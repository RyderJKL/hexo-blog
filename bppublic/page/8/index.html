<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="onejustone&apos;s blog">
<meta property="og:type" content="website">
<meta property="og:title" content="onejustone">
<meta property="og:url" content="http://yoursite.com/page/8/index.html">
<meta property="og:site_name" content="onejustone">
<meta property="og:description" content="onejustone&apos;s blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="onejustone">
<meta name="twitter:description" content="onejustone&apos;s blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/8/">





  <title>onejustone</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">onejustone</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">--愿你内心有种不灭的火焰，将你与别人区分开来--</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/08/React(1)快速概览/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="onejustonee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="onejustone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/08/React(1)快速概览/" itemprop="url">React(1)之快速概览</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-08T00:00:00+08:00">
                2017-02-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/technology/" itemprop="url" rel="index">
                    <span itemprop="name">technology</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="0x00-JSX"><a href="#0x00-JSX" class="headerlink" title="0x00 JSX"></a>0x00 JSX</h3><p>JSX 是 JavaScriptXML 的缩写，基于ECMAScript的一种新特性（并不是一种新语言），一种定义带属性树结构（DOM结构）的语法，它并不是 XML 或者 HTML。</p>
<hr>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>可以把 JSX 标签当做一个变量,而在 React 中，一个标签就是一个组件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const div = &lt;div&gt;hello,world&lt;/div&gt;;</span><br><span class="line">ReactDOM.render(div, document.body);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 JSX 中，所有标签必需严格闭合。</p>
</blockquote>
<p>自定义标签首字母必需大写，而且对于标签中自定义属性,事件等命名必需使用 <code>camelCase</code> 方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const add = function () &#123;&#125;;</span><br><span class="line">&lt;Welcome onClic=&#123;add&#125;className=&quot;this.props.name&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>JSX 语法解析规则是: 遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析。但并不是所有的 JavaScript 语法都能被解析，比如 <code>if</code> 语句就不可以。</p>
<h5 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h5><p>如果要在 JSX 中使用条件判断，可以使用三目运算符或者使用函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div calssName=&#123;&quot;this.sate.isCompelte ? &apos;is-complete&apos; : &apos;&apos;&#125;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h5 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const myName = &quot;Jack&quot;;</span><br><span class="line">function getId (props) &#123;</span><br><span class="line">    return props.id;</span><br><span class="line">&#125;</span><br><span class="line">const isDiv = &lt;div id=&#123;getid()&#125;&gt;&#123; &quot;Your Name:&quot; + myName&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>如上，JSX 中可以对组件中的属性使用变量或函数，这一点是不同于 HTML 的。</p>
<h5 id="使用-Array"><a href="#使用-Array" class="headerlink" title="使用 Array"></a>使用 Array</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const names = [&quot;Alice&quot;, &quot;Jack&quot;];</span><br><span class="line"></span><br><span class="line">    function ListItems (props) &#123;</span><br><span class="line">        const names = props.names;</span><br><span class="line">        return (</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        names.map( (name) =&gt; &#123;</span><br><span class="line">                            return &lt;li key=&#123;name.toString()&#125;&gt;&#123;name&#125;&lt;/li&gt;;</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReactDOM.render(</span><br><span class="line">        &lt;ListItems names=&#123;names&#125;/&gt;,</span><br><span class="line">        document.getElementById(&apos;root&apos;)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意 <li> 标签中的 key 属性，在使用具有 Iterator 接口或者数组等源数据生成多个重复的组件时，key 属性是必须的，而且应该是唯一的，这将有利于 React 识别唯一组件进行渲染。</li></p>
</blockquote>
<hr>
<h3 id="0x01-安装-React"><a href="#0x01-安装-React" class="headerlink" title="0x01 安装 React"></a>0x01 安装 React</h3><p>一个基本的 React 应用需要 <code>react</code> 和 <code>react-dom</code> 库:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">λ mkdir MyReact</span><br><span class="line">λ npm install -y</span><br><span class="line">λ  npm install react react-dom --save-dev</span><br><span class="line">λ  npm install babel@5 --save-dev</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="0x01-组件和属性集"><a href="#0x01-组件和属性集" class="headerlink" title="0x01 组件和属性集"></a>0x01 组件和属性集</h3><p>React 中可以使用函数或者类继承自 <code>React.Component</code> 来构建组件。</p>
<hr>
<h4 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Welcome (props) &#123;</span><br><span class="line">    return &lt;h1&gt;Hllo, &#123;props.name&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Welcome name=&quot;Jack&quot;/&gt;,</span><br><span class="line">    document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class LittleComponent extends React.Component &#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">         return &lt;div&gt;&#123;this.props.name&#125;&lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;LittleComponent name=&quot;Jack&quot;/&gt;,</span><br><span class="line">    document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 React <code>props</code> 对象是只读的， 无论是函数还是类，都不能改变自己的属性(props)，而所有 React 组件都必须像纯函数那样运行。</p>
</blockquote>
<p>当然，还是有例外的，比如网络响应组件这些状态可能随时变化的组件不适用这一规则。</p>
<hr>
<h3 id="0x02-状态和生命周期"><a href="#0x02-状态和生命周期" class="headerlink" title="0x02 状态和生命周期"></a>0x02 状态和生命周期</h3><p><code>state</code> 是只有类组件拥有的特性，<code>state</code> 状态和 <code>props</code> 属性集类似，但是 <code>state</code> 是私有的并且完全由组件控制。</p>
<p><code>state</code> 存在存在于组件的生命周期之中。React 提供了两个特别的方法 <code>componentDidMount()</code> 和 <code>componentWillUnmout()</code> 作为 <code>lifecycle hooks</code> 生命周期钩子去赋予和结束生命周期。</p>
<p><code>componentDidMount</code> 会在组件 <code>render</code> 之后被自动调用，而 <code>componentWillUnmount</code>会在组件被移除时自动调用。</p>
<p>下面是 React 官网的 example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Clock extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">constructor(props)&#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;date: new Date()&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentDidMount () &#123;</span><br><span class="line">    this.timerId = setInterval(</span><br><span class="line">        () =&gt; this.tick(),</span><br><span class="line">        1000</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentWillUnmount() &#123;</span><br><span class="line">    clearInterval(this.timerId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tick ()&#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">        date: new Date()</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render()&#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;Hello,world!&lt;/h1&gt;</span><br><span class="line">            &lt;h2&gt;It is: &#123;this.state.date.toLocaleTimeString()&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Clock/&gt;,</span><br><span class="line">   document.querySelector(&apos;#root&apos;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/07/JS设计模式(4)发布-订阅模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="onejustonee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="onejustone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/07/JS设计模式(4)发布-订阅模式/" itemprop="url">JS设计模式(4)发布-订阅模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-07T00:00:00+08:00">
                2017-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/technology/" itemprop="url" rel="index">
                    <span itemprop="name">technology</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布/订阅模式"></a>发布/订阅模式</h3><p>观察者模式(Observer Pattern)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。。这是设计模式中最常用的一种模式了。最简单的JavaScript 中事件就是一种观察者模式。</p>
<p>观察者模式由主体(被观察者)和观察者两个对象组成。主体负责发布事件（这时可以认为主体是个生产者），同时观察者通过订阅这些事件来观察主体。</p>
<p>下面是一个发布订阅模式的一个通用实现。</p>
<hr>
<h3 id="发布订阅模式的通用实现"><a href="#发布订阅模式的通用实现" class="headerlink" title="发布订阅模式的通用实现"></a>发布订阅模式的通用实现</h3><p>以 &lt;<javascript 高级程序设计="">&gt; 中的自定义事件为例:</javascript></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">function EventTarget() &#123;</span><br><span class="line">      // EventTarget 其实就是发布者（主体），也可以理解为母体，因为是通用模式，她将构造出所有发布者</span><br><span class="line"></span><br><span class="line">    this.handlers = &#123;&#125;</span><br><span class="line">    // 存放订阅者的消息(回调函数)的缓存对象</span><br><span class="line">    // handlers 用于存储事件处理程序的缓存对象</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  EventTarget.prototype = &#123;</span><br><span class="line">    constructor: EventTarget,</span><br><span class="line">    addHandler: function (type,handler/*接收两个参数:自定的事件类型和事件处理程序*/) &#123;</span><br><span class="line">      if (typeof this.handlers[type] === &apos;undefined&apos;) &#123;</span><br><span class="line">          // 初次判断，是否存在该类型的消息</span><br><span class="line">        this.handlers[type] = [];</span><br><span class="line">        // 为每一种事件类型建立一个事件类型数组</span><br><span class="line">      &#125;</span><br><span class="line">      this.handlers[type].push(handler)</span><br><span class="line">      // 将订阅的消息存放进缓存列表</span><br><span class="line">      // 将对应的事件处理函数推入到事件类型数组中</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    fire:function (event) &#123;</span><br><span class="line">      // 发布消息</span><br><span class="line">      console.log(this)</span><br><span class="line">      event.target || (event.target = this)</span><br><span class="line">      // 为自定义事件构造 event 对象</span><br><span class="line">      if (this.handlers[event.type] instanceof Array)&#123;</span><br><span class="line">          // 如何消息池中没有消息，就什么都不干</span><br><span class="line">        var handlers = this.handlers[event.type];</span><br><span class="line">        // 获取要发布的消息类型</span><br><span class="line">        for(var i = 0;i&lt; handlers.length;i++)&#123;</span><br><span class="line">          handlers[i](event);</span><br><span class="line">          // 发布消息</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    removeHandler:function (type,handler) &#123;</span><br><span class="line">        // 取消订阅</span><br><span class="line">      if(this.handlers[type] instanceof Array) &#123;</span><br><span class="line">        var i = this.handlers[type].indexOf(handler)</span><br><span class="line">        if (i &gt; -1) &#123;</span><br><span class="line">          this.handlers[type].splice(i,1)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">subject = new EventTarget()</span><br><span class="line">// 新建一个主体，即发布者，一个发布者可以对应多个订阅者</span><br><span class="line"></span><br><span class="line">function message1(event) &#123;</span><br><span class="line">  console.log(event.message)</span><br><span class="line">&#125;</span><br><span class="line">function message2(event) &#123;</span><br><span class="line">  console.log(event.message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function message3(event) &#123;</span><br><span class="line">  event.message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">observable1 = subject.addHandler(&apos;sayHello&apos;, message1)</span><br><span class="line">// 订阅者二 订阅 sayHello 种类的消息，消息的内容是 message1</span><br><span class="line">observabler2 = subject.addHandler(&apos;sayWorld&apos;, message2)</span><br><span class="line">  // 订阅者二 订阅 sayWorld 种类的消息，消息的内容是 message2</span><br><span class="line">observabler3 = subject.addHandler(&apos;say&apos;, message3)</span><br><span class="line">// 订阅者三 订阅 say 种类的消息，消息的内容是 message3</span><br><span class="line"></span><br><span class="line">/*先订阅消息，才能发布消息*/</span><br><span class="line"></span><br><span class="line">subject.fire(&#123;</span><br><span class="line">      /*fire 的参数就是 event 对象，</span><br><span class="line">      通过在 fire 内部对 event 对象的改造，</span><br><span class="line">      使得 event 对象最少具有 target 和 type 属性。</span><br><span class="line">      然后将 event 对象传递给订阅者，即是要发布的消息</span><br><span class="line">      */</span><br><span class="line">      // 发布 message 消息</span><br><span class="line">      type:&apos;sayHello&apos;,</span><br><span class="line">      message: &apos;hello&apos;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  subject.fire(&#123;</span><br><span class="line">      // 发布 message2 消息</span><br><span class="line">      type: &apos;sayWorld&apos;,</span><br><span class="line">      message: &apos;world&apos;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  subject.removeHandler(&apos;say&apos;,message3)</span><br><span class="line">  // 取消订阅 消息3</span><br></pre></td></tr></table></figure>
<p>总结下,实现一个通用类型的发布/订阅模式需要注意的几个点:</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/07/JS设计模式(3)代理模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="onejustonee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="onejustone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/07/JS设计模式(3)代理模式/" itemprop="url">JS设计模式(3)代理模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-07T00:00:00+08:00">
                2017-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/technology/" itemprop="url" rel="index">
                    <span itemprop="name">technology</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="0x00-代理模式"><a href="#0x00-代理模式" class="headerlink" title="0x00 代理模式"></a>0x00 代理模式</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/06/JS设计模式(0)漫话设计模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="onejustonee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="onejustone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/06/JS设计模式(0)漫话设计模式/" itemprop="url">JS设计模式(0)漫话设计模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-06T00:00:00+08:00">
                2017-02-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/technology/" itemprop="url" rel="index">
                    <span itemprop="name">technology</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="0x00-设计模式"><a href="#0x00-设计模式" class="headerlink" title="0x00 设计模式"></a>0x00 设计模式</h3><p>设计模式的定义的是：<em>在面向对象软件设计过程中针对特定问题的简洁而又优雅的解决方案</em>。</p>
<p>俗一点，设计模式就是套路，高逼格的套路，但是这种套路是有用，它给出了在某种场合下对某个问题的一种解决方案，更通俗一点，设计模式就是给面向对象软件开发中的一些好的设计取个好的名字。</p>
<p>因为一个好的设计方案只有有了名字之后，才能更好地传播，并使得人们有更多的机会去分享和学习他们。</p>
<p>但是从某些角度来看，设计模式可能会增加代码量，也会把系统的逻辑搞定更复杂。但是，只要当程序足够复杂，设计模式的作用便突显出现了，它会使得人们写出可复用性和可维护性更高的代码。</p>
<p>一个程序的设计总是可以分为可变的部分和不可变的部分。而所有设计模式的实现都遵循一条原则:<strong>查找程序中变化的部分，并将变化的部分封装起来</strong>。</p>
<hr>
<h3 id="0x01-JavaScript-中的设计模式"><a href="#0x01-JavaScript-中的设计模式" class="headerlink" title="0x01 JavaScript 中的设计模式"></a>0x01 JavaScript 中的设计模式</h3><p>对于不同的语言，相同的设计模式的差异还是很大的</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/06/JS设计模式(2)策略模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="onejustonee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="onejustone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/06/JS设计模式(2)策略模式/" itemprop="url">JS设计模式(2)策略模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-06T00:00:00+08:00">
                2017-02-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/technology/" itemprop="url" rel="index">
                    <span itemprop="name">technology</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="0x00-策略模式"><a href="#0x00-策略模式" class="headerlink" title="0x00 策略模式"></a>0x00 策略模式</h3><p><strong>策略模式</strong> 的定义是: <em>定义一系列算法，把他们一个个封装起来，并且使他们可以相互替换</em></p>
<hr>
<h3 id="0x01-策略模式实现缓动动画"><a href="#0x01-策略模式实现缓动动画" class="headerlink" title="0x01 策略模式实现缓动动画"></a>0x01 策略模式实现缓动动画</h3><p>策略模式的一个经典运用场景就是缓动动画。</p>
<p>其核心思想是使用策略模式把算法传入动画类库中，来达到给种不同的缓动效果，而这些算法可以轻易的被另一个算法替代。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let tween = &#123;</span><br><span class="line">// 动画类库，用于封装缓动算法</span><br><span class="line">//    	t:动画已经消耗的时间</span><br><span class="line">//        b:小球的原始位置</span><br><span class="line">//        c:小球目标位置</span><br><span class="line">//        d:动画持续的总时间</span><br><span class="line">    linear: function (t, b, c, d) &#123;</span><br><span class="line">        return c * t / d + b;</span><br><span class="line">    &#125;,</span><br><span class="line">    easeIn: function (t, b, c, d) &#123;</span><br><span class="line">        return c * (t /= d) * t + b;</span><br><span class="line">    &#125;,</span><br><span class="line">    strongEaseIn: function (t, b, c, d) &#123;</span><br><span class="line">        return c * (t /= d) * t * t * t * t + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="">完整代码:策略模式-缓动动画</a></p>
<hr>
<h3 id="0x02-策略模式实现表单验证"><a href="#0x02-策略模式实现表单验证" class="headerlink" title="0x02 策略模式实现表单验证"></a>0x02 策略模式实现表单验证</h3><p>其实，仅仅把策略模式用于封装算法有点大材小用，实际开发中，通常会把算法的含义扩散开来，使策略模式可以用来封装一系列的 <strong>业务规则</strong>。</p>
<p>在一个 Web 项目中，表单验证往往是在所难免的，当需要验证的字段很少的时候，比如几条，十几条，没问题，我们完全可以重复的使用 <code>if...else</code> 去验证表单字段，但如一个表单中的字段多大几十个，甚至上百个时，考虑到代码的可复用性和后期的可以维护性，便十分有必要使用一些模式去组织我们的代码了。 比如，策略模式。</p>
<p>使用策略模式编写表单校验代码的第一步就是将校验逻辑都封装成为策略对象:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">let strategies = &#123;</span><br><span class="line">    //	策略对象，封装验证表单的规则</span><br><span class="line">    isNotEmpty: function (value, errorMsg) &#123;</span><br><span class="line">        if (value == &apos;&apos;) &#123;</span><br><span class="line">            return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    minLength: function (value, length, errorMsg) &#123;</span><br><span class="line">        if (value.length &lt; length) &#123;</span><br><span class="line">            return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    legalPhone: function (value, errorMsg) &#123;</span><br><span class="line">        let regPhone = /^1[345678]\d&#123;9&#125;$/g;</span><br><span class="line">        if (!regPhone.test(value)) &#123;</span><br><span class="line">            return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    legalEmail: function (value, errorMsg) &#123;</span><br><span class="line">        let regEmail = /^\w&#123;1,18&#125;@([a-z][0-9])&#123;2,7&#125;.[a-z]&#123;2,4&#125;$/i;</span><br><span class="line">        if (!regEmail.test(value)) &#123;</span><br><span class="line">            return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后，我们会创建 <code>Validate</code> 类，它的作用是作为 <code>Context</code>，负者接收用户的输入并将用户输入的内容委托给 <code>strategy</code> 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">let validateFunc = function () &#123;</span><br><span class="line">//		validateFunc 执行表单验证函数</span><br><span class="line">//        添加验证规则</span><br><span class="line">    let validator = new Validate();</span><br><span class="line">    // 创建一个 Validate 类，作用是作为 `Context`，负者接收用户的输入并将用户输入的内容委托给 `strategy` 对象。</span><br><span class="line">    validator.add(regForm.userName, [</span><br><span class="line">        &#123;</span><br><span class="line">            strategy: &quot;isNotEmpty&quot;,</span><br><span class="line">            errorMsg: &quot;用户名不能为空&quot;,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            strategy: &quot;minLength:6&quot;,</span><br><span class="line">            errorMsg: &quot;密码长度不能小于六位&quot;</span><br><span class="line">        &#125;]);</span><br><span class="line">    validator.add(regForm.userPassword, [&#123;</span><br><span class="line">        strategy: &quot;minLength:6&quot;,</span><br><span class="line">        errorMsg: &quot;密码长度不能小于六位&quot;</span><br><span class="line">    &#125;]);</span><br><span class="line">    validator.add(regForm.phoneNumber, [&#123;</span><br><span class="line">        strategy: &quot;legalPhone&quot;,</span><br><span class="line">        errorMsg: &quot;手机号格式不正确&quot;</span><br><span class="line">    &#125;]);</span><br><span class="line">    validator.add(regForm.userEmail, [&#123;</span><br><span class="line">        strategy: &quot;legalEmail&quot;,</span><br><span class="line">        errorMsg: &quot;邮箱格式不正确&quot;</span><br><span class="line">    &#125;]);</span><br><span class="line"></span><br><span class="line">    return validator.start();</span><br><span class="line">    // 返回校验结果</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如上，<code>validate</code>  类的 <code>add</code> 方法用于向我们的 <code>strategy</code> 的对象添加校验规则，它接收两参数:参与校验的 <code>input</code> 输入框以及一个数组，数组中存放的是验证的策略规则和验证失败返回的提示信息。</p>
<p>下面是 <code>validate</code> 对象的具体实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">let Validate = function () &#123;</span><br><span class="line">    //  验证表单的类</span><br><span class="line">    // Validate 类作为 Context，负者接收用户的请求并委托给 strategies 对象</span><br><span class="line">    this.cache = [];</span><br><span class="line">//        保存验证规则的数组</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Validate.prototype = &#123;</span><br><span class="line">    constructor: Validate,</span><br><span class="line">    add: function (dom, rules) &#123;</span><br><span class="line">        //        规则关联，将规则与对应的元素进行绑定，并返回验证结果</span><br><span class="line"></span><br><span class="line">        let self = this;</span><br><span class="line">        for (let i =0, rule; rule = rules[i++];)&#123;</span><br><span class="line">            (function (rule) &#123;</span><br><span class="line">                let strategyArr = rule.strategy.split(&quot;:&quot;);</span><br><span class="line">                // 参数解析</span><br><span class="line">                let errorMsg = rule.errorMsg;</span><br><span class="line">                // 获取错误信息</span><br><span class="line">                self.cache.push(function() &#123;</span><br><span class="line">                    // 推入策略规则</span><br><span class="line">                    let strategy = strategyArr.shift();</span><br><span class="line">                    // 首先截取策略名称</span><br><span class="line">                    strategyArr.unshift(dom.value);</span><br><span class="line">                    // 添加 dom 的内容</span><br><span class="line">                    strategyArr.push(errorMsg);</span><br><span class="line">                    // 推入错误信息</span><br><span class="line">                    return strategies[strategy].apply(dom, strategyArr);</span><br><span class="line">                    // 信息策略，并返回校验结果</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;)(rule);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    start: function () &#123;</span><br><span class="line">        for (let i = 0, validaterFunc; validaterFunc = this.cache[i++];) &#123;</span><br><span class="line">            let msg = validaterFunc();</span><br><span class="line">            // 开始校验，并取得校验后的返回信息</span><br><span class="line">            if (msg) &#123;</span><br><span class="line">                // 如若有返回值，说明校验不成功</span><br><span class="line">                return msg;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当我们往 <code>validate</code> 对象添加完校验规则以后，便调用 <code>validate.start</code> 方法来启动校验，该方法返回的 <code>errorMsg</code> 字符串代表校验没有通过，那么便需要调用 <code>regForm.onsubmit</code> 方法返回 <code>false</code> 阻止表单的提交。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    regForm.onsubmit = function () &#123;</span><br><span class="line">        let errorMsg = validateFunc();</span><br><span class="line">        // 若，validateFunc 没有任何值返回，则代表校验通过</span><br><span class="line">        if (errorMsg) &#123;</span><br><span class="line">            alert(errorMsg);</span><br><span class="line">            return false;</span><br><span class="line">//          阻止表单提交</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><a href="---
title: JS设计模式(2"> 策略模式实现表单验证</a>策略模式<br>date: 2017-02-06<br>tags: [‘JavaScript’,’JS设计模式’]<br>toc: true<br>categories: technology</p>
<hr>
<h3 id="0x00-策略模式-1"><a href="#0x00-策略模式-1" class="headerlink" title="0x00 策略模式"></a>0x00 策略模式</h3><p><strong>策略模式</strong> 的定义是: <em>定义一系列算法，把他们一个个封装起来，并且使他们可以相互替换</em></p>
<hr>
<h3 id="0x01-策略模式实现缓动动画-1"><a href="#0x01-策略模式实现缓动动画-1" class="headerlink" title="0x01 策略模式实现缓动动画"></a>0x01 策略模式实现缓动动画</h3><p>策略模式的一个经典运用场景就是缓动动画。</p>
<p>其核心思想是使用策略模式把算法传入动画类库中，来达到给种不同的缓动效果，而这些算法可以轻易的被另一个算法替代。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let tween = &#123;</span><br><span class="line">// 动画类库，用于封装缓动算法</span><br><span class="line">//    	t:动画已经消耗的时间</span><br><span class="line">//        b:小球的原始位置</span><br><span class="line">//        c:小球目标位置</span><br><span class="line">//        d:动画持续的总时间</span><br><span class="line">    linear: function (t, b, c, d) &#123;</span><br><span class="line">        return c * t / d + b;</span><br><span class="line">    &#125;,</span><br><span class="line">    easeIn: function (t, b, c, d) &#123;</span><br><span class="line">        return c * (t /= d) * t + b;</span><br><span class="line">    &#125;,</span><br><span class="line">    strongEaseIn: function (t, b, c, d) &#123;</span><br><span class="line">        return c * (t /= d) * t * t * t * t + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="">完整代码:策略模式-缓动动画</a></p>
<hr>
<h3 id="0x02-策略模式实现表单验证-1"><a href="#0x02-策略模式实现表单验证-1" class="headerlink" title="0x02 策略模式实现表单验证"></a>0x02 策略模式实现表单验证</h3><p>其实，仅仅把策略模式用于封装算法有点大材小用，实际开发中，通常会把算法的含义扩散开来，使策略模式可以用来封装一系列的 <strong>业务规则</strong>。</p>
<p>在一个 Web 项目中，表单验证往往是在所难免的，当需要验证的字段很少的时候，比如几条，十几条，没问题，我们完全可以重复的使用 <code>if...else</code> 去验证表单字段，但如一个表单中的字段多大几十个，甚至上百个时，考虑到代码的可复用性和后期的可以维护性，便十分有必要使用一些模式去组织我们的代码了。 比如，策略模式。</p>
<p>使用策略模式编写表单校验代码的第一步就是将校验逻辑都封装成为策略对象:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">let strategies = &#123;</span><br><span class="line">    //	策略对象，封装验证表单的规则</span><br><span class="line">    isNotEmpty: function (value, errorMsg) &#123;</span><br><span class="line">        if (value == &apos;&apos;) &#123;</span><br><span class="line">            return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    minLength: function (value, length, errorMsg) &#123;</span><br><span class="line">        if (value.length &lt; length) &#123;</span><br><span class="line">            return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    legalPhone: function (value, errorMsg) &#123;</span><br><span class="line">        let regPhone = /^1[345678]\d&#123;9&#125;$/g;</span><br><span class="line">        if (!regPhone.test(value)) &#123;</span><br><span class="line">            return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    legalEmail: function (value, errorMsg) &#123;</span><br><span class="line">        let regEmail = /^\w&#123;1,18&#125;@([a-z][0-9])&#123;2,7&#125;.[a-z]&#123;2,4&#125;$/i;</span><br><span class="line">        if (!regEmail.test(value)) &#123;</span><br><span class="line">            return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后，我们会创建 <code>Validate</code> 类，它的作用是作为 <code>Context</code>，负者接收用户的输入并将用户输入的内容委托给 <code>strategy</code> 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">let validateFunc = function () &#123;</span><br><span class="line">//		validateFunc 执行表单验证函数</span><br><span class="line">//        添加验证规则</span><br><span class="line">    let validator = new Validate();</span><br><span class="line">    // 创建一个 Validate 类，作用是作为 `Context`，负者接收用户的输入并将用户输入的内容委托给 `strategy` 对象。</span><br><span class="line">    validator.add(regForm.userName, [</span><br><span class="line">        &#123;</span><br><span class="line">            strategy: &quot;isNotEmpty&quot;,</span><br><span class="line">            errorMsg: &quot;用户名不能为空&quot;,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            strategy: &quot;minLength:6&quot;,</span><br><span class="line">            errorMsg: &quot;密码长度不能小于六位&quot;</span><br><span class="line">        &#125;]);</span><br><span class="line">    validator.add(regForm.userPassword, [&#123;</span><br><span class="line">        strategy: &quot;minLength:6&quot;,</span><br><span class="line">        errorMsg: &quot;密码长度不能小于六位&quot;</span><br><span class="line">    &#125;]);</span><br><span class="line">    validator.add(regForm.phoneNumber, [&#123;</span><br><span class="line">        strategy: &quot;legalPhone&quot;,</span><br><span class="line">        errorMsg: &quot;手机号格式不正确&quot;</span><br><span class="line">    &#125;]);</span><br><span class="line">    validator.add(regForm.userEmail, [&#123;</span><br><span class="line">        strategy: &quot;legalEmail&quot;,</span><br><span class="line">        errorMsg: &quot;邮箱格式不正确&quot;</span><br><span class="line">    &#125;]);</span><br><span class="line"></span><br><span class="line">    return validator.start();</span><br><span class="line">    // 返回校验结果</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如上，<code>validate</code>  类的 <code>add</code> 方法用于向我们的 <code>strategy</code> 的对象添加校验规则，它接收两参数:参与校验的 <code>input</code> 输入框以及一个数组，数组中存放的是验证的策略规则和验证失败返回的提示信息。</p>
<p>下面是 <code>validate</code> 对象的具体实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">let Validate = function () &#123;</span><br><span class="line">    //  验证表单的类</span><br><span class="line">    // Validate 类作为 Context，负者接收用户的请求并委托给 strategies 对象</span><br><span class="line">    this.cache = [];</span><br><span class="line">//        保存验证规则的数组</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Validate.prototype = &#123;</span><br><span class="line">    constructor: Validate,</span><br><span class="line">    add: function (dom, rules) &#123;</span><br><span class="line">        //        规则关联，将规则与对应的元素进行绑定，并返回验证结果</span><br><span class="line"></span><br><span class="line">        let self = this;</span><br><span class="line">        for (let i =0, rule; rule = rules[i++];)&#123;</span><br><span class="line">            (function (rule) &#123;</span><br><span class="line">                let strategyArr = rule.strategy.split(&quot;:&quot;);</span><br><span class="line">                // 参数解析</span><br><span class="line">                let errorMsg = rule.errorMsg;</span><br><span class="line">                // 获取错误信息</span><br><span class="line">                self.cache.push(function() &#123;</span><br><span class="line">                    // 推入策略规则</span><br><span class="line">                    let strategy = strategyArr.shift();</span><br><span class="line">                    // 首先截取策略名称</span><br><span class="line">                    strategyArr.unshift(dom.value);</span><br><span class="line">                    // 添加 dom 的内容</span><br><span class="line">                    strategyArr.push(errorMsg);</span><br><span class="line">                    // 推入错误信息</span><br><span class="line">                    return strategies[strategy].apply(dom, strategyArr);</span><br><span class="line">                    // 信息策略，并返回校验结果</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;)(rule);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    start: function () &#123;</span><br><span class="line">        for (let i = 0, validaterFunc; validaterFunc = this.cache[i++];) &#123;</span><br><span class="line">            let msg = validaterFunc();</span><br><span class="line">            // 开始校验，并取得校验后的返回信息</span><br><span class="line">            if (msg) &#123;</span><br><span class="line">                // 如若有返回值，说明校验不成功</span><br><span class="line">                return msg;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当我们往 <code>validate</code> 对象添加完校验规则以后，便调用 <code>validate.start</code> 方法来启动校验，该方法返回的 <code>errorMsg</code> 字符串代表校验没有通过，那么便需要调用 <code>regForm.onsubmit</code> 方法返回 <code>false</code> 阻止表单的提交。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    regForm.onsubmit = function () &#123;</span><br><span class="line">        let errorMsg = validateFunc();</span><br><span class="line">        // 若，validateFunc 没有任何值返回，则代表校验通过</span><br><span class="line">        if (errorMsg) &#123;</span><br><span class="line">            alert(errorMsg);</span><br><span class="line">            return false;</span><br><span class="line">//          阻止表单提交</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><a href="---
title: JS设计模式(2"> 策略模式实现表单验证</a>策略模式<br>date: 2017-02-06<br>tags: [‘JavaScript’,’JS设计模式’]<br>toc: true<br>categories: technology</p>
<hr>
<h3 id="0x00-策略模式-2"><a href="#0x00-策略模式-2" class="headerlink" title="0x00 策略模式"></a>0x00 策略模式</h3><p><strong>策略模式</strong> 的定义是: <em>定义一系列算法，把他们一个个封装起来，并且使他们可以相互替换</em></p>
<hr>
<h3 id="0x01-策略模式实现缓动动画-2"><a href="#0x01-策略模式实现缓动动画-2" class="headerlink" title="0x01 策略模式实现缓动动画"></a>0x01 策略模式实现缓动动画</h3><p>策略模式的一个经典运用场景就是缓动动画。</p>
<p>其核心思想是使用策略模式把算法传入动画类库中，来达到给种不同的缓动效果，而这些算法可以轻易的被另一个算法替代。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let tween = &#123;</span><br><span class="line">// 动画类库，用于封装缓动算法</span><br><span class="line">//    	t:动画已经消耗的时间</span><br><span class="line">//        b:小球的原始位置</span><br><span class="line">//        c:小球目标位置</span><br><span class="line">//        d:动画持续的总时间</span><br><span class="line">    linear: function (t, b, c, d) &#123;</span><br><span class="line">        return c * t / d + b;</span><br><span class="line">    &#125;,</span><br><span class="line">    easeIn: function (t, b, c, d) &#123;</span><br><span class="line">        return c * (t /= d) * t + b;</span><br><span class="line">    &#125;,</span><br><span class="line">    strongEaseIn: function (t, b, c, d) &#123;</span><br><span class="line">        return c * (t /= d) * t * t * t * t + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/onejustone/JavaScriptDesignModel/blob/master/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-%E7%BC%93%E5%8A%A8%E5%8A%A8%E7%94%BB.html" target="_blank" rel="noopener">完整代码:策略模式-缓动动画</a></p>
<hr>
<h3 id="0x02-策略模式实现表单验证-2"><a href="#0x02-策略模式实现表单验证-2" class="headerlink" title="0x02 策略模式实现表单验证"></a>0x02 策略模式实现表单验证</h3><p>其实，仅仅把策略模式用于封装算法有点大材小用，实际开发中，通常会把算法的含义扩散开来，使策略模式可以用来封装一系列的 <strong>业务规则</strong>。</p>
<p>在一个 Web 项目中，表单验证往往是在所难免的，当需要验证的字段很少的时候，比如几条，十几条，没问题，我们完全可以重复的使用 <code>if...else</code> 去验证表单字段，但如一个表单中的字段多大几十个，甚至上百个时，考虑到代码的可复用性和后期的可以维护性，便十分有必要使用一些模式去组织我们的代码了。 比如，策略模式。</p>
<p>使用策略模式编写表单校验代码的第一步就是将校验逻辑都封装成为策略对象:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">let strategies = &#123;</span><br><span class="line">    //	策略对象，封装验证表单的规则</span><br><span class="line">    isNotEmpty: function (value, errorMsg) &#123;</span><br><span class="line">        if (value == &apos;&apos;) &#123;</span><br><span class="line">            return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    minLength: function (value, length, errorMsg) &#123;</span><br><span class="line">        if (value.length &lt; length) &#123;</span><br><span class="line">            return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    legalPhone: function (value, errorMsg) &#123;</span><br><span class="line">        let regPhone = /^1[345678]\d&#123;9&#125;$/g;</span><br><span class="line">        if (!regPhone.test(value)) &#123;</span><br><span class="line">            return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    legalEmail: function (value, errorMsg) &#123;</span><br><span class="line">        let regEmail = /^\w&#123;1,18&#125;@([a-z][0-9])&#123;2,7&#125;.[a-z]&#123;2,4&#125;$/i;</span><br><span class="line">        if (!regEmail.test(value)) &#123;</span><br><span class="line">            return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后，我们会创建 <code>Validate</code> 类，它的作用是作为 <code>Context</code>，负者接收用户的输入并将用户输入的内容委托给 <code>strategy</code> 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">let validateFunc = function () &#123;</span><br><span class="line">//		validateFunc 执行表单验证函数</span><br><span class="line">//        添加验证规则</span><br><span class="line">    let validator = new Validate();</span><br><span class="line">    // 创建一个 Validate 类，作用是作为 `Context`，负者接收用户的输入并将用户输入的内容委托给 `strategy` 对象。</span><br><span class="line">    validator.add(regForm.userName, [</span><br><span class="line">        &#123;</span><br><span class="line">            strategy: &quot;isNotEmpty&quot;,</span><br><span class="line">            errorMsg: &quot;用户名不能为空&quot;,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            strategy: &quot;minLength:6&quot;,</span><br><span class="line">            errorMsg: &quot;密码长度不能小于六位&quot;</span><br><span class="line">        &#125;]);</span><br><span class="line">    validator.add(regForm.userPassword, [&#123;</span><br><span class="line">        strategy: &quot;minLength:6&quot;,</span><br><span class="line">        errorMsg: &quot;密码长度不能小于六位&quot;</span><br><span class="line">    &#125;]);</span><br><span class="line">    validator.add(regForm.phoneNumber, [&#123;</span><br><span class="line">        strategy: &quot;legalPhone&quot;,</span><br><span class="line">        errorMsg: &quot;手机号格式不正确&quot;</span><br><span class="line">    &#125;]);</span><br><span class="line">    validator.add(regForm.userEmail, [&#123;</span><br><span class="line">        strategy: &quot;legalEmail&quot;,</span><br><span class="line">        errorMsg: &quot;邮箱格式不正确&quot;</span><br><span class="line">    &#125;]);</span><br><span class="line"></span><br><span class="line">    return validator.start();</span><br><span class="line">    // 返回校验结果</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如上，<code>validate</code>  类的 <code>add</code> 方法用于向我们的 <code>strategy</code> 的对象添加校验规则，它接收两参数:参与校验的 <code>input</code> 输入框以及一个数组，数组中存放的是验证的策略规则和验证失败返回的提示信息。</p>
<p>下面是 <code>validate</code> 对象的具体实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">let Validate = function () &#123;</span><br><span class="line">    //  验证表单的类</span><br><span class="line">    // Validate 类作为 Context，负者接收用户的请求并委托给 strategies 对象</span><br><span class="line">    this.cache = [];</span><br><span class="line">//        保存验证规则的数组</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Validate.prototype = &#123;</span><br><span class="line">    constructor: Validate,</span><br><span class="line">    add: function (dom, rules) &#123;</span><br><span class="line">        //        规则关联，将规则与对应的元素进行绑定，并返回验证结果</span><br><span class="line"></span><br><span class="line">        let self = this;</span><br><span class="line">        for (let i =0, rule; rule = rules[i++];)&#123;</span><br><span class="line">            (function (rule) &#123;</span><br><span class="line">                let strategyArr = rule.strategy.split(&quot;:&quot;);</span><br><span class="line">                // 参数解析</span><br><span class="line">                let errorMsg = rule.errorMsg;</span><br><span class="line">                // 获取错误信息</span><br><span class="line">                self.cache.push(function() &#123;</span><br><span class="line">                    // 推入策略规则</span><br><span class="line">                    let strategy = strategyArr.shift();</span><br><span class="line">                    // 首先截取策略名称</span><br><span class="line">                    strategyArr.unshift(dom.value);</span><br><span class="line">                    // 添加 dom 的内容</span><br><span class="line">                    strategyArr.push(errorMsg);</span><br><span class="line">                    // 推入错误信息</span><br><span class="line">                    return strategies[strategy].apply(dom, strategyArr);</span><br><span class="line">                    // 信息策略，并返回校验结果</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;)(rule);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    start: function () &#123;</span><br><span class="line">        for (let i = 0, validaterFunc; validaterFunc = this.cache[i++];) &#123;</span><br><span class="line">            let msg = validaterFunc();</span><br><span class="line">            // 开始校验，并取得校验后的返回信息</span><br><span class="line">            if (msg) &#123;</span><br><span class="line">                // 如若有返回值，说明校验不成功</span><br><span class="line">                return msg;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当我们往 <code>validate</code> 对象添加完校验规则以后，便调用 <code>validate.start</code> 方法来启动校验，该方法返回的 <code>errorMsg</code> 字符串代表校验没有通过，那么便需要调用 <code>regForm.onsubmit</code> 方法返回 <code>false</code> 阻止表单的提交。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    regForm.onsubmit = function () &#123;</span><br><span class="line">        let errorMsg = validateFunc();</span><br><span class="line">        // 若，validateFunc 没有任何值返回，则代表校验通过</span><br><span class="line">        if (errorMsg) &#123;</span><br><span class="line">            alert(errorMsg);</span><br><span class="line">            return false;</span><br><span class="line">//          阻止表单提交</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/onejustone/JavaScriptDesignModel/blob/master/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81.html" target="_blank" rel="noopener"> 策略模式实现表单验证</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/05/AngularJS(8)创建复杂指令/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="onejustonee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="onejustone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/05/AngularJS(8)创建复杂指令/" itemprop="url">AngularJS(8)创建复杂指令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-05T00:00:00+08:00">
                2017-02-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/technology/" itemprop="url" rel="index">
                    <span itemprop="name">technology</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="0x00-定义复杂指令"><a href="#0x00-定义复杂指令" class="headerlink" title="0x00 定义复杂指令"></a>0x00 定义复杂指令</h3><p>以下是自定义指令对象所定义的属性:</p>
<ul>
<li><code>link</code>: 为指令指定一链接函数；</li>
<li><code>compile</code>: 指定一个编译函数；</li>
<li><code>restrict</code>: 指定指令如何被使用；</li>
<li><code>template</code>: 指定一被嵌入到 HTML 文档的模板；</li>
<li><code>templateUrl</code>: 指定一个外部 HTML 模板；</li>
<li><code>scope</code>: 创建一个新的作用域或者隔离作用域；</li>
<li><code>controller</code>: 为指令创建一个控制器；</li>
<li><code>replace</code>: 指定模板内容是否替换指令所应用到的元素；</li>
<li><code>require</code>: 声明对某个控制器的依赖；</li>
<li><code>transclude</code>: 指令是否被用于包含任意内容。</li>
</ul>
<p>当指令只返回一个链接函数时，所创建的指令只能被当做一个属性来使用，此时，我们可以通过 <code>restrict</code> 属性来修改默认配置，其对应的属性值有 <code>E(将指令用作一个元素)</code>,<code>A(将指令用作一个属性)</code>,<code>C(将指令用作一个类)</code>,<code>M(将指令用作一个注释)</code>。</p>
<hr>
<h4 id="使用指令模板"><a href="#使用指令模板" class="headerlink" title="使用指令模板"></a>使用指令模板</h4><h5 id="使用-template"><a href="#使用-template" class="headerlink" title="使用 template"></a>使用 template</h5><p><a href="https://github.com/onejustone/SimpleAngularDemo/blob/master/src/AngularJS%E5%9F%BA%E7%A1%80/AngularJS(8" target="_blank" rel="noopener">清单8-1</a>%E5%88%9B%E5%BB%BA%E5%A4%8D%E6%9D%82%E6%8C%87%E4%BB%A4/%E6%B8%85%E5%8D%958-1.html)</p>
<p>生成一个模板，最简单的方式就是使用 <code>template</code> 属性，为其写入要生成的模板内容。</p>
<p>如上清单所示，其核心代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.directive(&quot;unorderedList&quot;, function () &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">		link: function (scope, ele, attrs) &#123;</span><br><span class="line">			scope.data = scope[attrs[&quot;unorderedList&quot;]];</span><br><span class="line">		&#125;,</span><br><span class="line">		restrict: &quot;A&quot;,</span><br><span class="line">		template: &quot;&lt;ul&gt;&lt;li ng-repeat=&apos;item in data&apos;&gt;&quot; +&quot;&#123;&#123;item.price | currency&#125;&#125;&lt;/li&gt;&lt;/ul&gt;&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>但是 <code>template</code> 属性的灵活性也是显而易见的，就是并不怎么灵活。所以 AngularJS 还提供了 <code>templateUrl</code> 属性以提供外部来进行指令渲染。</p>
<h5 id="使用-tempateUrl"><a href="#使用-tempateUrl" class="headerlink" title="使用 tempateUrl"></a>使用 tempateUrl</h5><p><a href="https://github.com/onejustone/SimpleAngularDemo/blob/master/src/AngularJS%E5%9F%BA%E7%A1%80/AngularJS(8" target="_blank" rel="noopener">清单8-2</a>%E5%88%9B%E5%BB%BA%E5%A4%8D%E6%9D%82%E6%8C%87%E4%BB%A4/%E6%B8%85%E5%8D%958-2.html)</p>
<p>如上清单所示，其核心代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.directive(&quot;unorderedList&quot;, function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        link: function (scope, ele, attrs) &#123;</span><br><span class="line">            scope.data = scope[attrs[&quot;unorderedList&quot;]];</span><br><span class="line">        &#125;,</span><br><span class="line">        restrict: &quot;A&quot;,</span><br><span class="line">        templateUrl: &quot;itemTemplate.html&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当然，我们还可以更灵活的使用 <code>templateUrl</code> 属性，即是为其指定一个函数使其动态的选择需要展示自定义指令的模板。</p>
<p>传递给 <code>templateUrl</code> 属性的函数接收一个代表指令所应用的元素以及该元素上定义的属性集。</p>
<h5 id="使用-replace"><a href="#使用-replace" class="headerlink" title="使用 replace"></a>使用 replace</h5><p>默认情况下使用 <code>templateUrl</code> 指定的模板，将会作为指令所在元素的子元素被插入。为 <code>replace</code> 指定属性值 <code>true</code> 便会替换所在的父级元素。</p>
<hr>
<h3 id="0x01-管理指令作用域"><a href="#0x01-管理指令作用域" class="headerlink" title="0x01 管理指令作用域"></a>0x01 管理指令作用域</h3><p>简单的将，我们可以为自定义指令的 <code>scope</code> 属性设置为 <code>true</code>，从而为指令所应用到的每一个实例创建独立的作用域，这种方式使得我们在一定程度上减少了控制器的数量，即不用使用大量的控制器以分隔作用域就可以复用自定义指令，但是我们所定义的自定义指令仍然会受到顶层控制器的支配，作用域继承规则总是有效的。</p>
<hr>
<h4 id="单向数据绑定"><a href="#单向数据绑定" class="headerlink" title="单向数据绑定"></a>单向数据绑定</h4><p>我们渴望创建一纯粹独立的自定义指令，不受任何控制器或作用域层次上的继承关系的影响，以在任何地方重用该指令。解决的方案是将 <code>scope</code> 属性设置为对象，通过对对象定义的属性做修改便不会被传播到控制器作用域上，因此此时，作用域的隔离是从作用域层次结构上别隔离的，即指令和控制器之间的作用域没有任何关系。</p>
<p>在这种情况下，便可以自定义指令的中 <code>scope</code> 对象上的特殊属性 <code>@prop</code> 实现单项数据绑定(从控制器作用域流向自定义指令作用域):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/ng-template&quot; id=&quot;scopeTemplate&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;panel-body&quot;&gt;</span><br><span class="line">       &lt;p&gt;Data Value: &#123;&#123;local&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;div class=&quot;panel panel-default&quot; ng-controller=&quot;scopeCtrl&quot; &gt;</span><br><span class="line">    &lt;div class=&quot;panel-body&quot;&gt;</span><br><span class="line">        Direct binding: &lt;input ng-model=&quot;data.name&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;panel-body&quot; scope-demo=&quot;&quot; nameprop=&quot;&#123;&#123;+ &apos;from Chinese&apos;&#125;&#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">angular.module(&apos;exampleApp&apos;, [])</span><br><span class="line">    .directive(&quot;scopeDemo&quot;, function () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">        	template: function () &#123;</span><br><span class="line">                return angular.element(document.querySelector(&apos;#scopeTemplate&apos;)).html();</span><br><span class="line">	        &#125;,</span><br><span class="line">            scope: &#123;</span><br><span class="line">        		local: &apos;@nameprop&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).controller(&quot;scopeCtrl&quot;, function ($scope) &#123;</span><br><span class="line">        $scope.data = &#123;name: &quot;jack&quot;&#125;;</span><br><span class="line">        $scope.city = &quot;london&quot;;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/onejustone/SimpleAngularDemo/blob/master/src/AngularJS%E5%9F%BA%E7%A1%80/AngularJS(8" target="_blank" rel="noopener">清单8-3</a>%E5%88%9B%E5%BB%BA%E5%A4%8D%E6%9D%82%E6%8C%87%E4%BB%A4/%E6%B8%85%E5%8D%958-3.html)</p>
<hr>
<h4 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h4><p>当然， 我们还可以创出双向数据绑定，只需要使用 <code>=prop</code> 特性就可以了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Data Value: &lt;input ng-model=&quot;local&quot;&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">scope: &#123;</span><br><span class="line">      local: &apos;=nameprop&apos;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &lt;div class=&quot;panel-body&quot; scope-demo=&quot;&quot; nameprop=&quot;data.name&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="计算表达式"><a href="#计算表达式" class="headerlink" title="计算表达式"></a>计算表达式</h4><p>下面的 Demo 将演示，如何将控制器作用域中的函数与自定义指令进行关联，并对来自控制器作用域中的数据进行计算或传递给自定义指令。</p>
<p>需要使用 <code>&amp;Fnuc</code> 特性来讲所指定特性的值绑定到一个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/ng-template&quot; id=&quot;scopeTemplate&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;panel-body&quot;&gt;</span><br><span class="line">        &lt;p&gt;Name: &#123;&#123;local&#125;&#125;, City:&#123;&#123;cityFn(&#123;nameVal: local&#125;)&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">angular.module(&apos;exampleApp&apos;, [])</span><br><span class="line">	.directive(&quot;scopeDemo&quot;, function () &#123;</span><br><span class="line">		return &#123;</span><br><span class="line">			template: function () &#123;</span><br><span class="line">				return angular.element(document.querySelector(&apos;#scopeTemplate&apos;)).html();</span><br><span class="line">			&#125;,</span><br><span class="line">			scope: &#123;</span><br><span class="line">				local: &apos;=nameprop&apos;,</span><br><span class="line">                cityFn: &quot;&amp;city&quot;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;).controller(&quot;scopeCtrl&quot;, function ($scope) &#123;</span><br><span class="line">		$scope.data = &#123;</span><br><span class="line">			name: &quot;Jack&quot;,</span><br><span class="line">		    defaultCity: &quot;China&quot;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		$scope.getCity = function (name) &#123;</span><br><span class="line">            return name == &quot;Jack&quot; ? $scope.data.defaultCity : &quot;Unknown&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">    &lt;div class=&quot;panel-body&quot; scope-demo=&quot;&quot; city=&quot;getCity(nameVal)&quot; nameprop=&quot;data.name&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/onejustone/SimpleAngularDemo/blob/master/src/AngularJS%E5%9F%BA%E7%A1%80/AngularJS(8" target="_blank" rel="noopener">清单8-4</a>%E5%88%9B%E5%BB%BA%E5%A4%8D%E6%9D%82%E6%8C%87%E4%BB%A4/%E6%B8%85%E5%8D%958-4.html)</p>
<hr>
<h4 id="使用隔离作用域的数据"><a href="#使用隔离作用域的数据" class="headerlink" title="使用隔离作用域的数据"></a>使用隔离作用域的数据</h4><p>最后，可以为表达式传递一个控制器作用域上没有被定义过的属性名，来实现将隔离作用域的数据作为控制器作用域表达的一部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--修改指令模板数据--&gt;</span><br><span class="line">&lt;p&gt;Name: &#123;&#123;local&#125;&#125;, City:&#123;&#123;cityFn(&#123;nameVal: local&#125;)&#125;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--修改指令实例--&gt;</span><br><span class="line">&lt;div class=&quot;panel-body&quot; scope-demo=&quot;&quot; city=&quot;getCity(nameVal)&quot; nameprop=&quot;data.name&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/04/AngularJS(6)使用过滤器/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="onejustonee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="onejustone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/04/AngularJS(6)使用过滤器/" itemprop="url">AngularJS(6)使用过滤器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-04T00:00:00+08:00">
                2017-02-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/technology/" itemprop="url" rel="index">
                    <span itemprop="name">technology</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="0x00-关于过滤器"><a href="#0x00-关于过滤器" class="headerlink" title="0x00 关于过滤器"></a>0x00 关于过滤器</h3><p>过滤器在数据从作用域传递到指令上时进行转换，但不改变源数据，这样可以允许同一份数据在应用中以不同的形式展示。</p>
<p>理论上，过滤器可以执行任何类型的转换，但是大多情况下用于格式化或者对数据以某种顺序排序。</p>
<hr>
<h3 id="0x01-过滤单个数据的值"><a href="#0x01-过滤单个数据的值" class="headerlink" title="0x01 过滤单个数据的值"></a>0x01 过滤单个数据的值</h3><p>AngularJS 有两种类型的内置过滤器:一类对单个数据值，另一类对数据集合进行操作。</p>
<p>用于单个数据的内置过滤器：</p>
<ul>
<li><code>currency</code>: 对货币值进行格式化；</li>
<li><code>date</code>: 对时间进行格式化；</li>
<li><code>json</code>: 从 JSON 字符串中生成一个对象；</li>
<li><code>number</code>: 对数字值进行格式化；</li>
<li><code>uppercase</code>，<code>lowercase</code>：大小写格式化。</li>
</ul>
<blockquote>
<p>过滤器可以进行链式调用，这样便可以使用多个过滤器按照一定的顺序对同一数据进行操作。</p>
</blockquote>
<hr>
<h3 id="0x02-过滤集合"><a href="#0x02-过滤集合" class="headerlink" title="0x02 过滤集合"></a>0x02 过滤集合</h3><p>AngularJS 包含了三个内置的集合过滤器: </p>
<ul>
<li><code>limitTo</code>: 从一个数组中选出一定数量的对象；</li>
<li><code>filter</code>: 从数组中选取对象；</li>
<li><code>orderBy</code>: 对数组中的对象进行排序。</li>
</ul>
<hr>
<h4 id="限制项目数量"><a href="#限制项目数量" class="headerlink" title="限制项目数量"></a>限制项目数量</h4><p><code>limitTo</code> 过滤器可以限制从一个数据对象构成的数组中取出的项目的数量。</p>
<p><a href="https://github.com/onejustone/SimpleAngularDemo/blob/master/src/AngularJS(6" target="_blank" rel="noopener">清单6-1</a>%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8/%E6%B8%85%E5%8D%956-1.html)</p>
<p>如上清单所示，其核心代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$scope.limitVal = &quot;5&quot;;</span><br><span class="line">$scope.limitRange = [];</span><br><span class="line">for(let i = (0 - $scope.products.length); i &lt;= $scope.products.length;i ++)&#123;</span><br><span class="line">  	$scope.limitRange.push(i.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Limit: &lt;select ng-model=&quot;limitVal&quot; ng-options=&quot;item for item in limitRange&quot;&gt;&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;tr ng-repeat=&quot;p in products | limitTo:limitVal&quot;&gt;</span><br></pre></td></tr></table></figure>
<p><code>limitTo</code> 过滤器的值被指定为一个变量。而当该变量为负数时，例如 -5，过滤器会从数组中选出最后的五个对象。</p>
<hr>
<h4 id="选取项"><a href="#选取项" class="headerlink" title="选取项"></a>选取项</h4><p><code>filter</code> 过滤器用于从数组中选出一些对象。选取的条件可以是表达式，一个匹配属性值的  <code>map</code> 对象，或者一个函数。</p>
<p>比如，使用 <code>map</code> 对象选取对象:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr ng-repeat=&quot;p in products | filter: &#123;category: &apos;Fish&apos;&#125; | limitTo:limitVal&quot;&gt;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/onejustone/SimpleAngularDemo/blob/master/src/AngularJS(6" target="_blank" rel="noopener">清单6-2</a>%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8/%E6%B8%85%E5%8D%956-2.html)</p>
<hr>
<h4 id="对项目排序"><a href="#对项目排序" class="headerlink" title="对项目排序"></a>对项目排序</h4><p><code>orderBy</code> 过滤器可对数组中的对象进行排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr ng-repeat=&quot;p in products | limitTo:limitVal | orderBy: &apos;-price&apos;&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>在只设定了一个属性名的情况下，相当于隐式的请求过滤器为对象进行生序排序，可以通过使用 <code>+</code> 或 <code>-</code> 字符来设置排序顺序。</p>
<blockquote>
<p>注意此处的属性名使用了引号: ‘price’ 而不是 price。没有引号，过滤器会将该属性看作一个作用域变量或者控制器变量。</p>
</blockquote>
<p>当然，按照某个属性的值进行排序是最简单的一种方式，<code>orderBy</code> 过滤器也能使用一个函数进行排序，用于排序的函数需要传入一个数据数组中的对象，然后再返回一个在排序时用于参考的对象或者值。</p>
<p><a href="https://github.com/onejustone/SimpleAngularDemo/blob/master/src/AngularJS(6" target="_blank" rel="noopener">清单6-3</a>%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8/%E6%B8%85%E5%8D%956-3.html)</p>
<p>函数 <code>myCustomSorter</code> 的作用是将 <code>expiry</code> 值小于 100 的项放到数据数组的前面。</p>
<p>最后，<code>orderBy</code> 还支持使用多个谓语进行排序，即通过为 <code>orderBy</code> 过滤器配置为使用一个属性名或者函数名构成的数组，用于依次进行排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr ng-repeat=&quot;p in products | orderBy: [myCustomeSorter, &apos;-price&apos;]&quot;&gt;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/onejustone/SimpleAngularDemo/blob/master/src/AngularJS(6" target="_blank" rel="noopener">清单6-4</a>%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8/%E6%B8%85%E5%8D%956-4.html)</p>
<hr>
<h3 id="0x03-使用自定义过滤器"><a href="#0x03-使用自定义过滤器" class="headerlink" title="0x03 使用自定义过滤器"></a>0x03 使用自定义过滤器</h3><p>过滤器由 <code>Module.filter</code> 方法创建，该方法接收两个参数:过滤器名称和一个工厂函数，该函数用于创建实际工作的 work 函数。</p>
<hr>
<h4 id="创建格式化数据值的过滤器"><a href="#创建格式化数据值的过滤器" class="headerlink" title="创建格式化数据值的过滤器"></a>创建格式化数据值的过滤器</h4><p><a href="https://github.com/onejustone/SimpleAngularDemo/blob/master/src/AngularJS(6" target="_blank" rel="noopener">清单6-5</a>%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8/%E6%B8%85%E5%8D%956-5.html)</p>
<p>如上，在清单中创建了 <code>labelCase</code> 过滤器，它会将一个字符串格式化为只有首字母是大写的。</p>
<p>在将该过滤器应用于 category 属性时指定了配置项为 <code>true</code>,将会颠倒过滤器所应用的大小写转换过程。</p>
<hr>
<h4 id="创建一个集合过滤器"><a href="#创建一个集合过滤器" class="headerlink" title="创建一个集合过滤器"></a>创建一个集合过滤器</h4><p><a href="https://github.com/onejustone/SimpleAngularDemo/blob/master/src/AngularJS(6" target="_blank" rel="noopener">清单6-6</a>%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8/%E6%B8%85%E5%8D%956-6.html)</p>
<p>如清单中所示，过滤器 <code>skip</code> 将会跳过数组对象中的前两项并选出之后的五项。</p>
<hr>
<h4 id="组合过滤器"><a href="#组合过滤器" class="headerlink" title="组合过滤器"></a>组合过滤器</h4><p>我们可以在已有过滤器的基础上将多个过滤器的功能合并到单个过滤器中。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.filter(&quot;take&quot;, function ($filter) &#123;</span><br><span class="line">	return function (data, skipCount, takeCount) &#123;</span><br><span class="line">		let skippedData = $filter(&quot;skip&quot;)(data, skipCount);</span><br><span class="line">		return $filter(&quot;limitTo&quot;)(skippedData, takeCount);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如上，首先在工厂函数中声明对 <code>$filter</code> 服务的依赖，如此便可以访问模块中所有已经定义的过滤器。</p>
<p>过滤器在工人函数中通过名称来访问和调用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let skippedData = $filter(&quot;skip&quot;)(data, skipCount);</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/onejustone/SimpleAngularDemo/blob/master/src/AngularJS(6" target="_blank" rel="noopener">清单6-7</a>%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8/%E6%B8%85%E5%8D%956-7.html)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/04/AngularJS(7)创建自定义指令/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="onejustonee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="onejustone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/04/AngularJS(7)创建自定义指令/" itemprop="url">AngularJS(7)创建自定义指令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-04T00:00:00+08:00">
                2017-02-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/technology/" itemprop="url" rel="index">
                    <span itemprop="name">technology</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="0x00-创建自定义指令"><a href="#0x00-创建自定义指令" class="headerlink" title="0x00 创建自定义指令"></a>0x00 创建自定义指令</h3><p>使用 <code>Module.directive</code> 方法来创建自定义指令，接收的两个参数是:要创建的新指令的名称和一个用于创建该指令的工厂函数。</p>
<p>同样工厂函数会返回一个 <code>worker</code> 函数，在自定义指令中，这个 <code>worker</code> 函数被称为链接函数，它提供了将指令与 HTML 文档和作用域数据相连接的方法。</p>
<hr>
<h4 id="链接函数"><a href="#链接函数" class="headerlink" title="链接函数"></a>链接函数</h4><p>链接函数接收三个参数:指令被应用到的视图的作用域(<code>scope</code>)，指令被应用到的 HTML 元素(<code>element</code>)，以及 HTML 元素的属性(<code>attrs</code>)。</p>
<blockquote>
<p>scope, element, attrs 参数是普通的 JavaScript 参数，而不是通过依赖注入提供的，这意味着被传入链接函数的对象的顺序应是固定的。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">angular.module(&quot;exampleApp&quot;, [])</span><br><span class="line">.directive(&quot;unorderedList&quot;, function()&#123;</span><br><span class="line">    return function (scope, element, attrs) &#123;</span><br><span class="line">      // do something</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后可以将指令当作一个属性来使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div unordered-list=&quot;products&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意属性名和传给 <code>directive</code> 方法的名称是不同的: unordered-list 和 unorderedList。传给方法的参数中每个大写字母被认为是属性名中一个独立的词，而每个词之间用一个连字符隔开。</p>
</blockquote>
<h5 id="从作用域获取数据"><a href="#从作用域获取数据" class="headerlink" title="从作用域获取数据"></a>从作用域获取数据</h5><p>与 AngularJS 控制器不同，自定义指令并不声明对 <code>$scope</code> 服务的依赖，传入的是指令被应用到的视图的控制器所创建的作用域。</p>
<p>这样设计的目的允许单个指令在一个应用程序中被使用多次，而每个应用程序可能是在作用域层次结构上不同作用域上工作的。</p>
<p>链接函数的第三个参数是一个按照名字索引的属性结合，要从作用域中获取数据，可以通过该参数获得对应的属性值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.directive(&quot;unorderedList&quot;, function()&#123;</span><br><span class="line">    console.log(&quot;dafa&quot;)</span><br><span class="line">    return function (scope, element, attrs) &#123;</span><br><span class="line">        let data = scope[attrs[&quot;unorderedList&quot;]];</span><br><span class="line">        if (angular.isArray(data))&#123;</span><br><span class="line">            console.log(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>从 <code>attrs</code> 集合中使用 <code>unorderedList</code> 作为 <code>key</code> 来获取相关值，然后传给 <code>scope</code> 对象来获取相关数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let data = scope[attrs[&quot;unorderedList&quot;]];</span><br></pre></td></tr></table></figure>
<h5 id="生成-HTML-元素"><a href="#生成-HTML-元素" class="headerlink" title="生成 HTML 元素"></a>生成 HTML 元素</h5><p>AngularJS 包含了一个裁剪版的 jQuery，成为 jqLite，他具备jQuery的大多数功能。</p>
<p>jqLite 的功能通过链接函数的 <code>element</code> 参数暴露出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (angular.isArray(data))&#123;</span><br><span class="line">    let listElem = angular.element(&quot;&lt;ul&gt;&quot;);</span><br><span class="line">    element.append(listElem);</span><br><span class="line">    for(let i =0;i &lt; data.length;i++)&#123;</span><br><span class="line">        listElem.append(angular.element(&apos;&lt;li&gt;&apos;).text(data[i].name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/onejustone/SimpleAngularDemo/blob/master/src/AngularJS(7" target="_blank" rel="noopener">清单7-1</a>%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/%E6%B8%85%E5%8D%957-1.html)</p>
<hr>
<h4 id="打破数据依赖"><a href="#打破数据依赖" class="headerlink" title="打破数据依赖"></a>打破数据依赖</h4><p>清单7-1 中的指令存在对于数据属性的依赖，因为它假定对象都有一个 <code>name</code> 属性。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listElem.append(angular.element(&apos;&lt;li&gt;&apos;).text(data[i].name));</span><br></pre></td></tr></table></figure>
<p>这种依赖将导致我们无法在别处或者其它应用程序钟使用该指令。</p>
<p>解决这个问题的最简单的办法是定义一个额外的属性，用来指定哪个属性值会被显示在 li 项目中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let data = scope[attrs[&quot;unorderedList&quot;]];</span><br><span class="line">let propertyName = attrs[&quot;listProperty&quot;];</span><br><span class="line">if (angular.isArray(data)) &#123;</span><br><span class="line">    let listElem = angular.element(&quot;&lt;ul&gt;&quot;);</span><br><span class="line">    element.append(listElem);</span><br><span class="line">    for (let i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">        listElem.append(angular.element(&apos;&lt;li&gt;&apos;).text(data[i][propertyName]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div unordered-list=&quot;products&quot; list-property=&quot;name&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/onejustone/SimpleAngularDemo/blob/master/src/AngularJS(7" target="_blank" rel="noopener">清单7-2</a>%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/%E6%B8%85%E5%8D%957-2.html)</p>
<p>添加一个额外的属性是最简单的方法，它存在的问题是无法灵活的应用指令，比如当为其添加一个过滤器时，自定义指令将被破坏。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div unordered-list=&quot;products&quot; list-property=&quot;price | currency&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>解决该问题的方案是使用 <code>scope.$eval()</code> 方法，让作用域将属值当作一个表达式来计算，该方法接收的是要计算的表达式和用于执行该计算的数据。</p>
<h5 id="计算表达式"><a href="#计算表达式" class="headerlink" title="计算表达式"></a>计算表达式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let propertyExpression = attrs[&quot;listProperty&quot;];</span><br><span class="line"></span><br><span class="line">for (let i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">    listElem.append(angular.element(&apos;&lt;li&gt;&apos;).text(scope.$eval(propertyExpression, data[i])));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/onejustone/SimpleAngularDemo/blob/master/src/AngularJS(7" target="_blank" rel="noopener">清单7-3</a>%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/%E6%B8%85%E5%8D%957-3.html)</p>
<hr>
<h4 id="处理数据变化"><a href="#处理数据变化" class="headerlink" title="处理数据变化"></a>处理数据变化</h4><p>上述所有的清单中，在 AngularJS 处理时 li 元素的内容就已经被设置了，并且在底层的数据变化时无法自动更新。</p>
<p><a href="https://github.com/onejustone/SimpleAngularDemo/blob/master/src/AngularJS(7" target="_blank" rel="noopener">清单7-4</a>%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/%E6%B8%85%E5%8D%957-4.html)</p>
<p>如上，在清单中当点击 <code>button</code> 按钮是，<code>price</code> 也将会逐次累加。 </p>
<p>其核心代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.directive(&quot;unorderedList&quot;, function () &#123;</span><br><span class="line">    return function (scope, element, attrs) &#123;</span><br><span class="line">        let data = scope[attrs[&quot;unorderedList&quot;]];</span><br><span class="line">        let propertyExpression = attrs[&quot;listProperty&quot;];</span><br><span class="line">        if (angular.isArray(data)) &#123;</span><br><span class="line">            let listElem = angular.element(&quot;&lt;ul&gt;&quot;);</span><br><span class="line">            element.append(listElem);</span><br><span class="line">            for (var i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">                ( function () &#123;</span><br><span class="line">                    let itemElement = angular.element(&apos;&lt;li&gt;&apos;);</span><br><span class="line">                    listElem.append(itemElement);</span><br><span class="line">                    var index = i;</span><br><span class="line">                    let watcherFn = function (watchScope) &#123;</span><br><span class="line">                        return watchScope.$eval(propertyExpression, data[index]);</span><br><span class="line">                    &#125;;</span><br><span class="line"></span><br><span class="line">                    scope.$watch(watcherFn,function (newValue, oldValue) &#123;</span><br><span class="line">                        itemElement.text(newValue);</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们使用了 <code>$watch</code> 方法来监控作用域中的变化，并定义了一个监听器函数 <code>watcheFn</code>,该函数然我们可以从容面对表达式中可能带有过滤器的数据值的情况。</p>
<p>每次 <code>watcherFn</code> 函数被重新计算时，该函数作为参数被传递给作用域，另外使用了 <code>$eval</code> 函数计算在使用的表达式。</p>
<p>然后将 <code>watcherFn</code> 函数传递个 <code>$watch</code> 函数并指定回调函数，该回调函数使用 jqLite 的 <code>text</code> 方法更新 <code>li</code> 元素的文本内容。</p>
<p>最后，归于 JavaScript 的特性，防止 <code>index</code> 被 <code>for</code> 循环的下一次迭代所更新，使用了 IIFE (即立即执行函数表达式)。</p>
<hr>
<h3 id="0x01-使用-jqLite"><a href="#0x01-使用-jqLite" class="headerlink" title="0x01 使用 jqLite"></a>0x01 使用 jqLite</h3><hr>
<h4 id="DOM-导航"><a href="#DOM-导航" class="headerlink" title="DOM 导航"></a>DOM 导航</h4><p>对于简单的指令通常并不需要对 DOM 进行导航，因为已经对链接函数传入 <code>element</code> 参数了，该参数代表的是指令所引用到的元素的 jqLite 对象。但对于一些更复杂的指令，仍然需要对元素层次结构进行遍历并定位或者更复杂的 DOM 操作。</p>
<p>以下是 DOM 导航的 jqLite 方法:</p>
<ul>
<li><code>children()</code>:  返回一组子元素(jqLite 对象)；</li>
<li><code>eq()</code>: 返回指定索引下的元素(jqLite 对象)；</li>
<li><code>find(tag)</code>: 按照指定的 tag 名称定位所有的后代元素(jqLite 对象)；</li>
<li><code>next()</code>: 获取下一个兄弟元素(jqLite 对象)；</li>
<li><code>parent()</code>: 返回父元素(jqLite 对象)。</li>
</ul>
<p><a href="https://github.com/onejustone/SimpleAngularDemo/blob/master/src/AngularJS(7" target="_blank" rel="noopener">清单7-5</a>%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/%E6%B8%85%E5%8D%957-5.html)</p>
<p>如上清单所示，其核心代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let items = element.children();</span><br><span class="line">for ( let i=0;i&lt;items.length;i++)&#123;</span><br><span class="line">    if (items.eq(i).text() == &quot;Oranges&quot;)&#123;</span><br><span class="line">        items.eq(i).css(&#123;&quot;font-weight&quot;:&quot;bold&quot;,&quot;color&quot;:&quot;red&quot;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，使用 <code>eq()</code> 方法将获得一个指定索引下的元素的 jqLite 对象。而不是将 jqLite 对象当做 JavaScript 数组来处理(例如 items[i])，因为这样得到的将是 <code>HTMLElement</code> 对象。</p>
<p>此外，值得注意的是，<code>children</code> 只会返回指定元素下的所有直接子元素，而不包括所有后代，要获得所有的后代元素可以使用 <code>find</code> 方法。</p>
<hr>
<h4 id="创建和移除元素"><a href="#创建和移除元素" class="headerlink" title="创建和移除元素"></a>创建和移除元素</h4><p>以下是用于创建和移除元素的 jqLite 方法:</p>
<ul>
<li><code>angular.element(html)</code>: 创建一个 jqLite 对象；</li>
<li><code>after(elem)</code>: 在元素后面插入内容；</li>
<li><code>append(elem)</code>: 将元素作为最后一个子元素插入；</li>
<li><code>clone()</code>: 复制一个 jqLite 对象；</li>
<li><code>prepend(elem)</code>: 将元素作为第一个子元素插入；</li>
<li><code>remove()</code>: 从 DOM 中删除 jqLite 对象的元素；</li>
<li><code>replaceWith(elem)</code>: 用指定元素替换调用方法的 jqLite 对象的元素；</li>
<li><code>wrap(elem)</code>: 使用特定元素包裹 jqLite 对象中的每个元素。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/02/JS离线应用与客户端存储/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="onejustonee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="onejustone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/02/JS离线应用与客户端存储/" itemprop="url">JS离线应用与客户端存储</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-02T00:00:00+08:00">
                2017-02-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/technology/" itemprop="url" rel="index">
                    <span itemprop="name">technology</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="0x00-离线检测"><a href="#0x00-离线检测" class="headerlink" title="0x00 离线检测"></a>0x00 离线检测</h3><p>前端开发者一直希望 Web 应用能够与传统的客户端应用同场竞技，起码做到只要设备有电就能使用。支持离线 Web 应用开发成为 HTML5 的另一个重点。</p>
<p>开发离线应用的第一步是要知道设备是在线还是离线，HTML5 为此定义了一个 <strong>navigator.onLine</strong> 属性，该值为 <code>true</code> 时表示设备能上网，为 <code>false</code> 表示设备不能上网。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (navigator.onLine) &#123;</span><br><span class="line">    // 正常工作</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 执行离线状态时的任务</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，为了更好的确认网络是否可用，HTML5 还定义了两个事件: <strong>online</strong> 和 <strong>offline</strong>。当网络从离线变为在线或者从在线变为离线时触发这两个事件。</p>
<p>这两个事件在 <code>window</code> 上触发:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(window, &quot;online&quot;, function () &#123;</span><br><span class="line">    console.log(&quot;Online&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">EventUtil.addHander(window, &quot;offline&quot;, function () &#123;</span><br><span class="line">    console.log(&quot;Offline&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="ox01-应用缓存"><a href="#ox01-应用缓存" class="headerlink" title="ox01 应用缓存"></a>ox01 应用缓存</h3><p>HTML5 的 <strong>应用缓存(application cache)</strong> 或者简称 <strong>appcache</strong>，是从浏览器的缓存中分离出来的一块缓存区。要想在这个缓存中保存数据，可以使用一个 <strong>描述文件(manifest file)</strong>, 列出要下载和缓存的资源。</p>
<p>下面是一个简单的描述文件示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"></span><br><span class="line">file.js</span><br><span class="line">file.css</span><br></pre></td></tr></table></figure>
<p>要将描述文件与页面关联起来，可以在 <code>&lt;html&gt;</code> 中的 <code>manifest</code> 属性中指定这个文件的路径:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;html manifest=&quot;/offline.manifest&quot;&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该文件的扩展名必须是 .appcache</p>
</blockquote>
<hr>
<h3 id="0x02-数据存储"><a href="#0x02-数据存储" class="headerlink" title="0x02 数据存储"></a>0x02 数据存储</h3><hr>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>HTTP Cookie， 通常直接叫做 Cookie，最初是在客户端用于存储会话信息的。该标准要求服务器对任意的 HTTP 请求发送 <strong>Set-Cookie</strong> HTTP 头作为响应的一部分，其中包含会话信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: name=value</span><br></pre></td></tr></table></figure>
<p>名称(name)和值(value)在传送时都必需是 URL 编码的，浏览器会存储这样的会话信息，并在之后通过为每个请求添加 <strong>Cookie</strong> HTTP 头将信息发送回服务器:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Cookie: name=value</span><br></pre></td></tr></table></figure>
<h5 id="cookie-的构成"><a href="#cookie-的构成" class="headerlink" title="cookie 的构成"></a>cookie 的构成</h5><ul>
<li><code>名称</code>: 一个唯一确定 cookie 的名称。虽然 cookie 的名称是不区分大小写的，但是部分浏览器还是有大小写限制的。cookie 的名称必须经过 URL 编码。</li>
<li><code>值</code>: 存储在 cookie 中的字符串值。值必需被 URL 编码。</li>
<li><code>域</code>: cookie 对于哪个域是有效的。</li>
<li><code>路径</code>: 对于指定域中的那个路径，应该向服务器发送 cookie。</li>
<li><code>失效时间</code>: 表示 cookie 何时应该被删除的时间戳。</li>
<li><code>安全标志</code>: 指定后，cookie 只有在使用 SSL 连接时才发送到服务器。</li>
</ul>
<p>每段信息都作为 <strong>Set-Cookie</strong> 头的一部分，使用 <code>分号</code> 加 <code>空格</code> 分隔每一段:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 Ok</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: name1=value1, name2=value2; expires=Mon, 22-Jan-08 GMT; domain=.wrox.com;path =/;secure;</span><br></pre></td></tr></table></figure>
<p>如上，我们设置了一个对所有 <code>wrox.ocm</code> 的子域和域名下所有页面都有效的 cookie。同时指定了 <code>secure</code> 标志，这个 cookie 只能通过 SSL 连接才能传输。</p>
<hr>
<h3 id="0x03-在JavaScript-中使用-cookie"><a href="#0x03-在JavaScript-中使用-cookie" class="headerlink" title="0x03 在JavaScript 中使用 cookie"></a>0x03 在JavaScript 中使用 cookie</h3><p>在 JavaScript 中对 cookie 的操作主要是使用 <code>document.cookie</code> 属性，并且在使用的时候最好使用 <code>encodeURIComponent()</code>  和 <code>decodeURIComponent()</code> 来进行编码和解码。</p>
<p>原始的 JavaScript 操作 cookie 并不直观，所有我们有必要去封装一个更加直观和可复用的 <strong>CookieUtil</strong> 对象，以实现基本的读取，写入和删除操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">let CookieUtil = &#123;</span><br><span class="line">	get: function (name) &#123;</span><br><span class="line">		// 根据 cookie 名获取相应的值</span><br><span class="line">		let cookieName = encodeURIComponent(name) + &quot;=&quot;;</span><br><span class="line">		// 将 cookie 加上 &quot;=&quot;</span><br><span class="line">		let cookieStart = document.cookie.indexOf(cookieName);</span><br><span class="line">		// 查找 cookie</span><br><span class="line">		let cookieValue = null;</span><br><span class="line"></span><br><span class="line">		if (cookieStart &gt; -1)&#123;</span><br><span class="line">			let cookieEnd = document.cookie.indexOf(&quot;;&quot;, cookieStart);</span><br><span class="line">			// 查找 cookieStart 之后的第一个分号(表示了该 cookie 的结束位置)</span><br><span class="line">			// 如果没有找到，则表示该 cookie 是字符中的最后一个，则余下的字符串都是 cookie 的值</span><br><span class="line">			if (cookieEnd == -1)&#123;</span><br><span class="line">				cookieEnd = document.cookie.length;</span><br><span class="line">			&#125;</span><br><span class="line">			cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd));</span><br><span class="line">			// 用 decodeURIComponent() 对 cookie 进行编码</span><br><span class="line">		&#125;</span><br><span class="line">		return cookieValue;</span><br><span class="line">		// 如果没有 cookie 则返回 null；</span><br><span class="line">	&#125;,</span><br><span class="line">	set: function(name, value, expires, path, domain, secure)&#123;</span><br><span class="line">		// 设置 cookie，根据使用参数的频率排序，只有前两个是必须的</span><br><span class="line">		let cookieText = encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(value);</span><br><span class="line">		if(expires instanceof Date)&#123;</span><br><span class="line">			cookieText += &quot;; expires=&quot; + expires.toGMTString();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (path)&#123;</span><br><span class="line">			cookieText += &quot;; path=&quot; + path;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (domain)&#123;</span><br><span class="line">			cookieText += &quot;; domain=&quot; + domain;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (secure)&#123;</span><br><span class="line">			cookieText += &quot;; secure&quot;;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		document.cookie = cookieText;</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	unset: function(name, path, domain, secure)&#123;</span><br><span class="line">		// 删除 cookie</span><br><span class="line">		this.set(name, &quot;&quot;, new Date(0), path, domain, secure);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CookieUtil.set(&quot;book&quot;, &quot;Professional JavaScript&quot;, &quot;/books/projects/&quot;,&quot;www.wrox.com&quot;, new Date(), secure);</span><br><span class="line">// 设置 cookie ，包括它的路径，域和失效时间，以及仅能使用SSL 链接</span><br><span class="line">alert(CookieUtil.get(&quot;book&quot;))</span><br><span class="line">CookieUtil.unset(&quot;book&quot;, &quot;/books/projects&quot;, &quot;www.www.wrox.com&quot;)</span><br><span class="line">// 删除 cookie</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Chrome 不允许本地保存 cookie，需设置，推荐使用 FireFox 进行测试</p>
</blockquote>
<hr>
<h4 id="关于-cookie-的思考"><a href="#关于-cookie-的思考" class="headerlink" title="关于 cookie 的思考"></a>关于 cookie 的思考</h4><p>首先 cookie 本身是不安全的，不应该在 cookie 中存储敏感信息，而且由于其受到浏览器的严格限制，注定其不能存储大容量的信息(5 kb)，即是我们可以通过子 cookie 的变种方案去打破单域名的 cookie 上限，但是 cookie 都会作为浏览器请求头发送，存储大量信息又势必会影响特定域的请求性能。</p>
<p>随着历史的推进渐渐的出现了一些新的存储机制。</p>
<hr>
<h3 id="0x04-WebStorage"><a href="#0x04-WebStorage" class="headerlink" title="0x04 WebStorage"></a>0x04 WebStorage</h3><p>WebStorage 提供了一种在 cookie 之外存储会话数据的途径，是一种可跨会话存储大容量数(5M)的机制。</p>
<p>最初的 WebStorage 规范包括了 <code>sessionStorage</code> 和 <code>globalStorage</code> 两个对象，但最后 <code>globalStorgae</code> 被废弃，取而代之的是 <code>localStorgae</code> (但某些浏览器仍然只支持 globalStorage)。它们都是 <strong>Storage</strong> 类型，并作为 <code>window</code> 对象的属性存在。</p>
<p><strong>Storage</strong> 类型提供如下方法:</p>
<ul>
<li>clear(): 删除所有值。(Firefox 没有实现)</li>
<li>getItem(): 根据指定的名字 <code>name</code> 获取对应的值。</li>
<li>setItem(): 为指定的 <code>name</code> 设置一个对应的值。</li>
<li>removeItem(): 删除 <code>name</code> 指定的键值对儿。</li>
<li>key(index) 获得 index　位处的值的名字。</li>
</ul>
<hr>
<h4 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h4><p>sessionStorage 对象存储特定于某个会话的数据，但也只会保存到浏览器关闭。此外，存储在 sessionStorage 中的数据只能由最初给对象存储数据的页面访问到，所以对多页面应用有限制。</p>
<p> 我们可以使用 <code>for-in</code> 循环来迭代 sessionStorage 中的值:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for ( let key in sessionStorage)&#123;</span><br><span class="line">   let value = sessionStorage.getItem(key);</span><br><span class="line">   console.log(key + &quot;=&quot; value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 要删除 sessionStorage 推荐使用 <code>removeItem()</code> 方法，而不是使用 <code>delete</code> 操作符:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.removeItem(&quot;book&quot;);</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h4><p> localStorage 是可以持久保存客户端数据。要访问同一个 localStorage 对象，页面必须来自同一个域名(子域名无效)，使用同一种协议，在同一个端口上。 </p>
<p> 其使用方法和 <code>sessionStorage</code> 一样，但为了兼容只支持 <code>globalStorage</code> 的浏览器，可以使用以下函数:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function getLocalStorage()&#123;</span><br><span class="line">   if (typeof localStorage == &quot;object&quot;)&#123;</span><br><span class="line">   return localStorage;</span><br><span class="line">   &#125; else if (typeof globalStorage == &quot;object&quot;)&#123;</span><br><span class="line">   return globalStorage[location.host];</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       throw new Error(&quot;Local storage not avaliable);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="0x05-使用-localStorage-缓存-js-和-css-代码"><a href="#0x05-使用-localStorage-缓存-js-和-css-代码" class="headerlink" title="0x05 使用 localStorage 缓存 js 和 css 代码"></a>0x05 使用 localStorage 缓存 js 和 css 代码</h3><p> 对于前端资源文件加载优化，一般就是 <strong>协商缓存(304)</strong>。即设置 <code>Cahe-Control</code> 里的 <code>max-age</code>，使页面资源请求返回 <code>304</code>，尽量延长资源的有效期，让浏览器直接使用本地缓存。</p>
<p> 这一招(协商缓存(304))对 PC 端很好用，但是对于移动端，因为手机会经常清除本地缓存，所以文件缓存的时间也不会长。</p>
<p> 这时 <strong>localStorage</strong> 就派上用场了。相对于 cookie 它可以存储大体积的数据，而且永久有效。如果把 JavaScript 和 CSS 资源存储在 localStorage 中，则可以省去 http 请求所消耗的时间。</p>
<hr>
<h4 id="使用-localStorage-面对的问题"><a href="#使用-localStorage-面对的问题" class="headerlink" title="使用 localStorage 面对的问题"></a>使用 localStorage 面对的问题</h4><h5 id="版本更新机制"><a href="#版本更新机制" class="headerlink" title="版本更新机制"></a>版本更新机制</h5><p> 普通的资源请求，可以根据 文件名 + md5 或者在资源链接后面加上特定的后缀做标识来判断是否需要更新资源。但如果使用 localStorage 则需要使用新的缓存更新机制。</p>
<h5 id="更新代码的脚手架"><a href="#更新代码的脚手架" class="headerlink" title="更新代码的脚手架"></a>更新代码的脚手架</h5><p> 我们还需要使用一个新的脚手架来管理资源文件的读取和写入。</p>
<h5 id="资源配置信息"><a href="#资源配置信息" class="headerlink" title="资源配置信息"></a>资源配置信息</h5><p> 于此对应的是后端需要输出一份依据给前端做判断用，即资源配置信息，前端更据配置信息，进行匹配和比较，最终决定使用 localStorage 缓存还是重新发起请求。</p>
<h5 id="XSS安全隐患"><a href="#XSS安全隐患" class="headerlink" title="XSS安全隐患"></a>XSS安全隐患</h5><p> 前端永远是不安全的。</p>
<p>最后推荐一个 <a href="https://mtjs.github.io" target="_blank" rel="noopener">MT 管理框架</a></p>
<hr>
<h3 id="0x06-更好的时代-Service-Worker"><a href="#0x06-更好的时代-Service-Worker" class="headerlink" title="0x06 更好的时代 Service Worker"></a>0x06 更好的时代 Service Worker</h3><p> App Cache有些 <a href="https://alistapart.com/article/application-cache-is-a-douchebag" target="_blank" rel="noopener">局限性</a>，例如它可以很容易地解决单页应用的问题，但是在多页应用上会很麻烦，而Service workers的出现正是为了解决App Cache的痛点。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/22/同源策略与CORS/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="onejustonee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="onejustone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/22/同源策略与CORS/" itemprop="url">同源策略与CORS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-22T12:45:00+08:00">
                2017-01-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/technology/" itemprop="url" rel="index">
                    <span itemprop="name">technology</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="0x00-同源策略"><a href="#0x00-同源策略" class="headerlink" title="0x00 同源策略"></a>0x00 同源策略</h3><p><strong>同源策略(Same-origin policy)</strong> 是浏览器安全的基石,其目的是为了保护用户信息的安全，具体点，同源指的是三个相同，<code>协议相同</code>, <code>域名相同</code>,<code>端口相同</code>。如果非同源，以下三种行为将会受到限制:</p>
<ul>
<li>Cookie,localStorage,和 IndexDB 无法读取</li>
<li>DOM 无法获得</li>
<li>AJAX 请求不能发送</li>
</ul>
<p>对于 Cookie 的限制，在以前，我们可以通过<code>document.domain</code> 来设置相同的域名以共享 Cookie。</p>
<p>也可以在服务器端指定 Cookie 所属的域名为一级域名:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-cookie: key=value; domain=.onejustone.xyz; path= /;</span><br></pre></td></tr></table></figure>
<p>这样二级和三级域名不用做任何设置，都可以读取这个 Cookie。</p>
<p>而如果两个网页不同源，则无法获取对方的 DOM，比如 <code>iframe</code> 窗口和 <code>window.open</code> 方法打开的窗口，它们与父窗口无法通信。这时如果两个窗口一级域名相同，而二级域名不同，则通过 <code>document.domain</code> 属性，即可规避同源策略，拿到 DOM。</p>
<p>而对于完全不同于源的网页则有三种方法:</p>
<ul>
<li>片段是识别符(fragment identifier)</li>
<li>window.name</li>
<li>跨文档通信API(Cross-document messaging)</li>
</ul>
<p>片段标识符（fragment identifier）指的是，URL的#号后面的部分，比如<a href="http://example.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新。" target="_blank" rel="noopener">http://example.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新。</a></p>
<p>而通过 <code>window.name</code> 属性，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。但是使用<code>window.name</code> 将会非常影响页面性能。</p>
<p>好在 H5 引入了一个全新的 API，<code>跨文档通信 API(Cross-document messaging)</code>,它为 <code>window</code> 对象新增了一个 <code>window
.postMessage</code> 方法，运行跨窗口通信，无论这两个窗口是否同源。除此之外，连读取其它窗口的  <code>localStorgae</code> 也成为了可能。</p>
<hr>
<h3 id="0x01-CORS"><a href="#0x01-CORS" class="headerlink" title="0x01 CORS"></a>0x01 CORS</h3><p>同源策略规定，AJAX 请求正发送给同源的网址，否则就会报错。面对这个问题，我们很多种解决的方法:</p>
<ul>
<li>JSONP</li>
<li>Cmment</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/33/">33</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">onejustonee</p>
              <p class="site-description motion-element" itemprop="description">onejustone's blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">329</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">103</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">onejustonee</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
