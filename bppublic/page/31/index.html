<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="onejustone&apos;s blog">
<meta property="og:type" content="website">
<meta property="og:title" content="onejustone">
<meta property="og:url" content="http://yoursite.com/page/31/index.html">
<meta property="og:site_name" content="onejustone">
<meta property="og:description" content="onejustone&apos;s blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="onejustone">
<meta name="twitter:description" content="onejustone&apos;s blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/31/">





  <title>onejustone</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">onejustone</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">--愿你内心有种不灭的火焰，将你与别人区分开来--</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/04/24/13.内建函数/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="onejustonee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="onejustone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/24/13.内建函数/" itemprop="url">Python(12)-动态类型(dynamic typing)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-24T19:15:00+08:00">
                2016-04-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/technology/" itemprop="url" rel="index">
                    <span itemprop="name">technology</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="0x00-帮助函数"><a href="#0x00-帮助函数" class="headerlink" title="0x00 帮助函数"></a>0x00 帮助函数</h2><hr>
<h3 id="dir-和help-函数"><a href="#dir-和help-函数" class="headerlink" title="dir()和help()函数"></a>dir()和help()函数</h3><p><code>dir()</code>函数用来查询一个类或者对象的所有属性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> dir(list)</span><br></pre></td></tr></table></figure>
<p><code>help()</code>用来查询说明文档</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> help(list)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>基本数据类型 type()</strong></li>
<li><strong>文本文件的输入输出 open()</strong></li>
<li><strong>循环设计 range()  enumerate()  zip()</strong></li>
<li><strong>循环对象 iter()</strong></li>
<li><strong>函数对象  map() filter()  reduce()</strong></li>
</ul>
<hr>
<h2 id="0x01-数学运算"><a href="#0x01-数学运算" class="headerlink" title="0x01 数学运算"></a>0x01 数学运算</h2><ul>
<li><strong>abs(-5)</strong>             取绝对值</li>
<li><strong>round(2.6)</strong>        四舍五入取整</li>
<li><strong>pow(2, 3)</strong>          相当于2<strong>3，如果是pow(2, 4, 5)x相当于2</strong>4 %  5</li>
<li><strong>cmp(a, b)</strong>             比较两个数的大小:a大于b返回1，否则返回-1</li>
<li><strong>divmod(9, 2)</strong>        返回除法结果和余数，本例返回(4, 1)</li>
<li><strong>max(),min(),sum()</strong>  求最大值，求最小值，求和</li>
</ul>
<hr>
<h2 id="0x02-类型转换"><a href="#0x02-类型转换" class="headerlink" title="0x02 类型转换"></a>0x02 类型转换</h2><ul>
<li><strong>int(“5”)</strong> 转换为整数:integer</li>
<li><strong>float(2)</strong> 转换为浮点数:float</li>
<li><strong>long(“23”)</strong> 转换为长整数:long integer</li>
<li><strong>str(2.3)</strong> 转换为字符串:string</li>
<li><strong>complex(3, 9)</strong> 返回复数3+9i</li>
<li><strong>ord(“A”)</strong> “A”字符对应的数字</li>
<li><strong>chr(65)</strong> 数字65对应的字符</li>
<li><strong>unichr(65)</strong> 数字65对应的unicode字符</li>
<li><strong>bool(0)</strong> 转换为相应的真假值，Python中，0相当于False，且下列对象都相当于False: <strong>[ ]</strong>, <strong>( )</strong>, <strong>{ }</strong>, <strong>0</strong>, <strong>None</strong>, <strong>0.0</strong>, <strong>‘ ‘</strong></li>
<li><strong>bin(56)</strong> 返回一个字符串，表示56的二进制数</li>
<li><strong>hex(56)</strong> 返回一个字符串，表示56的十六进制数</li>
<li><strong>oct(56)</strong> 放回一个字符串，表示56的八进制数</li>
<li><strong>list((1, 3, 4))</strong> 转换为表:list</li>
<li><strong>tuple([1, 3, 45])</strong> 转换为元组:tuple</li>
<li><strong>slice(3, 4, -1)</strong> 构建下标对象:slice</li>
<li><strong>dict(a=1, b=”hello”, c=[1,2,3])</strong> 构建词典:dictionary</li>
</ul>
<p>–</p>
<h2 id="0x03-list操作"><a href="#0x03-list操作" class="headerlink" title="0x03 list操作"></a>0x03 list操作</h2><p>list是python内置的一个类，当建立一个列表时:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n1 = [1,2,3,4,5]</span><br></pre></td></tr></table></figure>
<p>实际上，n1是类list的一个对象</p>
<hr>
<h3 id="关list常用的的一些方法"><a href="#关list常用的的一些方法" class="headerlink" title="关list常用的的一些方法__"></a>关list常用的的一些方法__</h3><ul>
<li><strong>nl.count(5)</strong> 计数，看总共有多少个5</li>
<li><strong>nl.index(3)</strong> 查询 nl 的第一个3的下标</li>
<li><strong>nl.append(6)</strong> 在 nl 的最后增添一个新元素6</li>
<li><strong>nl.sort()</strong>  对nl的元素排序</li>
<li><strong>nl.pop(-1)</strong>  从nl中去除最后一个元素，并将该元素返回。</li>
<li><strong>nl.remove(2)</strong>  从nl中去除第一个2</li>
<li><strong>nl.insert(0,9)</strong> 在下标为0的位置插入9</li>
<li><strong>all([True, 1, “hello!”])</strong> 是否所有元素都相当于True值</li>
<li><strong>any([“ “, 0, False, [ ], None])</strong> 是否有任意一个元素相当于True值</li>
<li><strong>sorted([1, 4, 5])</strong> 返回正序的序列</li>
<li><strong>reversed([1, 4, 5])</strong> 返回逆序的序列，即是:[5, 4, 1]</li>
</ul>
<hr>
<h2 id="0x04-编译，执行"><a href="#0x04-编译，执行" class="headerlink" title="0x04 编译，执行"></a>0x04 编译，执行</h2><ul>
<li><strong>repr(me)</strong> 返回对象的字符串表达式</li>
<li><strong>compile(“print(‘hello’”, ‘test.py’, ‘exec’)</strong> 编译成为code对象</li>
<li><strong>eval(“1 + 1”)</strong> 解释字符串表表达式，参数也可以是compile()返回的code对象</li>
<li><strong>exec(“print(‘hello’)”)</strong> 解释并执行字符串，print(‘Hello’)。参数也可以是compile()返回的code对象</li>
</ul>
<hr>
<h2 id="0x05-其它"><a href="#0x05-其它" class="headerlink" title="0x05 其它"></a>0x05 其它</h2><ul>
<li><strong>globals()</strong> 返回全局命名空间，比如全局变量，全局函数名</li>
<li><strong>locals()</strong> 返回局部命名空间</li>
</ul>
<p>Python的强大之处在于，它提供很多已经写好的，可以现成利用的对象，在Python的标准库里还有大量可以用于操作系统互动，Internet开发，多线程，文本处理的对象，而在这些基础之上是很多外部的库，定义了更丰富的对象，比如Django等等，我们要开始攀登巨人的肩膀了！</p>
<blockquote>
<p>参考来源:<a href="http://www.cnblogs.com/vamei" target="_blank" rel="noopener">http://www.cnblogs.com/vamei</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/04/21/第十三章-Shell-Scripts/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="onejustonee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="onejustone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/21/第十三章-Shell-Scripts/" itemprop="url">第十三章-Shell Scripts</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-21T15:12:52+08:00">
                2016-04-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/technology/" itemprop="url" rel="index">
                    <span itemprop="name">technology</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="0x01-What-is-Shell-Script"><a href="#0x01-What-is-Shell-Script" class="headerlink" title="0x01 What is Shell Script?"></a>0x01 What is Shell Script?</h3><p>从字面意思可以理解为，shell script就是针对shell所写的剧本，哈哈，官方一点，shell script 是利用 shell 的功能所写的一个『程序     (program)』，这个程序是使用纯文字档，将一些 shell 的语法与命令(含外部命令)写在里面，    搭配正规表示法、管线命令与数据流重导向等功能，以达到我们所想要的处理目的。简单点，shell script就像是早期DOS年代的批处理文件(.bat)。</p>
<hr>
<h4 id="Why-shell-script"><a href="#Why-shell-script" class="headerlink" title="Why shell script?"></a>Why shell script?</h4><p>对于Linux的系统管理而言，shell script实在是一个很不错的工具，它可以汇整一些在command<br> line下达的命令，将它写入sctipt文件中，来启动一连串的command  line命令输入，就是这么简单。但是shell script也有自身的不足，比如其在大数据的运算处理上，就不够好了，速度比较慢，这时候就是python的天下了！</p>
<hr>
<h4 id="第一个shell-script"><a href="#第一个shell-script" class="headerlink" title="第一个shell script"></a>第一个shell script</h4><p>基本了解了shell script后我们来看看编写它的一些</p>
<p><strong>注意事项:</strong></p>
<ul>
<li>命令下达后:命令，选项与参数间的多个空白都会被忽略掉</li>
<li>空白行也将被忽略，并且[tab]键所占有的空白同样被视为空白键</li>
<li>读取到一个Enter符号(CR),就尝试运行该(串)命令。</li>
<li>如果一行的内容太多，可以使用{ [Enter] }来延生至下一行</li>
<li>#作为注解符号</li>
</ul>
<hr>
<h4 id="关于shell-script-sh-文件的的运行"><a href="#关于shell-script-sh-文件的的运行" class="headerlink" title="关于shell script(.sh)文件的的运行"></a>关于shell script(.sh)文件的的运行</h4><ul>
<li><p>直接命令下达:shell.sh文件必须具备可读与可运行的权限(rx):</p>
<ul>
<li>绝度路径:比如/home/sys/shell.sh来下达运行命令</li>
<li>相对路径:假设工作目录在/home/sys/下，则使用./shell.sh来运行</li>
<li>变量[PATH]的功能:将shell.sh放在PATH指定的目录内，例如:～/bin</li>
</ul>
</li>
<li><p>以bash程序来运行:通过bash shell.sh或者sh shell.sh来运行</p>
</li>
</ul>
<hr>
<h3 id="0x01-hello-world"><a href="#0x01-hello-world" class="headerlink" title="0x01 hello world!"></a>0x01 hello world!</h3><p>下面开始编写我们的第一个script:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#program</span><br><span class="line">#	this program shows &quot;hello world,this is my first script!&quot; in your scree</span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin </span><br><span class="line">export PATH</span><br><span class="line">echo &quot;hello world!\a\n&quot;</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure></p>
<p>对上面程序做出一些解释:</p>
<ul>
<li><p>第一行<strong>#!/bin/bash</strong>声明这个script所使用的shell<br><strong>#!/bin/bash</strong>来声明这个文件内的语法使用bash的语法，当程序被运行时，他会自动加载bash相关的环境配置，并且运行bash来使得文件内的命令能够运行，这很重要！</p>
<ul>
<li>程序内容的说明<br>在书写内容以前，建议一定要养成这样一些说明习惯:1)内容与功能；2)版本咨询；3)作者与联络方式;4)建档日期;5)历史记录；等等，这有助于未来程序的改写与dubug！</li>
</ul>
</li>
</ul>
<ul>
<li><p>主要的环境变量<br>建议将一些重要的环境变量配置好，比如PATH和LANG,如此以来，则可以让我们在运行这个程序时，可以直接下达一些外部命令，而不必写决定路径！</p>
</li>
<li><p>退出程序<br>我们可以利用exit这个命令来让程序中断，并且回传一个数值系统！</p>
</li>
</ul>
<hr>
<h3 id="0x02-简单的shell-script练习"><a href="#0x02-简单的shell-script练习" class="headerlink" title="0x02  简单的shell script练习"></a>0x02  简单的shell script练习</h3><p>编写scritp在工具最好是vim而不是vi，因为vim会有额外的语法检验！</p>
<hr>
<h4 id="对谈是脚本-变量由使用者决定"><a href="#对谈是脚本-变量由使用者决定" class="headerlink" title="对谈是脚本:变量由使用者决定"></a>对谈是脚本:变量由使用者决定</h4><p>比如，让使用者输入自己的名字，然后显示到屏幕上:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">!/bin/bash</span><br><span class="line">#program:</span><br><span class="line"># user inputs his first name and last name then shows his full name</span><br><span class="line">#History:</span><br><span class="line">#2016/04/22</span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">export PATH</span><br><span class="line"></span><br><span class="line">read -p &quot;please input you first name:&quot; firstname</span><br><span class="line">read -p &quot;please input you last name:&quot; lastname</span><br><span class="line">echo -e &quot;\nYour full name is:$firstname $lastname&quot;</span><br></pre></td></tr></table></figure></p>
<p>如果想要制作一个每次运行都会依据不同的日期而变化结果的脚本呢？</p>
<hr>
<h4 id="随日期变化-利用date进行文件创建"><a href="#随日期变化-利用date进行文件创建" class="headerlink" title="随日期变化:利用date进行文件创建"></a>随日期变化:利用date进行文件创建</h4><p>实例使用者只需要输入文件名，然后自动添加创建时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">export PATH</span><br><span class="line">#输入要创建的文件名</span><br><span class="line">echo -e &quot;i will use &apos;touch&apos; command to creat 3 files.&quot;</span><br><span class="line">read -p &quot;please input your filename:&quot; fileuser</span><br><span class="line"></span><br><span class="line">filename=$&#123;fileuser:-&quot;fileuser&quot;&#125;</span><br><span class="line"></span><br><span class="line">#利用date命令创建文件</span><br><span class="line">date1=$(date --date=&apos;2 days ago&apos;+%Y%m%d) #前两天的日期</span><br><span class="line">date2=$(date --date=&apos;1 days ago&apos;+%Y%m%d) #前一天的日期</span><br><span class="line">date3=$(date +%Y%m%d)                    #今天的日期</span><br><span class="line">#配置文件名</span><br><span class="line">file1=$&#123;filename&#125;$&#123;date1&#125;</span><br><span class="line">file2=$&#123;filename&#125;$&#123;date2&#125;</span><br><span class="line">file3=$&#123;filename&#125;$&#123;date3&#125;</span><br><span class="line">#建立文件</span><br><span class="line">touch &quot;$file1&quot;</span><br><span class="line">touch &quot;$file2&quot;</span><br><span class="line">touch &quot;$file3</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><p> 我们除了declare来定义变量类型进行运算之外，还可以使用<strong>{ $((计算式)) }</strong>来进行数值运算，但是bash shell里面默认只能进行整数的计算。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">export PATH</span><br><span class="line">read -p &quot;first number:&quot; firstnu</span><br><span class="line">read -p &quot;sencond number:&quot; secnu</span><br><span class="line">total=$(($firstnu*$secnu))</span><br><span class="line">echo -e &quot;\nthe result of $firstnu*$secnu if ==&gt;$total&quot;</span><br><span class="line">运行:</span><br><span class="line">root@jack:~# sh sh04.sh </span><br><span class="line">first number:6</span><br><span class="line">sencond number:9</span><br><span class="line">the result of 6*9 if ==&gt;54</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="0x03-script的运行方式差异"><a href="#0x03-script的运行方式差异" class="headerlink" title="0x03 script的运行方式差异"></a>0x03 script的运行方式差异</h3><p>不同的script运行方式会造成不一样的结果:</p>
<h4 id="直接运行"><a href="#直接运行" class="headerlink" title="直接运行"></a>直接运行</h4><p> 除了source之外的都是直接运行，当我们直接运行，其实是调用了一个子程序运行的script，当子程序完成后，在子程序内的各项变量或动作将会结束而不会传回到父程序中。</p>
<h4 id="source-在父程序中运行"><a href="#source-在父程序中运行" class="headerlink" title="source:在父程序中运行"></a>source:在父程序中运行</h4><p> 当使用source运行脚本式脚本内陪的变量都会在原本的bash中生效，这和不注销系统而让某些写进~/.bashrc的配置生效时，使用<strong>{ source ~/.bashrc }而不使用</strong>{ bash ~/.bashrc }__一样的！</p>
<hr>
<h3 id="0x04-判断"><a href="#0x04-判断" class="headerlink" title="0x04 判断"></a>0x04 判断</h3><p>我们提到过 $? 这个变量所代表的意义，    此外，也透过 &amp;&amp; 及 || 来作为前一个命令运行回传值对於后一个命令是否要进行的依据</p>
<hr>
<h4 id="利用test命令测试"><a href="#利用test命令测试" class="headerlink" title="利用test命令测试"></a>利用test命令测试</h4><p>比如判断一个文件是否存在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# test -e /fuckshit</span><br><span class="line">#什么都不返回</span><br></pre></td></tr></table></figure></p>
<p>配合&amp;&amp;与||来使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# test -e /fuckshit &amp;&amp; echo &quot;exit&quot; || echo &quot;not exit&quot;</span><br><span class="line">not exit</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="test常用的判断标志"><a href="#test常用的判断标志" class="headerlink" title="test常用的判断标志:"></a>test常用的判断标志:</h4><h5 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h5><table>
<thead>
<tr>
<th style="text-align:center">测试标志</th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-e</td>
<td style="text-align:left">该『档名』是否存在？(常用)</td>
</tr>
<tr>
<td style="text-align:center">-f</td>
<td style="text-align:left">该『档名』是否存在且为文件(file)？(常用)</td>
</tr>
<tr>
<td style="text-align:center">-d</td>
<td style="text-align:left">该『档名』是否存在且为目录(directory)？(常用)</td>
</tr>
</tbody>
</table>
<h5 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h5><table>
<thead>
<tr>
<th style="text-align:center">测试标志</th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-r</td>
<td style="text-align:left">侦测该档名是否存在且具有『可读』的权限？</td>
</tr>
<tr>
<td style="text-align:center">-w</td>
<td style="text-align:left">侦测该档名是否存在且具有『可写』的权限？</td>
</tr>
<tr>
<td style="text-align:center">-x</td>
<td style="text-align:left">侦测该档名是否存在且具有『可运行』的权限？</td>
</tr>
<tr>
<td style="text-align:center">-u</td>
<td style="text-align:left">侦测该档名是否存在且具有『SUID』的权限？</td>
</tr>
<tr>
<td style="text-align:center">-g</td>
<td style="text-align:left">侦测该档名是否存在且具有『SGID』的权限？</td>
</tr>
<tr>
<td style="text-align:center">-s</td>
<td style="text-align:left">侦测该档名是否存在且为『非空白文件』？</td>
</tr>
</tbody>
</table>
<h5 id="两个文件之间的比较"><a href="#两个文件之间的比较" class="headerlink" title="两个文件之间的比较"></a>两个文件之间的比较</h5><p>如test file1 -nt file2</p>
<table>
<thead>
<tr>
<th style="text-align:center">测试标志</th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-nt</td>
<td style="text-align:left">(newer than)判断file1是否比file2新</td>
</tr>
<tr>
<td style="text-align:center">-ot</td>
<td style="text-align:left">(older than)判断file1是否比file2旧</td>
</tr>
<tr>
<td style="text-align:center">-ef</td>
<td style="text-align:left">判断 file1 与 file2 是否为同一文件，可用在判断 hard link 的判定上。 主要意义在判定，两个文件是否均指向同一个 inode 哩！</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="利用判断符号"><a href="#利用判断符号" class="headerlink" title="利用判断符号[ ]"></a>利用判断符号[ ]</h4><p>判读HOME是否为空<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# [ -z &quot;$HOME&quot; ];echo $?</span><br><span class="line">1</span><br><span class="line">root@jack:~# echo $HOME</span><br><span class="line">/root</span><br></pre></td></tr></table></figure></p>
<p><strong>在 bash的语法当中使用中括号作为 shell 的判断式时，必须要注意中括号的两端需要有空格字节来分隔</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　[ &quot;$HOME&quot; == &quot;$MAIL&quot; ]</span><br><span class="line">(我是空格)[(我是空格)&quot;$HOME&quot;(我是空格)==(我是空格)“$MAIL”(我是空格)]</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="shell-script的默认变量-0-1…"><a href="#shell-script的默认变量-0-1…" class="headerlink" title="shell script的默认变量($0,$1….)"></a>shell script的默认变量($0,$1….)</h4><p>其实系统已近为每个script默认配置好了一些，使得我们可以在运行script的同时直接添加参数以更好的使用脚本程序。</p>
<p>比如可以直接重新启动运行一个脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# /etc/init.d/syslog restart</span><br></pre></td></tr></table></figure></p>
<p>script配置的默认变量格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/path/to/sciptname opt1 opt2 opt3 opt4</span><br><span class="line">   $0   $1    $2   $3   $4</span><br><span class="line">$0:这个脚本的文件名</span><br><span class="line">$1:来自使用者的参数，善用 $1 的话，就可以很简单的立即下达某些命令功能</span><br></pre></td></tr></table></figure></p>
<p>此外还有一些较为特殊的变量$#,$@我们通过下面的程序来了解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;the script name is ==&gt; $0&quot;</span><br><span class="line">echo &quot;total parameter number is ==&gt;$#&quot;</span><br><span class="line">　[ &quot;$#&quot; -lt2 ]&amp;&amp; echo &quot;the number of parameter is less than 2.Stop here.&quot;\</span><br><span class="line">&amp;&amp; exit 0</span><br><span class="line">echo &quot;your whole parameter is ==&gt;&apos;$@&apos;&quot;</span><br><span class="line">echo &quot;the 1st parameter ==&gt;$1&quot;</span><br><span class="line">echo &quot;the 2nd parameter ==&gt;$2&quot;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~/scripts# sh sh07.sh chen jack jhno</span><br><span class="line">the script name is ==&gt; sh07.sh #文件名</span><br><span class="line">total parameter number is ==&gt;3 #总的参数</span><br><span class="line">your whole parameter is ==&gt;&apos;chen jack jhno&apos; #参数的全部内容</span><br><span class="line">the 1st parameter ==&gt;chen #第一个参数</span><br><span class="line">the 2nd parameter ==&gt;jack #第二个参数</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="0x05-条件判断"><a href="#0x05-条件判断" class="headerlink" title="0x05 条件判断"></a>0x05 条件判断</h3><hr>
<h4 id="if…then"><a href="#if…then" class="headerlink" title="if…then"></a>if…then</h4><h5 id="简单条件判断"><a href="#简单条件判断" class="headerlink" title="简单条件判断"></a>简单条件判断</h5> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if　[ 条件 ];then</span><br><span class="line">执行语句</span><br><span class="line">fi &lt;==fi就代表if语句的结束</span><br></pre></td></tr></table></figure>
<h5 id="多重条件判断"><a href="#多重条件判断" class="headerlink" title="多重条件判断"></a>多重条件判断</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> if　[ 条件 ];then</span><br><span class="line">    条件成立执行语句</span><br><span class="line">else</span><br><span class="line">    条件不成立执行语句</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h5 id="复杂条件判断"><a href="#复杂条件判断" class="headerlink" title="复杂条件判断"></a>复杂条件判断</h5> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if　[ 条件一 ];then</span><br><span class="line">条件一成立执行语句</span><br><span class="line">elif　[ 条件二 ];then</span><br><span class="line">条件二成立执行语句</span><br><span class="line">else</span><br><span class="line">条件一与二均不成立执行语句</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>实例:检查主机的80端口是否开放<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">export PATH</span><br><span class="line">echo &quot;now,i will detect your linux server&apos;services!&quot;</span><br><span class="line">echo -e &quot;the www,ftp,ssh,and mail will be detect!\n&quot;</span><br><span class="line">testing=$(netstat -tuln | grep &quot;:80&quot;)</span><br><span class="line">if　[ &quot;$testing&quot; != &quot;&quot; ];then</span><br><span class="line">	echo &quot;www is running in youre system.&quot;;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="0x06-case…-esac…-类似与c中which"><a href="#0x06-case…-esac…-类似与c中which" class="headerlink" title="0x06 case….esac…(类似与c中which)"></a>0x06 case….esac…(类似与c中which)</h3><p><strong>语法如下</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">case $变量 in</span><br><span class="line">&quot;第一个变量&quot;)</span><br><span class="line">  程序</span><br><span class="line">  ;;</span><br><span class="line">&quot;第二个变量&quot;)</span><br><span class="line">  程序</span><br><span class="line">  ;;</span><br><span class="line">*)</span><br><span class="line">  不满足一和二时执行</span><br><span class="line">   程序</span><br><span class="line">  ;;</span><br><span class="line">esac</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">实例:</span><br></pre></td></tr></table></figure></p>
<p>#!/bin/bash</p>
<p>PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin<br>export PATH</p>
<p>echo “this program will print you selection!”</p>
<p>read -p “input your choice:” choice<br>case $choice in</p>
<p>#case $1 in #代替前两行，这样可以执行脚本时直接添加参数<br>“one”)<br>  echo “your choice is ONE”<br>  ;;<br>“two”)<br>  echo “your choice is TWO”<br>  ;;<br>“three”)<br>  echo “your choice is THREE”<br>  ;;<br>*)<br>  echo “usage $0{one|two|three}”<br>  ;;<br>esac<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line">### 0x08 函数</span><br><span class="line"></span><br><span class="line">__语法:__</span><br></pre></td></tr></table></figure></p>
<p>function 函数名(){<br>  程序<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line">### 0x09 循环</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">#### while do done,until do done</span><br><span class="line"></span><br><span class="line">##### while循环</span><br><span class="line">当条件成立时，就执行循环体直到，while条件不成立，退出循环！</span><br></pre></td></tr></table></figure></p>
<p>while [ 条件 ]<br>do      #循环开始<br>  程序段<br>done    #循环结束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### until循环</span><br><span class="line">与while相反，当条件成立时就终止循环，否则就进入循环！</span><br></pre></td></tr></table></figure></p>
<p>until [ 条件 ]<br>do<br>  程序段<br>done<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">实例:</span><br></pre></td></tr></table></figure></p>
<p>#!/bin/bash</p>
<p>PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin<br>export PATH<br>while [ “$yn” != “yes” ]<br>do<br>        read -p “please input yes  to stop this program:” yn<br>done<br>echo “ok ,you input the correct answer.”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">#### for ...do...done</span><br><span class="line"></span><br><span class="line">__语法:__</span><br></pre></td></tr></table></figure></p>
<p>for var in con1 con2 con3<br>do<br>程序段<br>done<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">实例:</span><br></pre></td></tr></table></figure></p>
<p>for  animal in dog pig cat<br>do<br>    echo “${animal}”<br>done<br>运行结果:<br>dog<br>pig<br>cat<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for循环对数值运算的处理</span><br></pre></td></tr></table></figure></p>
<p>#!/bin/bash</p>
<p>PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin<br>export PATH<br>read -p “input a number,i will count for total your input:” nu</p>
<p>s=0<br>for((i=1;i&lt;=$nu;i=i+1))<br>do<br>        s=$(($s+$i))<br>done<br>echo “the result of ‘1+2+3+4+…+$nu is ==&gt; $s”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line">### 0xA Shell Script的追踪与debug</span><br></pre></td></tr></table></figure></p>
<p>root@jack:~#  sh [-nvx] script.sh<br>选项与参数:<br>-n:不要运行 script，仅查询语法的问题；<br>-v:再运行 sccript 前，先将 scripts 的内容输出到萤幕上；<br>-x:将使用到的 script 内容显示到萤幕上，这是很有用的参数！<br><code>`</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/04/11/kali基本工具-WIRESHARK/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="onejustonee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="onejustone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/11/kali基本工具-WIRESHARK/" itemprop="url">WIRESHARK初识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-11T08:48:52+08:00">
                2016-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/technology/" itemprop="url" rel="index">
                    <span itemprop="name">technology</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="0x00-WIRESHARK简介"><a href="#0x00-WIRESHARK简介" class="headerlink" title="0x00 WIRESHARK简介"></a>0x00 WIRESHARK简介</h3><p>wireshark前称Ethereal，是一个网络封包分析软件。网络封包分析软件的功能是撷取网络封包，并尽可能显示出最为详细的网络封包资料。Wireshark使用WinPCAP作为接口，直接与网卡进行数据报文交换(—百度百科)作为一款强大的抓包嗅探和协议分析工具，熟练的掌握它是安全专家必备技能！</p>
<p>wireshark本身只是对网络流量进行分析而不会去抓包，wireshark下的抓包组件引擎主要有两个:</p>
<ul>
<li>linux-Libpcap9</li>
<li>windows-Winpcap10</li>
</ul>
<p>衡量一个网络分析工具的强大与否最重要的一个参数指标就是它的解码能力，而wireshark在主流的分析软件中的解码能力是首屈一指的！</p>
<hr>
<h3 id="0x01-WIRESHARK的基本使用方法"><a href="#0x01-WIRESHARK的基本使用方法" class="headerlink" title="0x01 WIRESHARK的基本使用方法"></a>0x01 WIRESHARK的基本使用方法</h3><p>wireshark是kali的十大安全工具之一，所以在kali2.0下我们很容易的就能找到她了！</p>
<ul>
<li>指定抓包网卡<br> 在start的下拉框下指定抓取哪个网卡的进入流量，同样也可以选择interface list指定使用哪块网卡！</li>
<li>interface list下的options：<ul>
<li>可以看到默认打钩的那一项<a href="对所有的网卡使用混杂模式">Use promiscuous mode on all interfaces</a>:抓取哪些经过我的网卡的但是并不是发送给我的数据包，不勾选则是不会抓取除了我本地网卡绑定的IP之外的数据包的！但如果你想了解下你所在的网络里的所有的机器传输数据的情况则必须选择混杂模式！</li>
<li>Cpature Filter(抓包筛选器):为了减少混杂模式下所抓取的大量数据包对分析所产生的影响，我们可以过滤掉那些我并不想要抓取的数据包！点击Capture Filter选则格式抓取指定类型的数据包！</li>
</ul>
</li>
</ul>
<hr>
<h3 id="0x02-对抓取的数据进行保存"><a href="#0x02-对抓取的数据进行保存" class="headerlink" title="0x02 对抓取的数据进行保存"></a>0x02 对抓取的数据进行保存</h3><p>菜单栏&gt;File&gt;Save!只要是对数据保存的格式的选择，建议选择兼容性最好的Wireshark/tcpdumo/-pcap格式！最后好可以选择gzip对数据包进行压缩！以后便可以将其提取出来进行分析了！</p>
<hr>
<h3 id="0x03-WIRESHRK界面初识"><a href="#0x03-WIRESHRK界面初识" class="headerlink" title="0x03 WIRESHRK界面初识"></a>0x03 WIRESHRK界面初识</h3><p>Edit-&gt;Preferences(首选项):界面布局，对wireshark进行主题，颜色，字体等选择！</p>
<hr>
<h3 id="0x04-WIRESHARK筛选器"><a href="#0x04-WIRESHARK筛选器" class="headerlink" title="0x04 WIRESHARK筛选器"></a>0x04 WIRESHARK筛选器</h3><ul>
<li><em>抓包筛选器</em>(Display Filters)</li>
<li><em>显示筛选器</em>(Capture Filters)</li>
</ul>
<hr>
<h3 id="0x05-常见协议包"><a href="#0x05-常见协议包" class="headerlink" title="0x05 常见协议包"></a>0x05 常见协议包</h3><ul>
<li><em>Arp:</em></li>
<li><em>lcmp:</em></li>
<li><em>TCP:</em></li>
<li><em>UDP:</em></li>
<li><em>DNS:</em></li>
<li><em>HTTP:</em></li>
<li><em>FTP:</em></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/04/11/WIRESHARK-Statistics（信息统计）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="onejustonee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="onejustone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/11/WIRESHARK-Statistics（信息统计）/" itemprop="url">WIRESHARK信息统计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-11T08:48:52+08:00">
                2016-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/technology/" itemprop="url" rel="index">
                    <span itemprop="name">technology</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h3><ul>
<li>Endpoints:节点信息，包括tcp,udp的节点个数等！</li>
<li>ProtocolHierarchy:了解当前所抓的数据都有哪些协议类型的包所占的百分比是多少。</li>
<li>Conversation:判断哪个ip所占的宽带比例最多，是否被僵尸病毒入侵！</li>
</ul>
<p>值得注意的是wireshark默认只是通过端口来对协议包进行判断的，即是80端口下它就会是tcp的协议包了，这显然是不准确的</p>
<ul>
<li>解码方式Analyse—&gt;Decode As:用来精确的分析数据包所属的协议类型！</li>
<li>专家信息:Analyse-&gt;Expert Info:<br>通过对专家系统给出的信息对网络中可能存在的问题进行判断，结论的正确与否完全取决于专家系统分析的结果是否准确！</li>
</ul>
<hr>
<h3 id="0x01-WIRESHARK-实践"><a href="#0x01-WIRESHARK-实践" class="headerlink" title="0x01 WIRESHARK-实践"></a>0x01 WIRESHARK-实践</h3><p>抓包对比nc，ncat加密与不加密流量对比：<br>虚拟机A: kali(192.168.137.13)；<br>虚拟机B: ubuntu(192.168.137.12)  {为方便操作，请同时将两个虚拟机的网卡改为hostonly模式【根据之前的设置Vmnet0就是honstonly模式的啦！】}</p>
<p>WIRESHARK的不足之处就是不适合大数据大流量的抓包分析处理！</p>
<hr>
<h3 id="0x02-其他更强大的抓包软件"><a href="#0x02-其他更强大的抓包软件" class="headerlink" title="0x02 其他更强大的抓包软件"></a>0x02 其他更强大的抓包软件</h3><ul>
<li>sniffer</li>
<li>Cace/riverbed</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/04/11/文档记录工具/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="onejustonee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="onejustone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/11/文档记录工具/" itemprop="url">文档记录工具</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-11T08:48:52+08:00">
                2016-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/technology/" itemprop="url" rel="index">
                    <span itemprop="name">technology</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在渗透测试中不一定都是单兵作战，因为所涉及的领域和方向很多，所以这个时候过程文档记录就很有用了！</p>
<h3 id="0x00-Dradis"><a href="#0x00-Dradis" class="headerlink" title="0x00 Dradis"></a>0x00 Dradis</h3><p>Dradis是一个开放源代码的框架，用于在安全评估过程中实时共享信息。dradis自身包含了一个web应用程序，它提供了一个集中的资料库来记录什么迄今已完成的工作和仍然需要做的工作。<br>它的特点包括：</p>
<ul>
<li>易于生成报告。</li>
<li>支持附件。</li>
<li>通过服务器的插件，集成现有的系统和工具。</li>
<li>平台无关。</li>
</ul>
<p>Dradis远远不只是一个单纯的记笔记的应用程序。它支持SSL通信，可以导入的Nmap和Nessus结果文件，附加文件，生成报表，并且可以扩展，通过扩展就可以与（如漏洞数据库）外部系统结合。无论作为个人的信息积累和团队协作Dradis都是一个非常不错的工具。</p>
<p>使用卡里打开Dradis:<br>应用程序-&gt;报告工具集-&gt;Dradis</p>
<h3 id="Keepnote"><a href="#Keepnote" class="headerlink" title="Keepnote"></a>Keepnote</h3><h3 id="Truecrypt"><a href="#Truecrypt" class="headerlink" title="Truecrypt"></a>Truecrypt</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/04/11/被动信息收集/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="onejustonee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="onejustone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/11/被动信息收集/" itemprop="url">被动信息收集</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-11T08:48:52+08:00">
                2016-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/technology/" itemprop="url" rel="index">
                    <span itemprop="name">technology</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="0x00-被动信息收集"><a href="#0x00-被动信息收集" class="headerlink" title="0x00 被动信息收集"></a>0x00 被动信息收集</h3><p>被动信息收集指的是通过公开渠道可获得的信息，与目标系统不产生直接交互，尽量避免留下一切痕迹。</p>
<p>OSINT：<br>关于开源智能信息收集可以参看一下两篇文章：<br>美国军方：<a href="http://www.fas.org/irp/dodair/army/atp2-22-2.pdf" target="_blank" rel="noopener">http://www.fas.org/irp/dodair/army/atp2-22-2.pdf</a><br>被大西洋公约组织：<a href="http://information-retireval.info/docs/NATO-OSINT.html" target="_blank" rel="noopener">http://information-retireval.info/docs/NATO-OSINT.html</a></p>
<hr>
<h4 id="信息收集的过程"><a href="#信息收集的过程" class="headerlink" title="信息收集的过程"></a>信息收集的过程</h4><p>Passive reconnaissance(no direct interaction)-&gt;Normal interaction-&gt;Active reconnaissance-&gt;More information greater chance of detection</p>
<hr>
<h4 id="信息收集的内容"><a href="#信息收集的内容" class="headerlink" title="信息收集的内容"></a>信息收集的内容</h4><p>ip地址段，域名信息，邮件地址(判断是个人搭建的邮件信息服务器还是使用的企业级邮件服务器)，文档图片数据，公司地址，公司组织架构，联系电话/传真号码，人员姓名/职务，目标系统使用的技术架构，公开的商业信息</p>
<hr>
<h4 id="信息用途"><a href="#信息用途" class="headerlink" title="信息用途"></a>信息用途</h4><p>用信息描述目标，发现目标的物理系统，为社会工程学攻击奠定基础，以及发现一些可能的物理缺口</p>
<hr>
<h3 id="0x01-信息收集之-DNS"><a href="#0x01-信息收集之-DNS" class="headerlink" title="0x01 信息收集之-DNS"></a>0x01 信息收集之-DNS</h3><hr>
<h4 id="DNS域名，FQDN与IP地址，PTP，NS，A，Cname，MX"><a href="#DNS域名，FQDN与IP地址，PTP，NS，A，Cname，MX" class="headerlink" title="DNS域名，FQDN与IP地址，PTP，NS，A，Cname，MX"></a>DNS域名，FQDN与IP地址，PTP，NS，A，Cname，MX</h4><p>对于一个网站最想了解的或许就是域名，比如sinlang.com这是一个域名(Domain Name)，<a href="http://www.sinlang.com则是完全限定域名" target="_blank" rel="noopener">www.sinlang.com则是完全限定域名</a>(FQND:Fully Qualified Domain Name),FQND即是是该域名(sinlang.com)下的一个主机记录，主机记录也叫做A记录，当然也有可能是一个别名记录(C name)。每个域名都一个或者多个域名服务器，用来负责对该域名的解析，而域名服务器地址又是通过DNS里面的NS记录进行定义和注册的。此外每个域名或者也有自己的邮件服务器(MX记录)。而前面所有的解析记录都是将主机名解析成另外一个主机名或者IP地址，但是ptr则是一个反向解析记录的过程，即是将IP地址解析成主机名。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1571420-d3eb19bf70da8eca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DNS解析过程.png"></p>
<p>DNS 查询以各种不同的方式进行解析。有时，客户端也可使用从先前的查询获得的缓存信息就地应答查询。DNS 服务器可使用其自身的资源记录信息缓存来应答查询。DNS 服务器也可代表请求客户端查询或联系其他 DNS 服务器，以便完全解析该名称，并随后将应答返回至客户端。这个过程称为递归。另外，客户端自己也可尝试联系其他的 DNS 服务器来解析名称。当客户端这么做的时候，它会根据来自服务器的参考答案，使用其他的独立查询。该过程称作迭代。</p>
<hr>
<h3 id="0x02-DNS信息收集工具-NSLOOKUP"><a href="#0x02-DNS信息收集工具-NSLOOKUP" class="headerlink" title="0x02 DNS信息收集工具-NSLOOKUP"></a>0x02 DNS信息收集工具-NSLOOKUP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# nslookup</span><br><span class="line">&gt; www.sina.com</span><br><span class="line">Server:		112.100.100.100 &#123;本地缓存DNS服务器,就是所在地的运营商的服务器，如果不想使用本地服务商解析，可以更换任意的DNS服务器进行解析，比如:server 8.8.8.8更换为谷歌的DNS服务器进行解析！&#125;</span><br><span class="line">Address:	112.100.100.100#53</span><br></pre></td></tr></table></figure>
<p>解析结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Non-authoritative answer:</span><br><span class="line">www.sina.com	canonical name = us.sina.com.cn.</span><br><span class="line">us.sina.com.cn	canonical name = news.sina.com.cn.</span><br><span class="line">news.sina.com.cn	canonical name = jupiter.sina.com.cn.</span><br><span class="line">jupiter.sina.com.cn	canonical name = hydra.sina.com.cn.</span><br><span class="line">Name:	hydra.sina.com.cn</span><br><span class="line">Address: 218.30.108.188</span><br><span class="line">Name:	hydra.sina.com.cn</span><br><span class="line">Address: 218.30.108.182</span><br><span class="line">Name:	hydra.sina.com.cn</span><br><span class="line">Address: 218.30.108.190</span><br><span class="line">Name:	hydra.sina.com.cn</span><br><span class="line">Address: 218.30.108.183</span><br><span class="line">Name:	hydra.sina.com.cn</span><br><span class="line">Address: 218.30.108.181</span><br><span class="line">Name:	hydra.sina.com.cn</span><br><span class="line">Address: 218.30.108.191</span><br><span class="line">Name:	hydra.sina.com.cn</span><br></pre></td></tr></table></figure></p>
<p>可以看到<a href="http://www.sina.com并没有被直接解析为一个特定的IP地址，所以www.sina.com不是一个A记录，而是一个C" target="_blank" rel="noopener">www.sina.com并没有被直接解析为一个特定的IP地址，所以www.sina.com不是一个A记录，而是一个C</a> name记录，转而被继续解析成us.sina.com.cn，一直解析知道主机记录。</p>
<hr>
<h4 id="查找新浪FTP服务器的IP"><a href="#查找新浪FTP服务器的IP" class="headerlink" title="查找新浪FTP服务器的IP"></a>查找新浪FTP服务器的IP</h4><h5 id="首先查MX记录"><a href="#首先查MX记录" class="headerlink" title="首先查MX记录"></a>首先查MX记录</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# nslookup</span><br><span class="line">&gt; set type=mx </span><br><span class="line">&gt; sina.com</span><br><span class="line"></span><br><span class="line">查询结果: </span><br><span class="line">Server:		112.100.100.100</span><br><span class="line">Address:	112.100.100.100#53</span><br><span class="line">Non-authoritative answer:</span><br><span class="line">sina.com	mail exchanger = 5 freemx1.sinamail.sina.com.cn.</span><br><span class="line">sina.com	mail exchanger = 10 freemx2.sinamail.sina.com.cn.</span><br><span class="line">sina.com	mail exchanger = 10 freemx3.sinamail.sina.com.cn.</span><br></pre></td></tr></table></figure>
<h5 id="再查询三A个记录的IP"><a href="#再查询三A个记录的IP" class="headerlink" title="再查询三A个记录的IP"></a>再查询三A个记录的IP</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Authoritative answers can be found from:</span><br><span class="line">&gt; set type=a</span><br><span class="line">&gt; freemx1.sinamail.sina.com.cn.</span><br><span class="line">Server:		112.100.100.100</span><br><span class="line">Address:	112.100.100.100#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:	freemx1.sinamail.sina.com.cn</span><br><span class="line">Address: 202.108.3.242</span><br><span class="line">&gt; freemx2.sinamail.sina.com.cn.</span><br><span class="line">Server:		112.100.100.100</span><br><span class="line">Address:	112.100.100.100#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:	freemx2.sinamail.sina.com.cn</span><br><span class="line">Address: 218.30.115.106</span><br><span class="line">&gt; freemx3.sinamail.sina.com.cn.</span><br><span class="line">Server:		112.100.100.100</span><br><span class="line">Address:	112.100.100.100#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:	freemx3.sinamail.sina.com.cn</span><br><span class="line">Address: 60.28.2.248</span><br></pre></td></tr></table></figure>
<h5 id="查询新浪的所有域名服务器"><a href="#查询新浪的所有域名服务器" class="headerlink" title="查询新浪的所有域名服务器"></a>查询新浪的所有域名服务器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# nslookup</span><br><span class="line">&gt; set type=ns</span><br><span class="line">&gt; sina.com</span><br></pre></td></tr></table></figure>
<p>返回结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Non-authoritative answer:</span><br><span class="line">sina.com	nameserver = ns3.sina.com.</span><br><span class="line">sina.com	nameserver = ns2.sina.com.cn.</span><br><span class="line">sina.com	nameserver = ns2.sina.com.</span><br><span class="line">_sina.com nameserver = ns1.sina.com._</span><br><span class="line">sina.com	nameserver = ns1.sina.com.cn.</span><br><span class="line">sina.com	nameserver = ns3.sina.com.cn.</span><br><span class="line">sina.com	nameserver = ns4.sina.com.cn.</span><br><span class="line">sina.com	nameserver = ns4.sina.com.</span><br><span class="line">Authoritative answers can be found from:</span><br></pre></td></tr></table></figure></p>
<h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>解析<em>sina.com nameserver = ns1.sina.com.</em>对应的ip地址:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; set type=a</span><br><span class="line">&gt; ns1.sina.com</span><br></pre></td></tr></table></figure></p>
<p>返回结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Server:		112.100.100.100</span><br><span class="line">Address:	112.100.100.100#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:	ns1.sina.com</span><br><span class="line">Address: 114.134.80.144</span><br></pre></td></tr></table></figure></p>
<p>以此类推我们可以将sina的所有ip地址全部解析出来!</p>
<hr>
<h4 id="参数set-type-any"><a href="#参数set-type-any" class="headerlink" title="参数set type=any"></a>参数set type=any</h4><p>any可以解析所有的服务器记录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; set type=any</span><br><span class="line">&gt; sina.com</span><br></pre></td></tr></table></figure></p>
<p>返回结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Address: 66.102.251.33</span><br><span class="line">sina.com	text = &quot;v=spf1 include:spf.sinamail.sina.com.cn -all&quot;</span><br><span class="line">sina.com</span><br><span class="line">	origin = ns1.sina.com.cn</span><br><span class="line">	mail addr = zhihao.staff.sina.com.cn</span><br><span class="line">	serial = 2005042601</span><br><span class="line">	refresh = 900</span><br><span class="line">	retry = 300</span><br><span class="line">	expire = 604800</span><br><span class="line">	minimum = 300</span><br><span class="line">sina.com	nameserver = ns2.sina.com.</span><br><span class="line">sina.com	nameserver = ns3.sina.com.</span><br><span class="line">sina.com	nameserver = ns1.sina.com.cn.</span><br><span class="line">sina.com	nameserver = ns2.sina.com.cn.</span><br><span class="line">sina.com	nameserver = ns1.sina.com.</span><br><span class="line">sina.com	nameserver = ns4.sina.com.cn.</span><br><span class="line">sina.com	nameserver = ns4.sina.com.</span><br><span class="line">sina.com	nameserver = ns3.sina.com.cn.</span><br><span class="line">sina.com	mail exchanger = 10 freemx2.sinamail.sina.com.cn.</span><br><span class="line">sina.com	mail exchanger = 10 freemx3.sinamail.sina.com.cn.</span><br><span class="line">sina.com	mail exchanger = 5 freemx1.sinamail.sina.com.cn.</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到any查询出了sina.com域名的所有记录，ns记录，mail邮件交换记录。除此以为我们可以看到有一条特殊的记录即”text”,SPF记录，其作用就是反垃圾邮件的，根据方向解析，获得垃圾邮件的来源地址，对服务器得到ip进行对比，若匹配则判断为正规邮件，不匹配则为垃圾邮件！</p>
<p><strong> 当然以上的命令可以合成一条：nslookup -q=any 163.com</strong></p>
<hr>
<h3 id="0x03-PTR反向解析记录"><a href="#0x03-PTR反向解析记录" class="headerlink" title="0x03 PTR反向解析记录"></a>0x03 PTR反向解析记录</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/04/10/第二十一章-软件的源代码安装/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="onejustonee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="onejustone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/10/第二十一章-软件的源代码安装/" itemprop="url">第二十一章-软件安装</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-10T22:22:52+08:00">
                2016-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/technology/" itemprop="url" rel="index">
                    <span itemprop="name">technology</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="0x00-软件的安装升级"><a href="#0x00-软件的安装升级" class="headerlink" title="0x00 软件的安装升级"></a>0x00 软件的安装升级</h3><hr>
<h4 id="关于源代码，编译器与与可执行文件"><a href="#关于源代码，编译器与与可执行文件" class="headerlink" title="关于源代码，编译器与与可执行文件"></a>关于源代码，编译器与与可执行文件</h4><p>Linux系统上真正认可的可执行文件其实只有二进制文件(binary program)。shell scripts只是利用了shell这一程序的功能进行一些判断，其实任是呼叫一些已经编译好的二进制程序来执行。可以使用file命令来判断是否为二进制文件。</p>
<p>关于编译与链接与gcc可以看另一篇文章:<a href="http://www.jianshu.com/p/96fa579665e9" target="_blank" rel="noopener">http://www.jianshu.com/p/96fa579665e9</a></p>
<hr>
<h4 id="关于函数库"><a href="#关于函数库" class="headerlink" title="关于函数库"></a>关于函数库</h4><p>函数库分为动态和静态函数库，Linux的核心提供很多的核心相关函数库与外部参数，这些核心相关参数大多放在/usr/include，/usr/lib，/usr/lib64下。</p>
<hr>
<h4 id="关于make与configure"><a href="#关于make与configure" class="headerlink" title="关于make与configure"></a>关于make与configure</h4><p>make的主要作用是简化编译过程的指令。我们知道使用gcc进行单一程序编译时，但是无所谓，很简单，但若是一个大点的项目呢？gcc就吃不消了。</p>
<p>当使用make命令时，make会在当前目录下搜索Makefile这个文件，里面记录了源代码如何编译的详细信息。并且会自动判断源代码是否改动过了，而自动更新可执行文件。</p>
<p>其实每个软件都会有一个运行环境侦查程序，用来检测系统已经具备该安装该软件所需的环境或者相关依赖，即使通常所说的configure或者是config。然后我们运行config来呼叫make对源代码进行编译，生成可执行文件。 </p>
<p>也正因为如此，不同OS的核心，或者函数库的位置的不同，一旦编译过的软件是很难在其它的OS上运行，所以才需要重复编译源代码。</p>
<hr>
<h4 id="关于Tarball"><a href="#关于Tarball" class="headerlink" title="关于Tarball"></a>关于Tarball</h4><p>Tarball就是将软件的源代码先以tar打包，然后再压缩的包了。</p>
<hr>
<h3 id="0x01-关于程序的编译"><a href="#0x01-关于程序的编译" class="headerlink" title="0x01 关于程序的编译"></a>0x01 关于程序的编译</h3><p>假如有两个程序，主程序是:thanks<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"> printf(&quot;hello world!\n&quot;);</span><br><span class="line"> thanks_2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>副程序是：thanks_2()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">void thanks_s(void)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;thanks you!!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="将两个程序进行编译后链接"><a href="#将两个程序进行编译后链接" class="headerlink" title="将两个程序进行编译后链接"></a>将两个程序进行编译后链接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  c_programer gcc -c thanks.c thanks_2.c </span><br><span class="line">➜  c_programer ll thanks*                       </span><br><span class="line">-rw-r--r-- 1 root root 1496 5月  29 09:23 thanks_2.o</span><br><span class="line">-rw-r--r-- 1 root root 1560 5月  29 09:23 thanks.o</span><br><span class="line">➜  c_programer gcc -o thanks thanks.o thanks_2.o</span><br><span class="line">➜  c_programer ls thanks*</span><br><span class="line">thanks  thanks_2.c  thanks_2.o  thanks.c  thanks.o</span><br><span class="line">➜  c_programer file thanks</span><br><span class="line">thanks: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, </span><br><span class="line">interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, not stripped</span><br></pre></td></tr></table></figure>
<p>编译完成得到.o文件，然后进行链接最后得到可执行文件thanks。</p>
<h2 id="由此我们可以知道目标文件-o的意义，因为有时候源代码文件不知一个，我们无法直接进行编译，这时便要先生成目标文件，然后在链接成为可执行文件。此外，当某个源文件更新后也不需要从新编译整个项目，而是只需要编译该个源文件，然后再链接就行。"><a href="#由此我们可以知道目标文件-o的意义，因为有时候源代码文件不知一个，我们无法直接进行编译，这时便要先生成目标文件，然后在链接成为可执行文件。此外，当某个源文件更新后也不需要从新编译整个项目，而是只需要编译该个源文件，然后再链接就行。" class="headerlink" title="由此我们可以知道目标文件.o的意义，因为有时候源代码文件不知一个，我们无法直接进行编译，这时便要先生成目标文件，然后在链接成为可执行文件。此外，当某个源文件更新后也不需要从新编译整个项目，而是只需要编译该个源文件，然后再链接就行。"></a>由此我们可以知道目标文件.o的意义，因为有时候源代码文件不知一个，我们无法直接进行编译，这时便要先生成目标文件，然后在链接成为可执行文件。此外，当某个源文件更新后也不需要从新编译整个项目，而是只需要编译该个源文件，然后再链接就行。</h2><h3 id="0x02-make编译"><a href="#0x02-make编译" class="headerlink" title="0x02 make编译"></a>0x02 make编译</h3><p>pass</p>
<hr>
<h3 id="0x03-Tarball的管理"><a href="#0x03-Tarball的管理" class="headerlink" title="0x03 Tarball的管理"></a>0x03 Tarball的管理</h3><hr>
<h3 id="0x04-函数库管理"><a href="#0x04-函数库管理" class="headerlink" title="0x04 函数库管理"></a>0x04 函数库管理</h3><hr>
<h3 id="0x05-软件检验"><a href="#0x05-软件检验" class="headerlink" title="0x05 软件检验"></a>0x05 软件检验</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/04/10/第十一章-认识与学习BASH/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="onejustonee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="onejustone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/10/第十一章-认识与学习BASH/" itemprop="url">第十一章-BASH</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-10T22:22:52+08:00">
                2016-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/technology/" itemprop="url" rel="index">
                    <span itemprop="name">technology</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="0x00-关于BASH"><a href="#0x00-关于BASH" class="headerlink" title="0x00 关于BASH"></a>0x00 关于BASH</h3><p>管理整个计算机硬件的其实是操作系统的核心 (kernel)，这个核心是需要被保护的！ 所以我们一般使用者就只能透过 shell 来跟核心沟通，以让核心达到我们所想要达到的工作。</p>
<p>Shell其实就是能够操作应用程序的接口的壳程序！</p>
<p>但是shell的版本是很多的，比如Bourne SHell(sh),C SHell,商业上常用的K SHell，以及Bourn Again SHell(bash)这个是Bourne SHell的增强版！</p>
<p>而bash 是 GNU 计划中重要的工具软件之一，目前也是 Linux distributions 的标准 shell 。 bash 主要兼容于 sh ，并且依据一些使用者需求，而加强的 shell 版本。不论你使用的是那个 distribution ，你都难逃需要学习 bash 的宿命啦！</p>
<p>查看/etc/shells文件看看我们的电脑可以使用哪些shell:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# cat /etc/shells </span><br><span class="line"># /etc/shells: valid login shells</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/dash</span><br><span class="line">/bin/bash</span><br><span class="line">/bin/rbash</span><br><span class="line">/usr/bin/screen</span><br><span class="line">/usr/bin/tmux</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="Bash-shell的功能"><a href="#Bash-shell的功能" class="headerlink" title="Bash shell的功能:"></a>Bash shell的功能:</h4><p><strong>命令记忆功能:</strong><br>bash最棒的一个功能就是能记住你过去使用过的命令，默认可以记住1000条，它会将所有记住的命令存放在你的加目录.bash_history中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# cat .bash_history</span><br></pre></td></tr></table></figure></p>
<p>但需要知道的是，~/.bash_history 记录的是前一次登陆以前所运行过的命令，而至于这一次登陆所运行的命令都被缓存在内存中，当你成功的注销系统后，该命令记忆才会记录到 .bash_history 当中！</p>
<p><strong>命令别名配置功能:(alias)</strong><br>我们可以个一些常用的同时又很复杂的命令设置别名，比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# alias lm=&apos;ls -al&apos;</span><br></pre></td></tr></table></figure></p>
<p><strong>通配符:</strong><br>bash还支持许多的通配符来帮助用户查询与命令下达:<br>例如:<strong>{ $ ls -l /usr/bin/X* }</strong>查询/usr/bin下以X开头的文件.</p>
<p><strong>小插曲:</strong>命令的下达</p>
<p>使用(反斜杠)来跳脱:当我们下达的命令太长需要两行时:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# cp /var/spool/mail/root/etc/crontab\</span><br><span class="line">&gt; /etc/bin /root</span><br></pre></td></tr></table></figure></p>
<p>将三个文件复制到/root下。</p>
<hr>
<h3 id="0x01-shell的变量功能"><a href="#0x01-shell的变量功能" class="headerlink" title="0x01 shell的变量功能"></a>0x01 shell的变量功能</h3><hr>
<h4 id="变量的取用与配置"><a href="#变量的取用与配置" class="headerlink" title="变量的取用与配置"></a>变量的取用与配置</h4><p>首先我们来取出变量的内容出来看看，这样我们便要用到echo命令了，当然echo的可不止这一个哈，后面我们会慢慢道来，变量在被取用时，前面必须要加上美元符号”$”,或者用”${PATH}”来读取！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">root@jack:~# echo $&#123;PATH&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="在shell中配置一个变量"><a href="#在shell中配置一个变量" class="headerlink" title="在shell中配置一个变量"></a>在shell中配置一个变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# echo $myname</span><br><span class="line">root@jack:~# myname=jack</span><br><span class="line">root@jack:~# echo $myname</span><br><span class="line">jack</span><br></pre></td></tr></table></figure>
<p>若你有一个常去的工作目录名称为：『/cluster/server/work/taiwan_2005/003/』，如何进行该目录的简化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~#  work=&quot;/cluster/server/work/taiwan_2005/003/&quot;</span><br><span class="line">root@jack:~# cd $work</span><br></pre></td></tr></table></figure></p>
<h4 id="变量的配置规则"><a href="#变量的配置规则" class="headerlink" title="变量的配置规则:"></a>变量的配置规则:</h4><ul>
<li><p>变量内容若有空格符号可以使用双引号(“)或单引号(‘)将变量内容结合起来，但:</p>
<ul>
<li>双引号内的特殊字符如 $ 等，可以保有原本的特性，如下所示：『var=”lang is $LANG”』则『echo $var』可得『lang is en_US』</li>
<li>单引号内的特殊字符则仅为一般字符 (纯文本)，如下所示：『var=’lang is $LANG’』则『echo $var』可得『lang is $LANG』</li>
</ul>
</li>
<li><p>可用跳脱字符『 \ 』将特殊符号(如 [Enter], $, \, 空格符, ‘等)变成一般字符；</p>
</li>
<li><p>在一串命令中，还需要藉由其他的命令提供的信息，可以使用反单引号『`命令`』或『$(命令)』。特别注意，那个 ` 是键盘上方的数字键 1 左边那个按键，而不是单引号！例如想要取得核心版本的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# uname -r</span><br><span class="line">4.0.0-kali1-amd64</span><br><span class="line">root@jack:~# versoin=$(uname -r)</span><br><span class="line">root@jack:~# echo $versoin </span><br><span class="line">4.0.0-kali1-amd64</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>已知locate命令可以列出所有的相关文件来，但是如果我想知道所有文件的权限呢?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# ls -l `locate sina`</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>若该变量为扩增变量内容时，则可用 “$变量名称” 或 ${变量} 累加内容，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# version=$&#123;version&#125;yes</span><br><span class="line">root@jack:~# echo $version</span><br><span class="line">4.0.0-kali1-amd64yes</span><br></pre></td></tr></table></figure>
</li>
<li><p>若该变量需要在其他子程序运行，则需要以 export 来使变量变成环境变量：<br>『export PATH』</p>
</li>
<li><p>取消变量的方法为使用 unset 『unset变量名称』例如取消 myname 的配置:unset myname</p>
</li>
</ul>
<hr>
<h3 id="0x02-环境变量的功能"><a href="#0x02-环境变量的功能" class="headerlink" title="0x02 环境变量的功能"></a>0x02 环境变量的功能</h3><p>我们可以使用env和export两个命令来查看目前我的shell环境中有多少默认的环境变量!</p>
<hr>
<h4 id="env观察环境变量与常用环境变量"><a href="#env观察环境变量与常用环境变量" class="headerlink" title="env观察环境变量与常用环境变量:"></a>env观察环境变量与常用环境变量:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# env</span><br><span class="line">XDG_VTNR=7</span><br><span class="line">GPG_AGENT_INFO=/run/user/0/keyring/gpg:0:1</span><br><span class="line">SHELL=/bin/bash &#123; 代表目前使用的shell&#125;</span><br><span class="line">TERM=xterm</span><br><span class="line">LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;</span><br><span class="line">.........(省略)</span><br><span class="line">USERNAME=root</span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin &#123; 这个就是运行文件搜索的路径啦，目录与目录之间用冒号隔开&#125;</span><br><span class="line">DESKTOP_SESSION=default</span><br><span class="line">QT_IM_MODULE=fcitx</span><br><span class="line">PWD=/root</span><br><span class="line">HOME=/root &#123; 代表用户的家目录，很多程序都可能会取用到这个变量的值!&#125;</span><br></pre></td></tr></table></figure>
<p>env是(enviroment)的缩写，上面的意思是列出所有的环境变量来，当然export其中的一个功能也是可以这样的！</p>
<hr>
<h4 id="set观察所有变量-包括环境变量与自定义变量"><a href="#set观察所有变量-包括环境变量与自定义变量" class="headerlink" title="set观察所有变量(包括环境变量与自定义变量)"></a>set观察所有变量(包括环境变量与自定义变量)</h4><p>set 除了环境变量之外， 还会将其他在 bash 内的变量通通显示出来，下面仅列出几个重要的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# set</span><br><span class="line">GTK_IM_MODULE=fcitx</span><br><span class="line">HISTCONTROL=ignoreboth</span><br><span class="line">HISTFILE=/root/.bash_history</span><br><span class="line">HISTFILESIZE=2000</span><br><span class="line">HISTSIZE=1000</span><br><span class="line">HOME=/root</span><br><span class="line">HOSTNAME=jack</span><br><span class="line">HOSTTYPE=x86_64</span><br><span class="line">IFS=$&apos; \t\n&apos;</span><br><span class="line">LANG=zh_CN.UTF-8</span><br><span class="line">LINES=24</span><br><span class="line">LOGNAME=root</span><br></pre></td></tr></table></figure>
<p>基本上，在 Linux默认的情况中，使用{大写的字母}来配置的变量一般为系统内定需要的变量，比较重要的有以下几个:</p>
<h5 id="PS1-提示字符的配置"><a href="#PS1-提示字符的配置" class="headerlink" title="PS1:提示字符的配置"></a>PS1:提示字符的配置</h5><p>这是 PS1 (数字的 1 不是英文字母)，这个东西就是我们的『命令提示字符』喔！当我们每次按下 [Enter] 按键去运行某个命令后，最后要再次出现提示字符时，    就会主动去读取这个变量值了</p>
<pre><code>* \d ：可显示出『星期 月 日』的日期格式，如：&quot;Mon Feb 2&quot;
* \H ：完整的主机名。举例来说，鸟哥的练习机为『www.vbird.tsai』
* \h ：仅取主机名在第一个小数点之前的名字，如鸟哥主机则为『www』后面省略 
*  \t ：显示时间，为 24 小时格式的『HH:MM:SS』
*  \T ：显示时间，为 12 小时格式的『HH:MM:SS』
* \A ：显示时间，为 24 小时格式的『HH:MM』
* \@ ：显示时间，为 12 小时格式的『am/pm』样式
* \u ：目前使用者的账号名称，如『root』；
* \v ：BASH 的版本信息，如鸟哥的测试主板本为 3.2.25(1)，仅取『3.2』显示
* \w ：完整的工作目录名称，由根目录写起的目录名称。但家目录会以 ~ 取代；
* \W ：利用 basename 函数取得工作目录名称，所以仅会列出最后一个目录名。
* \# ：下达的第几个命令。
* \$ ：提示字符，如果是 root 时，提示字符为 # ，否则就是 $ 啰～
</code></pre><p>配置我的字符提示变量:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# PS1=&apos;[\u@\h \w \A #\#]\$ &apos;</span><br><span class="line">[root@jack ~ 15:27 #2]# ls</span><br></pre></td></tr></table></figure></p>
<h5 id="export-自定义变量转换成环境变量"><a href="#export-自定义变量转换成环境变量" class="headerlink" title="export 自定义变量转换成环境变量"></a>export 自定义变量转换成环境变量</h5><p>其实所谓的环境变量(也可以理解为全局变量)与自定义变量(也可以理解为局部变量)的区别便是，<strong>该变量是否会被子程序所继续引用</strong>。当我们登录Linux并取得一个bash后，我们得到的bash就是一个独立的程序，接下来在这个bash底下所下达的任何命令都是由这个bash衍生出来的，那些被下达的命令就被成为子程序了，在shell中，<strong>子程序仅会继承父程序的环境变量，而不会继承父程序的自定义变量</strong>,所以这时export命令就很有用了！export主要用在<strong>分享自己的变量配置给后来呼叫的文件或其他程序</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@jack ~ 15:46 #4]# export 变量名</span><br></pre></td></tr></table></figure></p>
<p>这里关于如何就爱那个环境变量转换成自定义变量将在后续的declare里介绍！</p>
<hr>
<h3 id="0x03-变量键盘读取，数组，声明-read-array-declare"><a href="#0x03-变量键盘读取，数组，声明-read-array-declare" class="headerlink" title="0x03 变量键盘读取，数组，声明:read,array,declare"></a>0x03 变量键盘读取，数组，声明:read,array,declare</h3><hr>
<h4 id="read"><a href="#read" class="headerlink" title="read"></a>read</h4><p> 用来读取来自键盘的输入的变量，用法如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">选与参数:&#123; USE $: read [-pt] variable &#125;</span><br><span class="line">-p:后面可以接提示字符</span><br><span class="line">-t:后面接等待的&quot;秒数&quot;</span><br></pre></td></tr></table></figure></p>
<p>从键盘输入一内容，并将该内容赋值给test变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# read test</span><br><span class="line">this is test   &quot;&#123;此时光标会等待你输入，此处我输入的是&quot;this is test&quot;&#125;&quot;</span><br><span class="line">root@jack:~# echo $test</span><br><span class="line">this is test</span><br></pre></td></tr></table></figure></p>
<p>提示用户在30秒内输入自己的名字，并将该内容赋值给变量named<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# read -p &quot;please input your name:&quot; -t 30 named</span><br><span class="line">please input your name:jack &quot;&#123; 看，此时会有提示字符哟！&#125;&quot;</span><br><span class="line">root@jack:~# echo $named</span><br><span class="line">jack</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="declare-typeset"><a href="#declare-typeset" class="headerlink" title="declare/typeset"></a>declare/typeset</h4><p>declare或typeset是一样的功能，就是<strong>声明变量的类型</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">选项与参数:&#123;USE $: declare [-aixr] variable &#125;</span><br><span class="line">-a:将变量定义为数组类型(array)</span><br><span class="line">-i:将变量定义为整数类型(integer)</span><br><span class="line">-x:用法与export一样，就是将变量变成环境变量</span><br><span class="line">-r:将变量配置为readonly类型，该变量不可被更改，也不能unset</span><br></pre></td></tr></table></figure></p>
<p>需要知道的是，在默认情况下，bash对于变量有几个基本的定义:</p>
<ul>
<li>变量类型默认为<strong>字符串</strong>，所以若是不指定变量类型，则1+2为一个字符而不是数学表达式</li>
<li>bash环境中的数值运算，默认只能达到整数形态，所以1/3结果是0</li>
</ul>
<p>让变量sum进行100+300+50的计算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# declare -i sum=100+300+50</span><br><span class="line">root@jack:~# echo $sum</span><br><span class="line">450</span><br></pre></td></tr></table></figure></p>
<p>将sum变成环境变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# declare -x sum</span><br><span class="line">root@jack:~# export | grep sum</span><br><span class="line">declare -ix sum=&quot;450&quot;</span><br></pre></td></tr></table></figure></p>
<p>让sum变成只读属性，不可更改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# declare -r sum</span><br><span class="line">root@jack:~# sum=dkfd</span><br><span class="line">bash: sum: 只读变量</span><br></pre></td></tr></table></figure></p>
<p>让sum变回去，变成自定义变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# declare +x sum   &quot;&#123; 将-变成+就可以进行取消了 &#125;&quot;</span><br><span class="line">root@jack:~# declare +p sum   &quot;&#123; -p可以单独列出变量类型 &#125;&quot;</span><br><span class="line">declare -ir sum=&quot;450&quot;         &quot;&#123; 看，现在只剩下i，r属性了，不在具备x了 &#125;&quot;</span><br></pre></td></tr></table></figure></p>
<p>declare结合数组的在一起是很有用的，但有趣的是，一旦将变量的配置为<strong>只读</strong>通常得要注销再重新登陆才能该变量的类型！</p>
<hr>
<h4 id="数组-array-变量类型"><a href="#数组-array-变量类型" class="headerlink" title="数组(array)变量类型"></a>数组(array)变量类型</h4><p>在bash里数组的声明方式是:<strong>var[number]=content</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# var[1]=&quot;small min&quot;</span><br><span class="line">root@jack:~# var[2]=&quot;big min&quot;</span><br><span class="line">root@jack:~# var[3]=&quot;nice min&quot;</span><br><span class="line">root@jack:~# echo &quot;$&#123;var[1]&#125;,$&#123;var[2]&#125;,$&#123;var[3]&#125;&quot;</span><br><span class="line">small min,big min,nice min</span><br></pre></td></tr></table></figure></p>
<p>对于数组的读取，一般建议使用<strong>${数组}的方式来读取</strong></p>
<hr>
<h3 id="0x04-文件系统与程序的限制关系-ulimit"><a href="#0x04-文件系统与程序的限制关系-ulimit" class="headerlink" title="0x04 文件系统与程序的限制关系:ulimit"></a>0x04 文件系统与程序的限制关系:ulimit</h3><p>通过ulimit命令，bash可以<strong>限制某些用户的某些系统资源，包括可以开启的文件数量，可以使用的cpu时间，可以使用的内存总量等</strong></p>
<p><strong>ulimit</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">选项与参数:&#123; use $: ulimit [-SHacdfltu] 配额 &#125;</span><br><span class="line">-a ：后面不接任何选项与参数，可列出所有的限制额度；</span><br><span class="line">-f ：此 shell 可以创建的最大文件容量(一般可能配置为 2GB)单位为 Kbytes</span><br><span class="line">-u ：单一用户可以使用的最大程序(process)数量。</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="0x05-变量的删除取代与替换"><a href="#0x05-变量的删除取代与替换" class="headerlink" title="0x05 变量的删除取代与替换"></a>0x05 变量的删除取代与替换</h3><hr>
<h4 id="变量内容的删除"><a href="#变量内容的删除" class="headerlink" title="变量内容的删除"></a>变量内容的删除</h4><table>
<thead>
<tr>
<th style="text-align:center">变量配置方式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">${变量#关键字}</td>
<td style="text-align:center">若变量内容从头开始的数据符合[关键字]，则将符合的最短数据删除</td>
</tr>
<tr>
<td style="text-align:center">${变量##关键字}</td>
<td style="text-align:center">若变量内容从头开始的数据符合[关键字]，则将符合的最长数据删除</td>
</tr>
<tr>
<td style="text-align:center">${变量%关键字}</td>
<td style="text-align:center">若变量内容从尾向前的数据符合[关键字]，则将符合的最短数据删除</td>
</tr>
<tr>
<td style="text-align:center">${变量%%关键字}</td>
<td style="text-align:center">若变量内容从尾向前的数据符合[关键字]，则将符合的最长数据删除</td>
</tr>
<tr>
<td style="text-align:center">${变量/旧字符串/新字符串}</td>
<td style="text-align:center">若变量内容符合[旧字符串]，则[第一个字符串将会被新字符串所取代]</td>
</tr>
<tr>
<td style="text-align:center">${变量//旧字符串//新字符串}</td>
<td style="text-align:center">若变量内容符合[旧字符串]，则[全部字符串将会被新字符串所取代]</td>
</tr>
</tbody>
</table>
<p>实例:<br>根据需要删除path路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# path=$&#123;PATH&#125;</span><br><span class="line">#先让小写path获得PATH变量内容</span><br><span class="line">root@jack:~# echo path</span><br><span class="line">path</span><br><span class="line">root@jack:~# echo $path</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">#删除前四个目录</span><br><span class="line">root@jack:~# echo $&#123;path#/*usr/bin:&#125;</span><br><span class="line">/sbin:/bin</span><br></pre></td></tr></table></figure></p>
<p>删除前面的所有目录，只保留最后一个目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# echo $&#123;path##/*:&#125;</span><br><span class="line">/bin</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="变量的测试与内容替换"><a href="#变量的测试与内容替换" class="headerlink" title="变量的测试与内容替换"></a>变量的测试与内容替换</h4><p>有时候我们需要判断某个变量是否存在，Bash Shell可以进行变量的条件替换,既只有某种条件发生时才进行替换：</p>
<ul>
<li>(1) ${value:-word} 当变量未定义或者值为空时,返回值为word的内容,否则返回变量的值.<ul>
<li>(2) ${value:=word}与前者类似,只是若变量未定义或者值为空时,在返回word的值的同时将word赋值给value　</li>
<li>(3) ${value:?message}若变量以赋值的话,正常替换.否则将消息message送到标准错误输出(若此替换出现在Shell程序中,那么该程序将终止运行)　　</li>
<li>(4) ${value:+word}若变量以赋值的话,其值才用word替换,否则不进行任<br>何替换</li>
<li>(5) ${value:offset}　${value:offset:length}从变量中提取子串,这里offset和length可以是算术表达式.<br>以上变量测试也是可以通过shell script内的if…then…来处理的，既然bash有提供这么简单的方法我们也可以吸收一下下！</li>
</ul>
</li>
</ul>
<hr>
<h3 id="0x06-命令别名与历史命令"><a href="#0x06-命令别名与历史命令" class="headerlink" title="0x06 命令别名与历史命令"></a>0x06 命令别名与历史命令</h3><hr>
<h4 id="命令别名配置-alias-unalias"><a href="#命令别名配置-alias-unalias" class="headerlink" title="命令别名配置:alias,unalias"></a>命令别名配置:alias,unalias</h4><p>使用alias我们可以为一个很长的命令配置一简短的命令别名来取代既有的命令！</p>
<p><strong>使用方法:{ use $: alis 别名=’命令 选项…’ }</strong></p>
<p>例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# alias vi=&apos;vim&apos;</span><br><span class="line">root@jack:~# alias lm=&apos;ls -al | more&apos;</span><br><span class="line">root@jack:~# alias rm=&apos;rm -i&apos;</span><br></pre></td></tr></table></figure></p>
<p>然后使用alias查看目前有哪些命令别名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# alias</span><br><span class="line">alias lm=&apos;ls -al | more&apos;</span><br><span class="line">alias ls=&apos;ls --color=auto&apos;</span><br><span class="line">alias rm=&apos;rm -i&apos;</span><br><span class="line">alias vi=&apos;vim&apos;</span><br></pre></td></tr></table></figure></p>
<p>至于如果想要缺消别名的话，就使用unalias:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# unalias lm</span><br></pre></td></tr></table></figure></p>
<p>但是我们添加的alias会在没开机以后就没有了，如果想要永久生效，那么需要在.bashrc文件最后添加alias命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# vim .bashrc</span><br><span class="line"></span><br><span class="line">alias ffx=&apos;firefox &gt; /tmp/firefox.txt 2&gt;&amp;1 &amp;&apos;</span><br><span class="line">alias fuck-gwf=&apos;bash /software/shadowsocks-gui-0.6.4-linux-x64/start.sh &gt; /tmp/gwf.txt 2&gt;&amp;1 &amp;&apos;</span><br></pre></td></tr></table></figure></p>
<p>或者新建立一个文件名为.bash_aliases的文件用来专门存放我们的alias命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# vim .bash_aliases</span><br><span class="line">alias ffx=&apos;firefox &gt; /tmp/firefox.txt 2&gt;&amp;1 &amp;&apos;</span><br><span class="line">alias fuck-gwf=&apos;bash /software/shadowsocks-gui-0.6.4-linux-x64/start.sh &gt; /tmp/gwf.txt 2&gt;&amp;1 &amp;&apos;</span><br></pre></td></tr></table></figure></p>
<p>然后，更新下:source .bashrc文件！{ 对了上面两个命令，懂的自然懂，哈哈！！}</p>
<hr>
<h4 id="历史命令-history"><a href="#历史命令-history" class="headerlink" title="历史命令 history"></a>历史命令 history</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">选项与参数:&#123; use $: history [n][-c]/[-raw] histfiles &#125;__</span><br><span class="line">n:数字，列出最近的n笔命令</span><br><span class="line">-c:将目前shell中的所有的history内容全部消除</span><br><span class="line">-a:将目前新增的histoty命令新曾到histfiles中，如没有加histfiles则默认写入～/.bash_histoty</span><br><span class="line">-r:将histfiles的内容读到目前这个shell的history中</span><br><span class="line">-w:将目前的history记录写入到histfiles</span><br></pre></td></tr></table></figure>
<p>history除了能记录历史命令外，还能帮助我们利用相关功能运行命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# !n</span><br><span class="line">root@jack:~# !command</span><br><span class="line">root@jack:~# !!</span><br><span class="line">选项与参数:</span><br><span class="line">n:运行history中第几个命令</span><br><span class="line">command:运行命令开头为command的命令</span><br><span class="line">!!:运行上一个命令</span><br></pre></td></tr></table></figure></p>
<p>其实history的用途是很多的，尤其是root的历史记录文件，是黑客的最爱，一旦解析该文件，便极有可能在～/.bash_history中获得重要数据！</p>
<hr>
<h3 id="0x07-Bash-shell的操作环境"><a href="#0x07-Bash-shell的操作环境" class="headerlink" title="0x07 Bash shell的操作环境"></a>0x07 Bash shell的操作环境</h3><hr>
<h4 id="路径与命令搜索顺序"><a href="#路径与命令搜索顺序" class="headerlink" title="路径与命令搜索顺序"></a>路径与命令搜索顺序</h4><p>1.以相对/绝对路径运行命令，例如『 /bin/ls 』或『 ./ls 』；<br>2.由 alias 找到该命令来运行；<br>3.由 bash 内建的 (builtin) 命令来运行；<br>4.透过 $PATH 这个变量的顺序搜寻到的第一个命令来运行。</p>
<hr>
<h4 id="环境配置文件"><a href="#环境配置文件" class="headerlink" title="环境配置文件"></a>环境配置文件</h4><p>bash的环境配置文件有全局配置文件和个人配置文件之分，需要注意的是我们前面谈到的命令的别名，自定义的变量啊，在注销bash以后就会失效，如果想要保留配置，就得将这些配置写入配置文件！</p>
<h5 id="login-shell"><a href="#login-shell" class="headerlink" title="login shell"></a>login shell</h5><p>login shell会读取两个配置文件:</p>
<ul>
<li>etc/profile:这个是系统的整体配置文件<br>每个使用者登录取得bash时一定会读取的配置文件</li>
<li>～/.bash_profile or ~/.bash_login or ~/.profile:个人配置文件</li>
</ul>
<p>bash在读完了整体环境配置/etc/profile并由此呼叫其它配置文件后，才会读取使用者的个人配置文件,依序是:</p>
<ul>
<li>~/.bash_profile</li>
<li>~/.bash_login</li>
<li>~/.profile</li>
</ul>
<p>其实bash的login shell配置只会读取以上三个文中的一个，而读取的顺序是依照上面的顺序!</p>
<h5 id="source-更新环境配置文件的命令"><a href="#source-更新环境配置文件的命令" class="headerlink" title="source 更新环境配置文件的命令"></a>source 更新环境配置文件的命令</h5><p> 由于 /etc/profile 与 ~/.bash_profile 都是在取得 login shell 的时候才会读取的配置文件，所以， 如果你将自己的偏好配置写入上述的文件后，通常都是得注销再登陆后，该配置才会生效。但是我们可以使用source或者小数点(.)命令都可以将配置文件的内容读进来目前的shell环境中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# source ~/.bashrc</span><br><span class="line">root@jack:~# .  ~/.bashrc</span><br></pre></td></tr></table></figure></p>
<h5 id="non-login-shell"><a href="#non-login-shell" class="headerlink" title="non-login shell"></a>non-login shell</h5><p>non-login shell这种非登录的取得的配置文件就是~/.bashrc</p>
<ul>
<li>其它相关配置文件<ul>
<li>/etc/man.config<br>规范了使用 man 的时候， man page 的路径到哪里去寻找！』所以说的简单一点，这个文件规定了下达man 的时候，该去哪里查看数据的路径配置！当以 tarball 的方式来安装你的数据，那么你的 man page 可能会放置在 /usr/local/softpackage/man 里头，那个 softpackage 是你的软件名称， 这个时候你就得以手动的方式将该路径加到 /etc/man.config 里头，否则使用 man 的时候就会找不到相关的说明档啰。</li>
<li>~/.bash_history<br>记录历史命令的文件，每次登录shell后，bash会先读取这个文件，将所有的历史命令读入内存！</li>
<li>~/.bash_logout<br>该文件则记录了当我注销bash后，系统再帮我做完什么动作以后才离开!</li>
</ul>
</li>
</ul>
<h4 id="终端机的环境配置-stty-set"><a href="#终端机的环境配置-stty-set" class="headerlink" title="终端机的环境配置:stty,set"></a>终端机的环境配置:stty,set</h4><p> 一般来讲，linux都帮我们做好了最好的使用者环境了，所以我们不用担心操作环境的问题，倒是了解了解总是可以的，比如如何在终端机中查询快捷键使用，或者更改终端机中的快捷键！</p>
<p> 我们可以使用<strong>stty -a</strong>来列出目前环境中所有的按键，^表示Ctrl的意思:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# stty -a</span><br><span class="line">speed 38400 baud; rows 18; columns 80; line = 0;</span><br><span class="line">intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = M-^?; eol2 = M-^?;</span><br><span class="line">swtch = M-^?; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W;</span><br><span class="line">lnext = ^V; flush = ^O; min = 1; time = 0;</span><br></pre></td></tr></table></figure></p>
<p>几个重要的代表意义是:</p>
<ul>
<li>eof: end of file,输入结束，例如邮件结束是，{ ^D }</li>
<li>erase:向后删除字符,{ ^? }</li>
<li>intr:送出一个interrupt(中断)的讯号给目前正run的程序，终止目前命令,{ ^C }</li>
<li>kill:删除在目前命令上的所有文字，在提示符下，将整列命令删除，{ ^U }</li>
<li>quit:送出一个quit讯号给目前正在run的程序,{ ^\ }</li>
<li>start:在某个程序停止后，重新启动其他的output,，恢复屏幕输出，{ ^Q }</li>
<li>stop:暂停目前屏幕的输出,{ ^S }</li>
<li>susp:送出一个terminal stop的讯号给正在run的程序,暂停目前的命令，{ ^Z }</li>
</ul>
<h5 id="通配符与特殊符号"><a href="#通配符与特殊符号" class="headerlink" title="通配符与特殊符号"></a>通配符与特殊符号</h5><p>bash下通配符(wildcard)可以帮我更加方便的处理数据，下面是一些常用的通配符:</p>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:left">代表<strong>0到无穷多个</strong>任意字符</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:left">代表<strong>一定有一个</strong>任意字符</td>
</tr>
<tr>
<td style="text-align:center">[ ]</td>
<td style="text-align:left">代表<strong>一定有一个在括号内</strong>的字符(非任意)，例如 [abcd]代表一定有一个字符，可能是a，b，c，d中的任一个</td>
</tr>
<tr>
<td style="text-align:center">[ - ]</td>
<td style="text-align:left">若有减号在中括号内时，代表<strong>在编码顺序内的所有字符</strong>.例如 [0-9] 代表 0 到 9 之间的所有数字，因为数字的语系编码是连续的！</td>
</tr>
<tr>
<td style="text-align:center">[ ^ ]</td>
<td style="text-align:left">若中括号内的第一个字符为指数符号 (^) ，那表示<strong>反向选择</strong>,例如 [^abc] 代表 一定有一个字符，只要是非 a, b, c 的其他字符就接受的意思。</td>
</tr>
</tbody>
</table>
<p>下面是几个使用通配符查看文件的用例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# ls -d /etc/gro* </span><br><span class="line">#查找/etc下以gro开头的目录</span><br><span class="line">root@jack:~# ls -d /etc/?????</span><br><span class="line">#查找刚好是五个字母的目录</span><br><span class="line">root@jack:~# ls  /etc/*[0-9]*</span><br><span class="line">#查找文件名含有数字的文件</span><br></pre></td></tr></table></figure></p>
<p>当然，linux下除了通配符外还有一些特殊的符号，整理如下:</p>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:center">跳脱符号：将『特殊字符或通配符』还原成一般字符</td>
</tr>
<tr>
<td style="text-align:center">;</td>
<td style="text-align:center">连续命令下达分隔符：连续性命令的界定 (注意！与管线命令并不相同)</td>
</tr>
<tr>
<td style="text-align:center">~</td>
<td style="text-align:center">用户的家目录</td>
</tr>
<tr>
<td style="text-align:center">$</td>
<td style="text-align:center">取用变量前导符：亦即是变量之前需要加的变量取代值</td>
</tr>
<tr>
<td style="text-align:center">&gt;,&gt;&gt;</td>
<td style="text-align:center">数据流重导向：输出导向，分别是<strong>取代</strong>\与<strong>累加</strong></td>
</tr>
<tr>
<td style="text-align:center">&lt;,&lt;&lt;</td>
<td style="text-align:center">数据流重导向：输入导向</td>
</tr>
<tr>
<td style="text-align:center">‘ ‘</td>
<td style="text-align:center">单引号，不具有变量置换的功能</td>
</tr>
<tr>
<td style="text-align:center">“ “</td>
<td style="text-align:center">具有变量置换的功能！</td>
</tr>
<tr>
<td style="text-align:center">` `</td>
<td style="text-align:center">两个<strong> ` </strong>中间为可以先运行的命令，亦可使用 $( )</td>
</tr>
</tbody>
</table>
<p>文件名尽量不要使用到上述的字符！</p>
<hr>
<h3 id="0x08-数据流重定向"><a href="#0x08-数据流重定向" class="headerlink" title="0x08 数据流重定向"></a>0x08 数据流重定向</h3><p>数据流重定向(redirect)就是将某个命令运行以后应该要出现在屏幕上的数据，给传输到其他地方去，在我们想要将某些数据存储下来时，超级有用！！！</p>
<hr>
<h4 id="standard-output-and-standard-error-output"><a href="#standard-output-and-standard-error-output" class="headerlink" title="standard output and standard error output"></a>standard output and standard error output</h4><p> 在学习数据流重定向之前我们先来了解下何为标准输出以及标准错误输出:<br>标准输出(standard output)指的是:命令行所回传的错误信息，而标准错误输出(standard error output)是:命令运行后，所回传的错误信息</p>
<p> 通过重定向我们可以将standard output(简称stdout)与standard error output(简称stderr)分别传送到其它的文件或者装置中，而不是打印到屏幕上，而分别传送所用的特殊字符如下所示:<br>1.标准输入(stdin):代码为0，使用&lt;或&lt;&lt;;<br>2.标准输出(stdout):代码为1，使用&gt;或&gt;&gt;;<br>3.标准错误输出(stderr):代码为2，使用2&gt;或2&gt;&gt;;<br>(数字与重定向符号之间没有空空)</p>
<p> 其中:</p>
<ul>
<li>1&gt;:以覆盖的方法将<strong>正确的数据</strong>输出到指定的文件或装置上</li>
<li>1&gt;&gt;:以覆盖的方法将<strong>正确的数据</strong>输出到指定的文件或装置上</li>
<li>2&gt;:以覆盖的方法将<strong>错误的数据</strong>输出到指定的文件或装置上</li>
<li><p>2&gt;&gt;:以累加的方法将<strong>错误的数据</strong>输出到指定的文件或装置上</p>
<p>实例:将一个命令的执行返回结果产生的stdout与stderr分别存到不同的文件中去:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# find /home -name .bashrc &gt;list_right 2&gt;list_error</span><br><span class="line">root@jack:~#</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意，此时<strong>屏幕上不会出现任何信息</strong>，所有的信息都被放进了那两个文件中！</p>
<p> 进一步如果我知道错误信息是会发生，倒是要将其忽略掉而不显示或者存储呢？这时就可以使用黑洞装置了/dev/null,这个/dev/null可以吃掉任何导向这个装置的信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# find /home -name .bashrc 2&gt;/dev/null </span><br><span class="line">/home/.Trash-0/files/chrome/.bashrc</span><br></pre></td></tr></table></figure></p>
<p>如此，stdout会显示到屏幕上，而stderr被丢弃了！</p>
<p> 那要将所有的正确和错误的信息写入到同一个文件中呢？使用<strong>&amp;&gt;filename</strong>就ok<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# find /home -name .bashrc &amp;&gt;list</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="standard-input-lt-and-lt-lt"><a href="#standard-input-lt-and-lt-lt" class="headerlink" title="standard input : &lt; and &lt;&lt;"></a>standard input : &lt; and &lt;&lt;</h4><p> standard input &lt;就是原本需要<strong>由键盘输入的数据，改由文件内容来取代</strong>，而<strong>&lt;&lt;</strong>代表的是<strong>结束的输入字符关键字</strong></p>
<p> 利用cat来创建一个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# cat &gt; catfile</span><br><span class="line">one man&apos;s dream </span><br><span class="line">to be or not to be</span><br><span class="line">root@jack:~# cat catfile </span><br><span class="line">one man&apos;s dream </span><br><span class="line">to be or not to be</span><br></pre></td></tr></table></figure></p>
<p>用stdin代替键盘输入以创建文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# cat &gt; catfile &lt;~/.bashrc</span><br></pre></td></tr></table></figure></p>
<p>使用重定向创建文件，并且输入关键字”eof”代表结束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# cat &gt; catfile &lt;&lt;&quot;eof&quot;</span><br><span class="line">&gt; this is a test</span><br><span class="line">&gt; ok now stop</span><br><span class="line">&gt; eof</span><br><span class="line">root@jack:~#</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="命令输出导向的意义"><a href="#命令输出导向的意义" class="headerlink" title="命令输出导向的意义"></a>命令输出导向的意义</h4><ul>
<li>屏幕输出的信息很重要，而且我们需要将他存下来的时候；</li>
<li>背景运行中的程序，不希望他干扰屏幕正常的输出结果时；</li>
<li>一些系统的例行命令 (例如写在 /etc/crontab 中的文件) 的运行结果，希望他可以存下来时；</li>
<li>一些运行命令的可能已知错误信息时，想以『 2&gt; /dev/null 』将他丢掉时；</li>
<li>错误信息与正确信息需要分别输出时。</li>
</ul>
<hr>
<h4 id="命令运行的判断依据-amp-amp"><a href="#命令运行的判断依据-amp-amp" class="headerlink" title="命令运行的判断依据: ;,&amp;&amp;,||"></a>命令运行的判断依据: ;,&amp;&amp;,||</h4><p> 使用<strong>;</strong>来分隔命令从而达到一次执行多个命令的目的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# sync;sync;shutdown -h now</span><br><span class="line">#先运行两次 sync 同步化写入磁盘后才 shutdown 计算机</span><br></pre></td></tr></table></figure></p>
<p>换个角度，若我想实现两个命令之间的相关性呢？就是前一个命令执行的成功与否决定后一个命令是否执行，这时就要用到&amp;&amp;或||了</p>
<ul>
<li><strong>$?(命令回传值)与&amp;&amp;或||</strong><br>在linux中<strong>若前一个命令的运行结果为正确，会回传一个$?=0的值</strong>,然后我便可以借助<strong>&amp;&amp;或||</strong>来判断后续命令是否要执行了！</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">命令下达情况</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">cmd1&amp;&amp;cmd2</td>
<td style="text-align:center">1. 若 cmd1 运行完毕且正确运行($?=0)，则开始运行 cmd2。 2.若 cmd1 运行完毕且为错误 ($?≠0)，则 cmd2 不运行。</td>
</tr>
<tr>
<td style="text-align:center">cmd1or(只能有英文代替了双竖线死活显示不了) cmd2</td>
<td style="text-align:center">1.若 cmd1 运行完毕且正确运行($?=0)，则 cmd2 不运行。 2.若 cmd1 运行完毕且为错误 ($?≠0)，则开始运行 cmd2。</td>
</tr>
</tbody>
</table>
<p> 实例:<br>  先判断一个目录是否存在，若不存在则建立该目录,若存在不做任何事情<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# ls /tmp/abc || mkdir /tmp/abc</span><br><span class="line">ls: 无法访问/tmp/abc: 没有那个文件或目录</span><br><span class="line">root@jack:~# ls /tmp</span><br><span class="line">abc</span><br></pre></td></tr></table></figure></p>
<p>如果我不确定abc目录是否存在，但是我必须想要创建/tmp/abc/hehe文件怎么办?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# ls /tmp/abd || mkdir /tmp/abc &amp;&amp; touch /tmp/abd/hehe</span><br><span class="line">ls: 无法访问/tmp/abd: 没有那个文件或目录</span><br><span class="line">mkdir: 无法创建目录&quot;/tmp/abc&quot;: 文件已存在</span><br></pre></td></tr></table></figure></p>
<p>解释如下:</p>
<ul>
<li>(1)若 /tmp/abc 不存在故回传 $?≠0，则 (2)因为 || 遇到非为 0 的 $? 故开始 mkdir /tmp/abc，由于 mkdir /tmp/abc 会成功进行，所以回传 $?=0 (3)因为 &amp;&amp; 遇到 $?=0 故会运行 touch /tmp/abc/hehe，最终 hehe 就被创建了</li>
</ul>
<ul>
<li>(2)若 /tmp/abc 存在故回传 $?=0，则 (2)因为 || 遇到 0 的 $? 不会进行，此时 $?=0 继续向后传，故 (3)因为 &amp;&amp; 遇到 $?=0 就开始创建 /tmp/abc/hehe 了！最终 /tmp/abc/hehe 被创建起来。</li>
</ul>
<p>比如:<br>以 ls 测试 /tmp/vbirding 是否存在，若存在则显示 “exist” ，若不存在，则显示 “not exist”！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# ls /tmp/vbirding &amp;&amp; echo &quot;exist&quot; || echo &quot;not exist&quot;</span><br><span class="line">ls: 无法访问/tmp/vbirding: 没有那个文件或目录</span><br><span class="line">not exist</span><br></pre></td></tr></table></figure></p>
<p>但如果反过来:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# ls /tmp/vbirding || echo &quot;not exist&quot; &amp;&amp; echo &quot;exist&quot;</span><br><span class="line">ls: 无法访问/tmp/vbirding: 没有那个文件或目录</span><br><span class="line">not exist</span><br><span class="line">exist</span><br></pre></td></tr></table></figure></p>
<p>not exist与exist同时出现了!why?<strong>原因在于,命令是从左向右顺序执行的，如果前一命令被执行者回传$?=0,若是前一个命令没有被执行，则会将前前一个的$?值继续传递给下一命令，所以&amp;&amp;或者||的顺序是不能颠倒的，这里存在一逻辑判断与回传值的问题</strong></p>
<hr>
<h3 id="0x09-管道命令"><a href="#0x09-管道命令" class="headerlink" title="0x09 管道命令"></a>0x09 管道命令</h3><p>管道命令使用的是”|”这个界定符号，另外管线命令与连续下达命令不一样的哈！</p>
<p>管道命令仅可以处理由前面一个命令传来的正确信息，也就是standard output的信息，对于standard error并没有直接处理的能力，例如less，more，head，tail等都是可以接受standard input的管道命令，至于ls，cp，mv等就不是管道命令了，因为ls，cp，mv不会接受来自stdin的数据。</p>
<hr>
<h4 id="截取命令-cut-grep"><a href="#截取命令-cut-grep" class="headerlink" title="截取命令:cut,grep"></a>截取命令:cut,grep</h4><p>截取其实就是将一段数据经过分析后，取出我们想要的，或者是经由关键字取得我们所想要的那一行，并且一般情况下，截取信息都是针对<strong>一行一行</strong>来分析的，并不是整篇信息分析的，不过cut在处理多空格相连数据时，会有点吃力。</p>
<h5 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h5><p>将一段信息的某一段给它<strong>切</strong>出来，处理的是<strong>以行为单位</strong>的信息 </p>
<p><strong>选项与参数: { usage $: cut -d’分割符号’ -f num  }</strong></p>
<ul>
<li>-d:后接分割符，与-f一起使用</li>
<li>-f:取出第几段的意思</li>
<li>-c:以字符为单位取出固定区间字符</li>
</ul>
<p>将PATH变量取出，找出第五个路径来:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">root@jack:~# echo $PATH | cut -d &apos;:&apos; -f4</span><br><span class="line">/usr/bin</span><br><span class="line">#如同上面的数字显示，我们是以【: 】作为分隔，因 此会出现</span><br><span class="line">/usr/local/bin</span><br></pre></td></tr></table></figure></p>
<h5 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h5><p>grep是分析一行信息，若当中有我们所有需要的信息，就将改行拿出来</p>
<p><strong>选项与参数:{ useage $: grep [-acinv] [–color=quto] ‘关键字’ filename</strong></p>
<ul>
<li>-a: 将 binary 文件以 text 文件的方式搜寻数据</li>
<li>-c:计算找到’关键字’的次数</li>
<li>-n:显示行号</li>
<li>-i:忽略大小写</li>
<li>-v:反向选择，显示出没有’关键字’的那一行</li>
<li>–color=auto:将找到的关键字部分加上颜色 </li>
</ul>
<p>将last(可查询本月里登录者的信息)中，有出现root的那一行就显示出来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# last | grep &apos;root&apos; -n --color=auto</span><br><span class="line">1:root     pts/0        :0               Mon Apr 18 18:47   still logged in   </span><br><span class="line">2:root     :0           :0               Mon Apr 18 18:22   still logged in   </span><br><span class="line">5:root     pts/0        :0               Sun Apr 17 14:24 - 16:29  (02:05)</span><br></pre></td></tr></table></figure></p>
<p>结合cut命令，只显示last行中含有root的第一列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# last | grep &apos;root&apos; -n | cut -d &apos; &apos; -f 1</span><br><span class="line">1:root</span><br><span class="line">2:root</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="排序命令-sort-uniq-wc"><a href="#排序命令-sort-uniq-wc" class="headerlink" title="排序命令:sort,uniq,wc"></a>排序命令:sort,uniq,wc</h4><h5 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h5><p><strong>选项与参数:{ usage $: sort [-fbMnrtuk] [file or stdin]</strong></p>
<ul>
<li>-f:忽略大小写</li>
<li>-b:忽略最前面空格部分</li>
<li>-M:一月份排序</li>
<li>-n:以数字排序</li>
<li>-r:反向排序</li>
<li>-u:重复信息过滤，只显示一次</li>
<li>-t:分隔符</li>
<li>-k:以哪个区间来进行排序</li>
</ul>
<p>/etc/password内容是以“：”来分隔的，现在以第三列来进行排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# cat /etc/passwd | sort -t &apos;:&apos; -k 3</span><br></pre></td></tr></table></figure></p>
<h5 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h5><p>wc的作用是显示文件有多少字，多少行，多少字符</p>
<p><strong>选项与参数:{ usage $: wc [-lwm] }</strong></p>
<ul>
<li>-l:显示有多少行</li>
<li>-w:显示有多少字(英文单词)</li>
<li>-m:多少字符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@jack:/etc# cat /etc/hosts | wc</span><br><span class="line">    7      22     184</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="双向重导向-tee"><a href="#双向重导向-tee" class="headerlink" title="双向重导向:tee"></a>双向重导向:tee</h4><p>tee 可以让 standard output 保存一份到文件内的同时并将同样的数据继续送到屏幕去处理！ 这样除了可以让我们同时分析一份数据并记录下来之外，还可以作为处理一份数据的中间缓存记录之用！</p>
<p><strong>选项与参数:{ usage $: tee [-a] file }</strong><br>参数-a，以累加(append)的方式将数据加入到file中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# last | tee last.list | cut -d &quot; &quot; -f1</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="字符转换命令-tr-col-join-paste-expand"><a href="#字符转换命令-tr-col-join-paste-expand" class="headerlink" title="字符转换命令:tr,col,join,paste,expand"></a>字符转换命令:tr,col,join,paste,expand</h4><h5 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h5><p>tr可以用来删除一段信息当中的文字，或者是进行文字信息的替换</p>
<p><strong>选项与参数:{ usage $:  tr [-ds] set1 …}</strong></p>
<ul>
<li>-d:删除信息当中的set1这个字符串</li>
<li>-s:取代掉重复的字符!</li>
</ul>
<p>将 last 输出的信息中，所有的小写变成大写字符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# last | tr [a-z] [A-Z]</span><br></pre></td></tr></table></figure></p>
<p>将 last输出的信息中，将冒号 (:) 删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# last | tr -d &apos;:&apos;</span><br></pre></td></tr></table></figure></p>
<h5 id="col"><a href="#col" class="headerlink" title="col"></a>col</h5><p><strong>选项与参数:{ usage $:  col [-xb] }</strong></p>
<ul>
<li>-x:将 tab 键转换成对等的空格键</li>
<li>-b:在文字内有反斜杠 (/) 时，仅保留反斜杠最后接的那个字符</li>
</ul>
<h5 id="join"><a href="#join" class="headerlink" title="join"></a>join</h5><p>他是在处理两个文件之间的数据，而且，主要是在处理『两个文件当中，有 “相同数据”的那一行，才将他加在一起』的意思</p>
<h5 id="past"><a href="#past" class="headerlink" title="past"></a>past</h5><p>paste 就直接『将两行贴在一起，且中间以 [tab] 键隔开』而已！</p>
<h5 id="expand"><a href="#expand" class="headerlink" title="expand"></a>expand</h5><p> 就是在将 [tab] 按键转成空格键啦</p>
<h5 id="分割命令-split"><a href="#分割命令-split" class="headerlink" title="分割命令:split"></a>分割命令:split</h5><p>split可以将一个大文件，依据文件的大小或行数来分割成为小文件</p>
<p><strong>选线与参数：{　usage $: split [-bl] file PREFIX }</strong></p>
<ul>
<li>-b:接分割成的文件大小，单位为b,k,m</li>
<li>-l:以行数来进行分割</li>
<li>PREFIX:代表前导符，可作为分割文件的前导字</li>
</ul>
<p>我的test.txt文件共有729行，现在我以200行分割为一个文件<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@jack:/tmp# split -l 200 test.txt test</span><br><span class="line">root@jack:/tmp# ls -al test*</span><br><span class="line">-rw-r--r-- 1 root root  8721 4月  19 14:50 testaa</span><br><span class="line">-rw-r--r-- 1 root root  8663 4月  19 14:50 testab</span><br><span class="line">-rw-r--r-- 1 root root  9821 4月  19 14:50 testac</span><br><span class="line">-rw-r--r-- 1 root root  3958 4月  19 14:50 testad</span><br><span class="line">-rw-r--r-- 1 root root 31163 4月  19 14:43 test.txt</span><br></pre></td></tr></table></figure></p>
<p>将以上４个文件合成为一个文件，命名为newtest<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@jack:/tmp# cat test* &gt;&gt; newtest</span><br><span class="line">#使用cat然后数据流重定向，ｏｋ！</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="参数代换-xargs"><a href="#参数代换-xargs" class="headerlink" title="参数代换:xargs"></a>参数代换:xargs</h4><p>xargs就是在产生某个命令的参数的意思！ xargs 可以读入 stdin 的数据，并且以空格符或断行字符作为分辨(因为是以空格为分隔符，当文件名或者其它名词内有空格时可能产生误判)，将 stdin 的数据分隔成为 arguments 。</p>
<p><strong>选项与参数:{ usage $: xargs [-0pen] command</strong></p>
<ul>
<li>-0:如果输入的 stdin 含有特殊字符，例如 `, \, 空格键等等字符时，这个 -0 参数 可以将他还原成一般字符</li>
<li>-e: EOF (end of file) 的意思</li>
<li>-p:在运行每个命令的 argument 时，都会询问使用者的意思</li>
<li>-n:后面接次数，每次 command 命令运行时，要使用几个参数的意思</li>
</ul>
<p>将 /etc/passwd 内的第一栏取出，仅取三行，使用 finger 这个命令将每个 账号内容秀出来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# cut -d&apos;:&apos; -f1 /etc/passwd | head -n 3|xargs finger </span><br><span class="line">Login: root           			Name: root</span><br><span class="line">Directory: /root                    	Shell: /bin/bash</span><br><span class="line">On since Tue Apr 19 14:30 (CST) on :0 from :0 (messages off)</span><br><span class="line">On since Tue Apr 19 14:40 (CST) on pts/0 from :0</span><br><span class="line">   7 seconds idle</span><br><span class="line">No mail.</span><br><span class="line">No Plan.</span><br></pre></td></tr></table></figure></p>
<p>同上，将所有的 /etc/passwd 内的账号都以 finger 查阅，但一次仅查阅五个账号，并且每次查询请求确认<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# cut -d&quot;:&quot; -f1 /etc/passwd | xargs -p -n 5 finger</span><br><span class="line">finger root daemon bin sys sync ?...y</span><br></pre></td></tr></table></figure></p>
<p>其实使用xargs的一个重要原因是:很多命令并不支持管道命令，但我们去可以通过xargs来提供该命令引用standard input之用.</p>
<p>找出/sbin目录下具有特殊权限的文件名，并使用ls -l列出详细属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# find /bin -perm +7000 | xargs ls -l</span><br><span class="line">-rwsr-xr-x 1 root root  30800 1月  22 01:38 /bin/fusermoun</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/04/10/TCPDUMP/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="onejustonee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="onejustone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/10/TCPDUMP/" itemprop="url">TCPDUMP初识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-10T11:48:52+08:00">
                2016-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/technology/" itemprop="url" rel="index">
                    <span itemprop="name">technology</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>TCPDUP已经默认安装在unix和linux系统的，但它是NO-GUI抓包分析工具的，所以tcpdump的一切操作都是基于字符界面的！</p>
<h3 id="0x00-tcpdump-抓包"><a href="#0x00-tcpdump-抓包" class="headerlink" title="0x00 tcpdump-抓包"></a>0x00 tcpdump-抓包</h3><p>.默认情况下tcpdum默认情况下只抓取数据包的68个字节，所以所抓取的信息是有限的，如果需要抓取更多的数据就需要添加tcpdump的参数</p>
<hr>
<h3 id="0x01-TCPDUMP的常用参数"><a href="#0x01-TCPDUMP的常用参数" class="headerlink" title="0x01 TCPDUMP的常用参数"></a>0x01 TCPDUMP的常用参数</h3><ul>
<li>选项与参数：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@$: tcpdump -i eth0 -s 0 -w file.pcap</span><br><span class="line">-i:指定哪个接口来进行抓包</span><br><span class="line">-s:指定抓取多少的数据，0代表无限即原始数据包有多大就抓取多杀！</span><br><span class="line">-w:将抓取到的数据包保存到指定文件里</span><br><span class="line">-r:查看抓取的数据包内容！</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="0x02-tcpdumpd的筛选器"><a href="#0x02-tcpdumpd的筛选器" class="headerlink" title="0x02 tcpdumpd的筛选器"></a>0x02 tcpdumpd的筛选器</h3><p>抓取特定端口下的某种协议的数据包:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ $ :tcpdump -i eth0 tcp port 22</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="tcpdump的显示筛选器"><a href="#tcpdump的显示筛选器" class="headerlink" title="tcpdump的显示筛选器"></a>tcpdump的显示筛选器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@ $: tcpdump -n -r http.cap | awk &apos;(print $3)&apos; | sort -u</span><br><span class="line">选项与参数:</span><br><span class="line">-n：不对IP地址进行域名解析，而是直接显示IP地址！</span><br><span class="line">打印出该文件的第三列的内容(即是显示出所有的ip地址  啦)</span><br><span class="line">最后剔除掉重复的内容！</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="对源-目标ip进行显示筛选"><a href="#对源-目标ip进行显示筛选" class="headerlink" title="对源,目标ip进行显示筛选:"></a>对源,目标ip进行显示筛选:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ $: tcpdump -n src(dst) host [IP] -r http.cap</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="根据端口号进行筛选"><a href="#根据端口号进行筛选" class="headerlink" title="根据端口号进行筛选"></a>根据端口号进行筛选</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ $: tcpdump -n [-X:会以16进制进行显示] udp port 53 -r http.cap</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="tcpdump的高级筛选"><a href="#tcpdump的高级筛选" class="headerlink" title="tcpdump的高级筛选"></a>tcpdump的高级筛选</h4><p>除了对ip，端口，协议的筛选之外，tcpdump还可以进行其他更为高级的筛选.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/04/10/二层发现/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="onejustonee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="onejustone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/10/二层发现/" itemprop="url">二层发现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-10T10:45:00+08:00">
                2016-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/technology/" itemprop="url" rel="index">
                    <span itemprop="name">technology</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="0x00-琐碎"><a href="#0x00-琐碎" class="headerlink" title="0x00 琐碎"></a>0x00 琐碎</h3><p>从上一章节，我们可以收集到大量的被动信息，但是因被动而收集的信息，并不与目标系统进行直接交互，所以很有可能所收集的并不是最新的信息，所以现在我们开始进行主动信息收集！</p>
<p>毫无疑问，主动信息收集，终极目标不过是为了获得目标大大量信息，比如高层管理账号密码，核心数据库，系统root权限，也因此我们不可避免的需要与目标主机进行直接接触而留下访问痕迹，为了避免留下痕迹，我们有必要使用受控的第三方电脑进行探测，并且做好被封杀的准备，或者我们可以使用噪音迷惑目标，淹没真实的探测流量。这些所有的主动信息收集过程我们称之为扫描！</p>
<p>过程是这样的，首先对目标进行IP层扫描，再对其进行端口扫描，然后是应用层的扫描，就是对其进行各种网络层面的扫描，根据发送不同探测返回的结果判断目标状态！</p>
<h3 id="0x01-第一阶段-发现"><a href="#0x01-第一阶段-发现" class="headerlink" title="0x01 第一阶段 发现"></a>0x01 第一阶段 发现</h3><hr>
<ul>
<li><p>一层发现 IP层<br>一层发现阶段的目的是为了识别网络里活着的主机，这些主机就会成为我们后续潜在的攻击目标，整理出一个IP地址列表！</p>
</li>
<li><p>二层发现 基于数据链路层<br>二层发现是基于数据链路层的，主要根据其arp协议，其有优点是扫描速度 ，探测出来的结果也非常可靠，缺点是不可路由，它只能发现本网段之内的主机，若是需要夸网段，进行下一跳的话是不可以的，因为路由器并不会转发arp协议包</p>
</li>
</ul>
<h3 id="0x02-基于二层发现的工具"><a href="#0x02-基于二层发现的工具" class="headerlink" title="0x02 基于二层发现的工具"></a>0x02 基于二层发现的工具</h3><hr>
<h4 id="arping-发现网卡所在网段的IP"><a href="#arping-发现网卡所在网段的IP" class="headerlink" title="arping 发现网卡所在网段的IP"></a>arping 发现网卡所在网段的IP</h4><hr>
<ul>
<li><p><strong>参数:airping ip -c &lt;数字&gt;</strong> 限定发送的探测包的数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# arping 192.168.0.109 -c 2</span><br><span class="line">ARPING 192.168.0.109</span><br><span class="line">Timeout</span><br><span class="line">Timeout</span><br><span class="line">--- 192.168.0.109 statistics ---</span><br><span class="line">2 packets transmitted, 0 packets received, 100% unanswered (0 extra)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>参数:arping ip -d </strong>其作用是发现重复的相应，即是发现不同的mac地址拥有同一个IP，就是说明这是一个arp地址欺骗了！<br>下面来尝试抓取本机网卡下的ip:</p>
</li>
<li><p>使用grep管道对信息进行过滤<br>首先抓取一个包，分析其特征信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# arping 192.168.0.110 -c 2 -d</span><br><span class="line">ARPING 192.168.0.110</span><br><span class="line">60 bytes from 20:6a:8a:02:bf:19 (192.168.0.110): index=0 time=6.563 msec</span><br><span class="line">60 bytes from 20:6a:8a:02:bf:19 (192.168.0.110): index=1 time=1.518 msec</span><br><span class="line">--- 192.168.0.110 statistics ---</span><br><span class="line">2 packets transmitted, 2 packets received,   0% unanswered (0 extra)</span><br><span class="line">rtt min/avg/max/std-dev = 1.518/4.040/6.563/2.522 ms</span><br></pre></td></tr></table></figure>
<p>如上可知得到的返回信息中还包含了统计信息，使用grep筛选出我们想要的”bytes from”字段:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# arping 192.168.0.110 -c 2 | grep &quot;bytes from&quot;</span><br><span class="line">60 bytes from 20:6a:8a:02:bf:19 (192.168.0.110): index=0 time=10.246 msec</span><br><span class="line">60 bytes from 20:6a:8a:02:bf:19 (192.168.0.110): index=1 time=5.159 msec</span><br></pre></td></tr></table></figure>
<p>在进一步筛选，只显示第五行IP字段信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# arping 192.168.0.110 -c 2 | grep &quot;bytes from&quot; | cut -d &quot; &quot;  -f 5</span><br><span class="line">&#123;cut -d &quot; &quot;忽略空格;-f 5意思是显示第五个字段的信息&#125;</span><br><span class="line">(192.168.0.110):</span><br><span class="line">(192.168.0.110):</span><br></pre></td></tr></table></figure>
<p>最后除去括号和冒号:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# arping 192.168.0.110 -c 2 | grep &quot;bytes from&quot; | cut -d &quot; &quot; -f 5 | cut -d &quot;(&quot; -f 2 | cut -d &quot;)&quot; -f 1</span><br><span class="line">192.168.0.110</span><br><span class="line">192.168.0.110</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>但是arping只能一个一个的取ping并不能进行大量同时的ping，所以这便需要脚本来完成了！<br>脚本代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#===============================================================================</span><br><span class="line">#</span><br><span class="line">#          FILE: arping1.sh</span><br><span class="line"># </span><br><span class="line">#         USAGE: ./arping1.sh </span><br><span class="line"># </span><br><span class="line">#   DESCRIPTION: 通过arping实现对整个网段或者网卡下连接的一个网络存活ip的扫描</span><br><span class="line"># </span><br><span class="line">#       OPTIONS: ---</span><br><span class="line">#  REQUIREMENTS: ---</span><br><span class="line">#          BUGS: ---</span><br><span class="line">#         NOTES: ---</span><br><span class="line">#        AUTHOR: onejustone</span><br><span class="line">#  ORGANIZATION: </span><br><span class="line">#       CREATED: 2016年04月29日 15:47</span><br><span class="line">#      REVISION:  ---</span><br><span class="line">#===============================================================================</span><br><span class="line">if [ &quot;$#&quot; -ne 1 ]; then</span><br><span class="line">#脚本携带的参数数量只能为１个参数</span><br><span class="line">    echo &quot;usage ../arping.sh [interface]&quot;</span><br><span class="line">    echo &quot;Example ../arping.sh etho&quot;</span><br><span class="line">    echo &quot;Example wil perfors an arp scanf of the local subnet to which eth0 is assigned&quot;</span><br><span class="line">fi</span><br><span class="line">interface=$1</span><br><span class="line">#获得第一参数</span><br><span class="line">prefix=$(ifconfig $interface | grep &apos;inet addr&apos;| cut -d&quot;:&quot; -f 2 | cut -d&apos; &apos; -f 1 | cut -d&quot;.&quot; -f 1-3)</span><br><span class="line">for addr in $(seq 1 254);do</span><br><span class="line">    arping -c 1 $prefix.$addr | grep &quot;bytes from&quot; | cut -d&quot; &quot; -f 5 | cut -d&quot;(&quot; -f 2 | cut -d&quot;)&quot; -f 1 &gt;&gt;addr.txt</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>运行脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~/scripts# sh arping1.sh  eth0 &amp;</span><br><span class="line">root@jack:~/scripts# cat addr.txt </span><br><span class="line">192.168.0.1</span><br><span class="line">192.168.0.101</span><br><span class="line">192.168.0.102</span><br><span class="line">192.168.0.103</span><br><span class="line">192.168.0.110</span><br><span class="line">192.168.0.113</span><br></pre></td></tr></table></figure>
<p>我们获得了６个相同局域网下活着的ＩＰ，但是多段时间以后我们如果要对这些ｉｐ重新进行检查是否依旧存活?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash - </span><br><span class="line">#===============================================================================</span><br><span class="line">#</span><br><span class="line">#          FILE: arping2.sh</span><br><span class="line"># </span><br><span class="line">#         USAGE: ./arping2.sh </span><br><span class="line"># </span><br><span class="line">#   DESCRIPTION: 定期对已收集到的ＩＰ进行存活检查</span><br><span class="line"># </span><br><span class="line">#       OPTIONS: ---</span><br><span class="line">#  REQUIREMENTS: ---</span><br><span class="line">#          BUGS: ---</span><br><span class="line">#         NOTES: ---</span><br><span class="line">#        AUTHOR: YOUR NAME (), </span><br><span class="line">#  ORGANIZATION: </span><br><span class="line">#       CREATED: 2016年04月29日 17:06</span><br><span class="line">#      REVISION:  ---</span><br><span class="line">#===============================================================================</span><br><span class="line">if [ &quot;$#&quot; -ne 1 ]; then</span><br><span class="line">    echo &quot;usage ../arping.sh [interface]&quot;</span><br><span class="line">    echo &quot;Example ../arping.sh etho&quot;</span><br><span class="line">    echo &quot;Example wil perfors an arp scanf of the local subnet to which eth0 is assigned&quot;</span><br><span class="line">fi</span><br><span class="line">file=$1</span><br><span class="line">for addr in $(cat $file); do</span><br><span class="line">	arping -c 1 $addr | grep &quot;bytes from&quot; | cut -d&quot; &quot; -f 5 | cut -d&quot;(&quot; -f 2 | cut -d&quot;)&quot; -f 1</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>运行脚本arping2.sh</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~/scripts# sh arping2.sh addr.txt</span><br><span class="line">192.168.0.1</span><br><span class="line">192.168.0.101</span><br><span class="line">192.168.0.102</span><br><span class="line">192.168.0.103</span><br><span class="line">192.168.0.110</span><br><span class="line">192.168.0.113</span><br><span class="line">[1]+  已完成               sh arping1.sh eth0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="nmap-神器"><a href="#nmap-神器" class="headerlink" title="nmap 神器"></a>nmap 神器</h4><hr>
<p>nmap是一个超级强大的工具，但是在这里我们不会细说，而只是基于nmap对于二层发现的作用，后面我们会单独介绍</p>
<ul>
<li><p><strong>参数:nmap -sn</strong></p>
<p> 不对端口进行扫描，只是二层发现，寻找存活IP</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~/scripts# nmap -sn 192.168.0.*</span><br><span class="line">Starting Nmap 7.01 ( https://nmap.org ) at 2016-04-29 17:35 CST</span><br><span class="line">Nmap scan report for 192.168.0.1</span><br><span class="line">Host is up (0.00069s latency).</span><br><span class="line">MAC Address: C8:3A:35:4E:4B:B0 (Tenda Technology)</span><br><span class="line">Nmap scan report for bogon (192.168.0.102)</span><br><span class="line">Host is up (0.52s latency).</span><br><span class="line">MAC Address: F8:A4:5F:14:74:FB (Xiaomi Communications)</span><br><span class="line">Nmap scan report for 192.168.0.103</span><br><span class="line">Host is up (0.52s latency).</span><br><span class="line">MAC Address: DC:6D:CD:D1:E4:FA (Guangdong Oppo Mobile Telecommunications)</span><br><span class="line">Nmap scan report for bogon (192.168.0.110)</span><br><span class="line">Host is up (0.00025s latency).</span><br><span class="line">MAC Address: 20:6A:8A:02:BF:19 (Wistron InfoComm Manufacturing(Kunshan)Co.)</span><br><span class="line">Nmap scan report for 192.168.0.113</span><br><span class="line">Host is up (0.00026s latency).</span><br><span class="line">MAC Address: 5C:F9:DD:6A:02:61 (Dell)</span><br><span class="line">Nmap scan report for 192.168.0.109</span><br><span class="line">Host is up.</span><br><span class="line">Nmap done: 256 IP addresses (6 hosts up) scanned in 2.71 seconds</span><br></pre></td></tr></table></figure>
<p>我可以发现nmap的扫描速度明显快于arping，执行时间为５秒，并且扫描出来的的信息比arping详细很多！</p>
<p> 同样nmap也可以从文件中获得ｉｐ地址段并对其进行扫描探测</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~/scripts# nmap -iL addr.txt -sn</span><br><span class="line">Nmap done: 7 IP addresses (7 hosts up) scanned in 0.43</span><br><span class="line">seconds</span><br></pre></td></tr></table></figure>
<p>运行时间缩短到了0.43秒！</p>
</li>
</ul>
<h4 id="Netdiscover"><a href="#Netdiscover" class="headerlink" title="Netdiscover"></a>Netdiscover</h4><hr>
<p>Netdiscover可用于主动发现和被动发现，同样它采用arp协议，通过向目标发送arp包是否响应来判断目标是否存活，当然主动探测很有可能会触发目标的反侦查系统(如果目标有的话)，所以Netdiscover也支持被动发送，Netdiscover对网卡启用混杂模式，收取非本网卡IP地址和非本网卡MAC地址的数据包，并且他的机制是基于广播的，Netdiscover会一直在网络中默默侦听着，等待截取目标发送的arp！这是一种被动的等待，所以比主动的探测或许响应稍慢！</p>
<ul>
<li><p><strong>主动探测</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@jack:/tmp# netdiscover -i eth0 -r 192.168.0.109/24</span><br><span class="line">#-i指定在哪个网卡上进行发现</span><br><span class="line">#-r指定网络地址段</span><br><span class="line"> Currently scanning: Finished!   |   Screen View: Unique Hosts                        </span><br><span class="line">                                                                                      </span><br><span class="line"> 1 Captured ARP Req/Rep packets, from 1 hosts.   Total size: 60                       </span><br><span class="line"> _____________________________________________________________________________ </span><br><span class="line">   IP            At MAC Address      Count  Len   MAC Vendor                   y scanni ----------------------------------------------------------------------------- dress    192.168.0.1     08:aa:45:6e:4b:10    01    060   Unknown vendor</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>被动扫描</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#-p将网卡配置为混杂模式，将会抓取非本网卡即整个网络物理空间中所广播的数据包</span><br><span class="line">root@jack:/# netdiscover -p</span><br><span class="line"> Currently scanning: (passive)   |   Screen View: Unique Hosts</span><br><span class="line">                                                                                      </span><br><span class="line"> 0 Captured ARP Req/Rep packets, from 0 hosts.   Total size: 0</span><br><span class="line"> _____________________________________________________________________________</span><br><span class="line">   IP            At MAC Address      Count  Len   MAC Vendor</span><br><span class="line"> -----------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="0x03-Python-Scapy"><a href="#0x03-Python-Scapy" class="headerlink" title="0x03 Python Scapy"></a>0x03 Python Scapy</h3><hr>
<p>Scapy是Python的一个库文件，可以在脚本里进行调用，主要是为Python处理一些网络的处理，可以抓包，以可以单独的创建一个数据包，进行发送，也可以对收集到数据包进行修改然后重放，向网络里注入流量，用Scapy学习网络协议也是不错的选择！</p>
<p>初次使用Scapy需要安装python-gnuplot的一组件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# apt-get install python-gnuplot</span><br></pre></td></tr></table></figure></p>
<p>进入Scapy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@jack:~# scapy </span><br><span class="line">WARNING: No route found for IPv6 destination :: (no default route?)</span><br><span class="line">Welcome to Scapy (2.2.0)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="0x04-Python-Scapy-脚本实现arp扫描"><a href="#0x04-Python-Scapy-脚本实现arp扫描" class="headerlink" title="0x04 Python Scapy 脚本实现arp扫描"></a>0x04 Python Scapy 脚本实现arp扫描</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">import logging</span><br><span class="line">&apos;&apos;&apos;导入日志&apos;&apos;&apos;</span><br><span class="line">import subprocess</span><br><span class="line">&apos;&apos;&apos;实现一些系统命令的调用&apos;&apos;&apos;</span><br><span class="line">logging.getLogger(&quot;scapy.routime&quot;).setLevel(logging.ERROR)</span><br><span class="line">from scapy.all import *</span><br><span class="line">&apos;&apos;&apos;导入scapy模块&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if len(sys.argv)!= 2:</span><br><span class="line">&apos;&apos;&apos;如果命令加脚本不等于2，这里不同于bash shell&apos;&apos;&apos;</span><br><span class="line">	print &quot;Usage .. /arp.display [interface]&quot;</span><br><span class="line">	print &quot;Usage .. /arp.display.py eth0&quot;</span><br><span class="line">	print &quot;Example will perfors an ARP scanf of the local subnet to which etho is assigned&quot;</span><br><span class="line">	sys.exit()</span><br><span class="line"></span><br><span class="line">interface = str(sys.argv[1])</span><br><span class="line">ip = subprocess.check_output(&quot;ifconfig &quot;+interface +&quot; | grep &apos;inet addr&apos;| cut -d&apos;:&apos; -f 2 | cut -d&apos; &apos; -f 1&quot;, shell=True).strip()</span><br><span class="line">prefix = ip.split(&apos;.&apos;)[0]+&apos;.&apos;+ip.split(&apos;.&apos;)[1]+&apos;.&apos;+ip.split(&apos;.&apos;)[2]+&apos;.&apos;</span><br><span class="line"></span><br><span class="line">for addr in range(0, 254):</span><br><span class="line">  answer = sr1(ARP(pdst=prefix+str(addr)),timeout=0.1,verbose=0)</span><br><span class="line">&apos;&apos;&apos;如果不添加timeout参数，那么scapy遇到不存在的p将会一直发包，</span><br><span class="line">直到有响应为止，所以我们为其添加timeout参数，</span><br><span class="line">超过1秒没响应将放弃，verbose=0表示不显示异常信息=1则会显示&apos;&apos;&apos;</span><br><span class="line">  if answer == None:</span><br><span class="line">    pass</span><br><span class="line">  else:</span><br><span class="line">    print prefix+str(addr)</span><br></pre></td></tr></table></figure>
<h3 id="0x05-何时用到二层发现"><a href="#0x05-何时用到二层发现" class="headerlink" title="0x05 何时用到二层发现"></a>0x05 何时用到二层发现</h3><hr>
<p>一般只有当渗透到内网以后才会使用基于二层的探测，一般服务器不会安装nmap，也可能没有arping，也有可能没有Netdiscover，也有可能运行不了Python的脚本，但是一般没有可能连以上一个可能都没有，这是不可能的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/30/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><span class="page-number current">31</span><a class="page-number" href="/page/32/">32</a><a class="page-number" href="/page/33/">33</a><a class="extend next" rel="next" href="/page/32/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">onejustonee</p>
              <p class="site-description motion-element" itemprop="description">onejustone's blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">329</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">103</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">onejustonee</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
