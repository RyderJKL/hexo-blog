---
title: 第二十一章-软件安装
date: 2016-04-10 22:22:52
tags: ['鸟哥的Linux读书笔记基础篇']
toc: true
categories: technology

---
### 0x00 软件的安装升级

---
#### 关于源代码，编译器与与可执行文件
Linux系统上真正认可的可执行文件其实只有二进制文件(binary program)。shell scripts只是利用了shell这一程序的功能进行一些判断，其实任是呼叫一些已经编译好的二进制程序来执行。可以使用file命令来判断是否为二进制文件。

关于编译与链接与gcc可以看另一篇文章:http://www.jianshu.com/p/96fa579665e9

---
#### 关于函数库
函数库分为动态和静态函数库，Linux的核心提供很多的核心相关函数库与外部参数，这些核心相关参数大多放在/usr/include，/usr/lib，/usr/lib64下。

---
#### 关于make与configure
make的主要作用是简化编译过程的指令。我们知道使用gcc进行单一程序编译时，但是无所谓，很简单，但若是一个大点的项目呢？gcc就吃不消了。

当使用make命令时，make会在当前目录下搜索Makefile这个文件，里面记录了源代码如何编译的详细信息。并且会自动判断源代码是否改动过了，而自动更新可执行文件。

其实每个软件都会有一个运行环境侦查程序，用来检测系统已经具备该安装该软件所需的环境或者相关依赖，即使通常所说的configure或者是config。然后我们运行config来呼叫make对源代码进行编译，生成可执行文件。 

也正因为如此，不同OS的核心，或者函数库的位置的不同，一旦编译过的软件是很难在其它的OS上运行，所以才需要重复编译源代码。


---
#### 关于Tarball
Tarball就是将软件的源代码先以tar打包，然后再压缩的包了。

---
### 0x01 关于程序的编译

假如有两个程序，主程序是:thanks
```
#include<stdio.h>
int main(void)
{
 printf("hello world!\n");
 thanks_2();
}
```

副程序是：thanks_2()
```
#include<stdio.h>
void thanks_s(void)
{
  printf("thanks you!!");
}
```
----
#### 将两个程序进行编译后链接
```
➜  c_programer gcc -c thanks.c thanks_2.c 
➜  c_programer ll thanks*                       
-rw-r--r-- 1 root root 1496 5月  29 09:23 thanks_2.o
-rw-r--r-- 1 root root 1560 5月  29 09:23 thanks.o
➜  c_programer gcc -o thanks thanks.o thanks_2.o
➜  c_programer ls thanks*
thanks  thanks_2.c  thanks_2.o  thanks.c  thanks.o
➜  c_programer file thanks
thanks: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, 
interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, not stripped
```
编译完成得到.o文件，然后进行链接最后得到可执行文件thanks。
由此我们可以知道目标文件.o的意义，因为有时候源代码文件不知一个，我们无法直接进行编译，这时便要先生成目标文件，然后在链接成为可执行文件。此外，当某个源文件更新后也不需要从新编译整个项目，而是只需要编译该个源文件，然后再链接就行。
---
### 0x02 make编译
pass

---
### 0x03 Tarball的管理

---
### 0x04 函数库管理

---
### 0x05 软件检验


