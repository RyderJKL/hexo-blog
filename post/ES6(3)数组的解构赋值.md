---
title: ES6(3)解构赋值
date: 2016-12-19
tags: ['ES6']
toc: true
categories: technology

---
### 0x00 数组的结构赋值
ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。

在 ES6 中可以这样给变量声明赋值

```
var [a, b, c] = [1, 2, 3]
```

解构的本质实际上是 **模式匹配** ,只要等号两边的模式相同，等号左边就会被赋予对应的值。


```
let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3
```

如果解构不成功，变量的值就等于undefined。

注意，当等号的右边不是数组时，结构将会报错

```
// 报错
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};
```

---
### 0x01 默认值
可以在结构的的同时制定默认值

```
[x, y = 'b'] = ['a', undefined];
// x = 'a',y = 'b'
```

ES6 内部严格使用全等运算符(`===`)来判断一个位置是否有值。所以，若一个数组元素不严格等于 `undefined`，默认不会生效。

```
var [x = 1] = [null];
// x = null
```

默认值可以引用解构赋值的其他变量，但该变量必须已经声明。

```
let [x = 1, y = x] = [1] // x= 1; y = 1
let [x = 1, y = x] = [1, 2] // x = 1; y = 2
let [x = y, y = 1] = [ ] // ReferenceError
```

如上，`x` 用到默认值 `y` 时，`y` 还没有声明，因此报错。


---
### 0x02 对象解构赋值
不同于数组元素是按次序排列的，对象的属性没有次序，所以变量必须与属性同名，才能取得正确的值。

```
var {bar, foo} = {foo:"aa", bar:"bb"}
```

其实，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。

```
var {foo:foo, bar:bar} = {foo:"aa", bar:"bb"}
// 真正被赋值的是后者，而不是前者。
```

我们称前者是匹配的模式，后者才是变量。而真正被赋值的是变量，而不是模式。

注意如下格式:

```
let foo;
({foo} = {foo:1})
```

`let` 命令下面一行的圆括号是必须的，否则会报错。因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句。

对象的循环结构

```
var obj = {
	p:[
		'hello',
		{
			y:'world',
		}
	]
}

var {p:[x,{y}]} = obj;
//x hello
//y world
```

注意，这时p是模式，不是变量，因此不会被赋值。

---
### 0x03 字符串解构赋值
对字符串进行结构时，字符串将会被转换为一个类似数组的对象。

```
const [a,b, c] = 'who'
a // 'w'
b // 'h'
c // 'o'
```

---
### 0x04 数组和布尔值解构
解构赋值的规则是，只要等号右边的值不是对象，就先将其转为对象。但是 `undefined` 和 `null` 无法转为对象，因此对它们进行解构赋值将会报错。

```
let {toString: s} = 123;
s === Number.prototype.toString // true

let {toString: s} = true;
s === Boolean.prototype.toString // true
```


---
### 0x05 函数参数解构
函数参数也可以解构:

```
[[1, 2], [3, 4]].map(([a, b]) => a + b);
// [3, 7]
```

解构的同时指定默认值:

```
function move({x = 0, y = 0} = {}){
// 对参数解构的同时指定默认值
    return [x, y];
}

move() // [0,0]
move({x:3, y:4} // [3, 8]
```

---
### 0x06 解构的用途

---
#### 交换变量的值

```
[x, y] = [y, x]
```

---
#### 获取函数返回的多个值
当函数有多返回值，并且放在数组或者对象中，那么使用解构获取这些类型的返回值真是再好不过了。

```
function example () {
    return {
        foo:1,
        bar:2
    }
}

var {foo, bar} = example()
```

---
#### 函数参数识别
解构赋值可将一组参数与变量名对应起来:

```
// 参数数无序的值
function f({x, y, z}) {...}
f({z:3, x:4, y:1})
```

---
#### 提取 JSON 数据

```
var jsonData = {
    'id':42,
    'status':'ok',
    'data': [3434,444]
}
let {id, status, data} = jsonData
console.log(id, status, data)
// 42 'ok' [ 3434, 444 ]
```

---
#### 函数参数默认值

```
jQuery.ajax = function (ur, {
    async = true,
    beforeSend = function () {},
    cache = true,
    complete = function () {},
    crossDomain = false,
    global = true,
    // more config
}){
    // do something
}
```

---
#### 变量 MAP
但凡具有 `Iterator` 接口的对象都可以使用 `for...of` 循环遍历,比如 `MAP` 对象，然后在通过解构赋值，可以很方便的获得键名和键值。

```
var map = new Map()
map.set('name', 'Jack')
map.set('home', 'china')
for(let [key, value] of map){
    console.log(key+': '+value)
}


for(let [key] of map){
    // 单独获得键名
}

for(let [, vlaue] of map){
    // 单独获得键值
}
```



---
#### 加载模块的指定方法

```
cosnt {SourceMapConsumer, SourceNode} = require('source-map')
```


