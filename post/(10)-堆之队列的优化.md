---
title: (10)-堆之队列优化
date: 2016-06-05 09:37:44
tags: ['算法入门']
toc: true
categories: technology

---
### 0x00 堆

堆是一种特殊的完全二叉树，只是在存储和构建这个完全二叉树的时候我们给这些数据进行了一个从小到大(所有父节点都比子节点要小，我们称为最小堆)或者(从大到小的排序，我们称为最大堆)，而已。

堆的特性方便于我们后续对完全二叉树中的数据进行查找。

### 0x01 最小堆

我们要先举个栗子:假如有n个数，我们已经将这个n个数按照最小堆的特性放在了一个完全二叉树中了，那么现在最小的数就在队顶了，假设存储这个堆的数组叫做h，那么最小数就是h[1],现在我们需要删除其中最小的数（堆顶那个数），并增加一个新数k，然后再求这n个数中最小的一个数。

显然加入新树以后，已经不符合最小堆的特性了，这时我便需要对其进行必要的调整，以让其符合最小堆的特性。

方法是向下调整。

---
### 0x02 最小堆的向下调整

基本思想:为符合最小堆的特性，父节点要小于它的左右子节点，需要将新加入的数依次与它的左右儿子进行比较，

向下调整的代码:

```
void siftdown(int i)//传入一个需要向下调整的节点编号，这里传入1
                           //，既从堆的顶点开始
{
	int t,flag=0;//flag用来标记是否需要继续向下调整
	//当i节点有儿子（最少存在左儿子），并且有向下调整的必要时，执行循环体
	while(i*2<=n && flag==0)
	{
		//首先判断i和左儿子的关系，并用t记录较小值的节点编号
		if(h[i]<h[i*2])
			t=i;
		else
			t=i*2;
		//如果还存在右儿子，则继续比较
		if(i*2+1<=n)
		{
			//若是右儿子的值更小，更新较小的节点编号
			if(h[t]<h[i*2+1])
				t=i*2+1
		}
		//若是发现最小的编号不是自己，则说明子节点中有比父节点更小的
		if(t!=i)
		{ 
			swap(t,i);//交换它们
			i=t;//更新i，便于接下来继续向下调整
		}
		else
			flag=1;//说明当前的父节点已
                                   //经比两个子节点都要小了，不再调整
	}
	
}
```

整个算法的时间复杂度是O（logN）。


---
### 0x03 最小堆的向上调整

那么，若是想直接在原有的堆上直接插入一个新的数呢？
只需要直接将新元素插入到末尾，再根据情况判断新元素是否需要上移，直到满足堆的特性为止。如果堆的大小为N（即有N个元素），那么插入一个新元素所需要的时间也是O(logN)。

向上调整的代码：

```
void siftup(int i)//传入一个需要向上调整的节点编号i
{
	int flag=0;//用来标记是否需要继续向上调整 
	if(i==1) return;//若是堆顶，则返回，不需要调整了
	//不在堆顶，并且当前节点i的值比父节点小的时候继续向上调整
	while(i!=1 && flag==0)
	{
		//判断是否比父节点小
		if(h[i]<h[i/2])
			swap(i,i/2);
		else
			flag=1;//表示当前节点的值比父节点的值要大，不需要调整了
		i=i/2；//更新i为它父节点的编号，便于下一此的向上调整

	}

}
```

----
### 0x04 最小堆的建立

把n个元素建立一个堆，首先我可以将这n个结点以自顶向下、从左到右的方式从1到n编码。这样就可以把这n个结点转换成为一棵完全二叉树。紧接着从最后一个非叶结点（结点编号为n/2）开始到根结点（结点编号为1），逐个扫描所有的结点，根据需要将当前结点向下调整，直到以当前结点为根结点的子树符合堆的特性。

注意完全二叉树有一个性质：最后一个非叶结点是第n/2个结点。

```
for(i=n/2;i>=1;i--)
    siftdown(i);
```

用这种方法来建立一个堆的时间复杂度是O(N)。

堆可以用在堆排序中，与快排的时间复杂度一样为O(NlogN)。
对于堆排序，我只需要先建立最小堆，然后每次删除顶部元素并将顶部元素输出或者放入一个新的数组中，直到堆为空为止，最后输出或者存发在数组中的数便已经是排好序的。

```
//删除最大元素
int deletemax()
{
    int i;
    t=h[1];//临时变量用于记录堆顶点的值
    h[1]=h[n];//将堆的最后一个顶点赋值到堆顶
    n--；//堆元素减1
    siftdown(1);向下调整
    return t；返回之前记录的堆顶点的最大值
}
```

### 0x05 堆的建立以及堆排序

```
```


