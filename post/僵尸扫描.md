---
title: 僵尸扫描
date: 2016-05-27 15:36
tags: ['kali渗透测试','主动信息收集']
toc: true
categories: technology

---
### 0x00 碎语
僵尸扫描的极度隐蔽绝决定了它的实施条件的苛刻，鱼与熊掌不可兼得，本就是宇宙法则。一个合格的僵尸机是实现僵尸扫描的关键因素，僵尸至少要保证在进行扫描阶段不会产生其它的IP包，即是不会与我们主机之外的任何机器进行第三层的IP通讯，至少在我们控制其进行扫描的阶段不可以，否则将直接导致我们扫描结果不可靠，白费时间。

何为合适的僵尸机:1)足够闲置;2）它的IPID必须是递增的，0和随机都不可以。然而现在大部分主流的OS的IPID都是随机产生的，但是早期的xp，比如xp200，xp2003都是递增的IPID。

---
### 0x01 僵尸扫描的过程
* 最开始扫描者主机对Zombie(僵尸机)发送SYN/ACK包，然后Zombie（假设此时系统产生的IPID为x）会回个主机一个RST，主机将会得到Zombie的IPID；
* 然后扫描主机向目标机器发送一个SYN包，有所不同的是，此时扫描主机会伪造一个伪装成Zombie的IP(即是x)向目标主机发送SYN包。

* 如果目标的端口开放，便会向Zombie返回一个SYN/ACK包，但是人家Zombie并没有发送任何的包啊，zombie会觉得莫名其妙，于是向目标主机发送一RST过去询问，此时Zombie的IPID将会增加1(x+1)。若果目标主机的端口并未开放，那么目标主机也会想Zombie发送一个RST包，但是Zombie收到RST包不会有任何反应，所以IPID不会改变(依旧是x)。

* 最后扫描者主机再向Zombie发送一个SYN/ACK，同样的Zombie会摸不着头脑，然后在懵懂中向扫描者主机发送一个RST包，此时Zombie的IPID将变成(x+2)。最后我们在zombies的迷惘中我们已经知道了我们想知道的。

---
### 0x02 渗透环境
__扫描主机 kali:__ {  ip:192.168.86.129 }

__zombie xp:__ { ip:192.168.86.132 }

__目标主机 metasploitable:__ { ip:192.168.86.130 }


---
### 0x03 Scapy实现方法
---
#### 构造Scapy扫描包
---
##### 分步构成
###### 构造request zombie包:
```
>>> i=IP() #构造ip包头
>>> t=TCP() #构造tcp包头
>>> rz=(i/t) #request_zombie，构造发送给僵尸机的数据包，将发送给xp
>>> rt=(i/t) #request_target,构造发送给目标主机的数据包，将发送给meta
>>>rz[IP].dst="192.168.86.132"//定义zombie的ip地址
>>>rz[TCP].dport=445 //定义发送到zombie的端口，务必确保这个端口是开启的端口，445端口是win中默认开启的
>>>rz[TCP].flags="SA"//定义向zombie发送的数据包是SYN/ACK包
>>>
```

###### 构造request target包:
```
>>>rt[IP].src="192.168.86.132"//定义rt包的源ip地址，直接伪造为xp的ip
>>>rt[IP].dst="192.168.86.130"//定义rt包的目的ip，就是目标ip了，meta
>>>rt[TCP].dport=25//定义rt包扫描的端口
>>>rt[TCP].flags="S"//定义发送的rt包为SYN包
```

然后将会发送两次rz包，一次rt包，最后在对结果进行分析。
```
>>>az1=sr1(rz) #向zombie发的第一个包az1
Begin emission:
Finished to send 1 packets.
*
Received 1 packets, got 1 answers, remaining 0 packets

>>>at=sr1(rt，timeout=1) #向目标机发包，由于我们不会收到回包，因为给zombie了，所以需要设置超时时间
Begin emission:
Finished to send 1 packets.
*
Received 1 packets, got 1 answers, remaining 0 packets

>>>az2=sr1(rz) #向zombie发送的第二个包az2
Begin emission:
Finished to send 1 packets.
*
Received 1 packets, got 1 answers, remaining 0 packets

```

分析az1与az2IPID:
```
>>> az1
<IP  version=4L ihl=5L tos=0x0 len=40 id=436 flags= frag=0L ttl=128 src=192.168.86.132 dst=192.168.86.129 options=[] 
>>> az2
<IP  version=4L ihl=5L tos=0x0 len=40 id=438 f proto=tcp chksum=0xac5 src=192.168.86.132 dst=192.168.86.129 
```
通过分析发现目标的25是开放的。

----
#### Python脚本实现僵尸扫描

```
#!/usr/bin/python
#-*-coding:utf-8-*-

import logging
logging.getLogger("scapy.runtime").setLevel(logging.ERROR)
from scapy.all import *

def ipid(zombie):#定义一个ipid函数，同时定义一个zombie变量。该函数的作用是探测一主机是否可以作为僵尸机
  reply1 = sr1(IP(dst=zombie)/TCP(flags="SA"), timeout=2,verbose=0)#向zombie发送一个syn/ack包
  send(IP(dst=zombie)/TCP(flags="SA"),verbose=0)#send()与sr1()方法的区别是:sr1发送出去一个包以后会在接收对方的一个回包，而send方法不会接收包
  reply2 = sr1(IP(dst=zombie)/TCP(flags="SA"),timeout=2,verbose=0)#紧接着在向僵尸机发送一个syn/ack包
  if reply2[IP].id == (reply1[IP].id+2):#根据发送的三个来判断僵尸机是否足够空闲,并且ipid序号是否为递增的。
    print("IPID secquence is incremental and target appears to be idle,ZOMBIE LOCATED")
    response = raw_input("Do you want to use this zombie to perform a scan?(Y or N):")
    if response == "Y": #是否使用该僵尸机执行扫描
      target = raw_input("Enter the IP address of the target system:") #输入要扫描的目标主机ip
      zombiescan(target, zombie)
  else:
    print("Either the IPID secquence is not incremental or the target if not idle. NOT A Good zombie")

def zombiescan(target, zombie):
  print("\nScanning target"+target+"with zombie"+zombie)
  print"\n-------Open Ports On Target-----\n"
  for port in range(1,100):#扫描目标1-100的端口
    try:
      start_val = sr1(IP(dst=zombie)/TCP(flags="SA",dport=port),timeout=2,verbose=0)
      send(IP(src=zombie,dst=target)/TCP(flags="S",dport=port),verbose=0)
      end_val = sr1(IP(dst=zombie)/TCP(flags="SA"),timeout=2,verbose=0)
      if end_val[IP].id == (start_val[IP].id+2):
        print(port)
    except:
      pass

#主函数内容
print"------Zombie Scan Suite------\n" #这是僵尸扫描套件程序
print"1.----Identity Zombie Host\n" #识别僵尸机
print"2.----Preform Zombie Scan\n"  #执行扫描过程
aws = raw_input("Select an Option (1 or 2):")
if aws == "1":
  zombie = raw_input("Enter IP address to test IPID sequence:")
  ipid(zombie)
else:
  if aws == "2":
    zombie = raw_input("Enter IP address for zombie System:\n")
    target = raw_input("Enter IP address for Scan Target:\n")
    zombiescan(target,zombie)
  ```

---
### 0x04 NMAP实现僵尸扫描
同样的，如果使用NMAP进行僵尸扫描，首先找到合适的僵尸机是最关键的。

除此以为，NMAP本身提供了大量用于僵尸扫描的脚本程序(大概400多种)，我们可以在NMAP中调用这些脚本程序来判断一个主机是否是一个合适的僵尸机。同样这些脚本所遵循也是根据对方IPIID是否递增来判断的。

---
#### NMAP扫描指定端口判断主机是否是合适的zombie

```
root@kali:~# nmap -p445 192.168.86.132 --script=ipidseq.nse

Starting Nmap 7.01 ( https://nmap.org ) at 2016-05-28 05:12 EDT
Nmap scan report for bogon (192.168.86.132)
Host is up (0.00033s latency).
PORT    STATE SERVICE
445/tcp open  microsoft-ds
MAC Address: 00:0C:29:10:88:B3 (VMware)

Host script results:
|_ipidseq: Incremental!

Nmap done: 1 IP address (1 host up) scanned in 0.49 seconds
```
可以看到该主机的ipid是递增的哦！
僵尸找到了，开始进行扫描。

---
#### NMAP 僵尸扫描

```
root@kali:~# nmap 192.168.86.130 -sI 192.168.1.132 -Pn -P 0-100

Starting Nmap 7.01 ( https://nmap.org ) at 2016-05-28 05:16 EDT
Idle scan using zombie 192.168.1.132 (192.168.1.132:80); Class: Incremental

root@kali:~# nmap 192.168.86.130 -sI 192.168.86.132 -Pn -P 0-100

Starting Nmap 7.01 ( https://nmap.org ) at 2016-05-28 05:16 EDT
Idle scan using zombie 192.168.86.132 (192.168.86.132:80); Class: Incremental
Nmap scan report for bogon (192.168.86.130)
Host is up (0.051s latency).
Not shown: 977 closed|filtered ports
PORT     STATE SERVICE
21/tcp   open  ftp
22/tcp   open  ssh
23/tcp   open  telnet
25/tcp   open  smtp
53/tcp   open  domain
80/tcp   open  http
111/tcp  open  rpcbind
139/tcp  open  netbios-ssn
445/tcp  open  microsoft-ds
512/tcp  open  exec
513/tcp  open  login
514/tcp  open  shell
1099/tcp open  rmiregistry
1524/tcp open  ingreslock
2049/tcp open  nfs
2121/tcp open  ccproxy-ftp
```


