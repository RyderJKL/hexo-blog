---
title: 漫话前端框架
date: 2017-06-01
tags: ['前端框架','框架思想']
toc: true
categories: technology

---
### 前言

距离上一次更博，已经过去两个月了，实习，工作，毕设，吧啦吧。今天听了尤雨溪大神在知乎
live 上的活动，收获良多。虽然最近都在捣鼓 Angular4
，但是框架这些东西在思想上是存在很多共性的，而这次的活动也让我对 React 和 Vue 有了更深入的了解，下面是自己对这次 live 的一点总结。live 本身涉及的方面是很多的，很多东西也不在我现阶段的学习范围之内。所以我只是提取现在阶段的我感兴趣或能消化的一些点，重点在数据的侦测机制，Redux 和 状态管理，Rxjs 和响应式编程。


### 一些小的点

1. 关于源码学习: 尤大推荐的一个关于[Vue源码学习](http://hcysun.me/2017/03/03/Vue源码学习/)的文章.

2. 关于是否采用 TS，未来会提供 TS 的官方模板，但是不会成为默认推荐的语言。

3. 关于框架:框架，语言，工具，没有绝对的好与不好，都需要区分场景，前端是一个产品形态差异很大的平台，不同的场景，需求，会有很大区别，其次开发者群体的多样化，处于学习背景，习惯，思维模式的差异，不同的开发者偏好不一样，区别是没有办法磨平的。所以各种框架的并存是必然的，也是有益的。

4. 如何选择框架？取决于使用中经验，对框架的理解程度。

### 组件
主流框架都以组件作为基本单位。从 web pages 到 web
app，网页复杂程度完全不在一个量级。SPA
应用可以抽象为组件树。整个应用是个大的函数，在React
中，一个组件可以是一个函数，这是最简单的组件形态。

当然 React 默认的组件形态还是 state 的，采用 class
的形式进行包装。

实际应用中的组件分

* 纯展示型组件：单纯的 UI 渲染，夹杂少量处理逻辑。
* 接入性组件：与数据层 service 打交道，continue 将数据向下传递。
* 交互性组件：对表单组件的加强和扩展，比如 element-ui，有复杂的逻辑，同时强调复用性。
* 功能性组件：高度抽象，一种逻辑型的东西，作为一种扩展,抽象的机制存在，比如
`<router-view>`,`<transition>`。

### 模板与jsx
jsx 的优点在于其灵活，具体体现在对功能型组件的扩展，但是模板在纯展示型和其它用例上也不差，模板更强制将少的逻辑放在视图中，展示型组件的逻辑可能并没有多么复杂，但是其样式会比较复杂。

### 组件与 collection
主流框架都将组件放在了一个 collection 中，Vue
的单文件或者Angular的元素在。不同于传统的应用，已语言进行切分，组件化以后已组件本身进行切分。


### 变化侦测和渲染机制

命令式（jquery）和声明式。使用 jQuery
很快会遇到维护性问题。** 声明式直接描述了数据与 DOM
之间的映射关系是怎样的，开发者不需要去手动的做这些操作**。

view = render(state)


### virtual dom

### 侦测机制

[巴黎演讲ppt](https://docs.google
.com/presentation/d/1_BlJxudppfKmAtfbNIcqNwzrC5vLrR_h1e09apcpdNY/edit?usp=sharing)


侦测机制主要分为 **push** 和 **pull**，React 和 Angular1.x
 Angular2 的脏检测机制都是 **pull** ,
 需要给系统一个信号，告诉它数据变了，在 React 里面即是 virtual dom，而在
 Angular
 中就是脏检测的流程，然后暴力遍历比对哪些数据发生了变化。能这样做的原因是现代的JS
 的运行速度很快，虽然存在内存浪费。而 push 呢? 比如说 vue 的响应式的数据或者
 rxjs 的 observable
 ，它们的数据机制使得数据在发生改变的时候立刻就能知道数据变了，push
 是一种相对更细粒度的的更新机制。
 pull
 是最粗粒度的更新，所以在大型应用需要去减少这种无用功，比如在 React 中使用 pure
 component ，suit component update
 这样的东西来从组件树中跳过某一部分的比对，而 push
 因为需要进行更细粒度的更新，粒度越细，那么每一个绑定都需要一个 observable 或者
 watcher，会增加内存和依赖追踪的开销。

 Vue2 选择是一个中等粒度的方案，在组件级别采用 push，在组件内部使用 virtual
  dom 进行比对，这是一个比较折中的方案。__ push 和 pull
  的本质区别在于，用侦测成本来换取一定程度的自动优化。__

  ### 状态管理
  flux 在经历过一段比较混乱的时期以后开始走向合流。

  状态管理的本质都是相同的，即是从源事件（source
  event）映射到状态的改变，然后再映射到 UI 的变化。

  声明式渲染已经解决了从状态到 UI
  的映射。所以，状态管理的这些库真正做的事情是如何管理将源事件映射到状态管理的这一过程，如何组织这一段代码，以提高维护性。

  Redux 与 MobX 是两种不同的范式(Paradigm)，Redux
  强调数据不可变，函数式的，immutable。而 Mobx 与 Vue
  里面，数据是可变的，响应式的。

  可变数据难以维护是指开发者需要自己手动去处理副作用操作的情况，比如手动观察这些数据，然后当数据改变以后应该怎么办，这会带来维护上的成本。若是可变数据所延伸出去的副作用全都是声明式的去写，比如将一个对象映射到一个模板，那么在 mutate 这个对象的时候，也并不复杂。


  其实 Redux 也好，Mobx 也好，他们都存在一个共性，有类似的地方，也有共同的痛点。
   即是如何处理异步。Redux 是将这个事情交给 middleware 去处理的，而
   Mobx 与 Vue 则是让用户 action 里 想怎么搞，怎么搞。但是 Redux
   middleware 的生态变得很混乱， redux-observabel,
   redux-thunk，redux-promise
   各种方案，这些方案之间各成一派，写出了的代码几乎完全不一样。但是反过来想想，杀鸡焉用牛刀？如果我们有一个完整的比较典型的 RESTful
   api，是不存在特别复杂的异步的，如果有比较复杂的事件源，比如，服务端推送，实时，或者是多个同时发布的请求，静态啊这些问题的时候，可以选择使用 rxjs 来专门做一层，来处理这些问题。

   当然用 rxjs
   就会很自然的想到另外一种思路了，即是直接跳过状态改变这个过程，直接从事件源映射到我们想要的结果，一切都使用 rxjs 的流来表示，这方面最具代表性的就是 Cycle.js。当是这又需要对 rxjs
    有充分的理解，要求很高。

    状态管理面临的另一个问题是，组件的局部状态和全局状态如何区分。最早需要全局状态是因为，我们发现有些数据在组件之间是共享的，我们把他们提升到一个全局状态以便进行统一的管理。但有些时候，又会发现，有的状态只会在组件中被使用，放入全局就会多此一举，全局与局部的区别并没有一个明显的界限。

    ### 构建工具
    构建工具解决的是几方面的问题：
    * 任务的自动化
    * 开发体验和效率（新的语言功能，语法糖，hot reload 等等）
    * 部署相关的需求
    * 编译时优化

    grunt，gulp 在很大程度上是 task
    runner，执行的是任务自动化的功能，但其实，大部分情况下，npm start
    就够用了，没必要用什么 grunt 和gulp。当然，require.js 和
    sea.js 也有一些构建方面的东西。但与现在的 brower.js,system.js,
    pollofiy.js，webpack，等一系列以模块为核心的构建的工具相比起来就差了很多。

关于部署： 部署的问题可以参考这篇文章:[部署](https://www.zhihu
.com/question/20790576)

rollrap 优秀的 js 打包工具。

