---
title: 层发现
date: 2016-05-9 21:45
tags: ['kali渗透测试','主动信息收集']
toc: true
categories: technology

---
### 0x00 碎语
IP以及ICMP协议(internet管理协议)属于三层协议，icmp的作用其实就是用来实现intenet管理的，进行路径的发现，网路通信情况，或者目标主机的状态，三层发现中主要使用icmp协议，arp协议属于二层协议，它是基于广播的，所以不可路由。而ICMP协议是可以路由的，理论上可以使用icmp协议发现全球的ip，如果么有边界防火墙(禁止icmp的探测包)进行过滤的话，对目标主机进行扫描，则会收到相应的响应，从而进行扑捉，除此以外，三层发现的扫描速度也较二层要慢些

----
### 0x01 三层发现工具
---
#### ping
ping使用icmp协议中两种类型的数据包，icmp
协议根据包头中的type字段定义了16中(0-15)种包类型，ping发送探测数据时使用的是第8号数据包，而接收数据(如果目标主机没有防火墙的回馈信息)时使用的是第0号数据包。

除此外，linux和windows使用ping命令时发送的ping包是有很大差异了。

使用ping命令对自身网关发送5个ping包
```
root@jack:~/scripts# ping 192.168.1.1 -c 5
PING 192.168.1.1 (192.168.1.1) 56(84) bytes of data.
64 bytes from 192.168.1.1: icmp_seq=1 ttl=251 time=5.38 ms
64 bytes from 192.168.1.1: icmp_seq=2 ttl=251 time=4.09 ms
64 bytes from 192.168.1.1: icmp_seq=3 ttl=251 time=3.56 ms
64 bytes from 192.168.1.1: icmp_seq=4 ttl=251 time=4.24 ms
64 bytes from 192.168.1.1: icmp_seq=5 ttl=251 time=18.8 ms
```

可以看到从本机追踪到sina.com一共经过了10次路由跳转，其中第六次时没有返回相关信息，说明该主机很有可能开启了边界防火墙过滤规则，自动过滤了icmp包的探测。

---
##### Bash脚本实现
ping命令结合bash脚本实现对IP段的扫描
```
#!/bin/bash
if [ "$#" -ne 1 ];then  
  echo "Usage - ./ping.sh [/24 network address]"
  echo "Usage - ./ping.sh 189.29.33.32"
  exit
fi
prefix=$(echo $1 | cut -d'.' -f 1-3)
for addr in $(seq 1 254);do
  ping -c 1 $prefix.$addr | grep "bytes from" | cut -d' ' -f 4 | cut -d':' -f 1 &
done
```

---
##### Scapy
先定义一个ip包头，在定义一个icmp包头，最后组合成一个ping包，然后发出去。

进入scapy
```
root@jack:~/scripts# scapy 
WARNING: No route found for IPv6 destination :: (no default route?)
Welcome to Scapy (2.2.0)
>>> i=IP() #先定义一个IP变量
>>> p=ICMP() #然后定义一个icmp变量
>>> ping=(i/p) #将ip包与icmp包组合成一个icmp的ping包
>>> ping.display()#显示ping包的包头结构
###[ IP ]###
  version= 4
  ihl= None
  tos= 0x0
  len= None
  id= 1
  flags= 
  frag= 0
  ttl= 64
  proto= icmp
  chksum= None
  src= 127.0.0.1
  dst= 127.0.0.1
  \options\
###[ ICMP ]###
     type= echo-request #已经被设置为8号包
     code= 0
     chksum= None
     id= 0x0
     seq= 0x0
>>> 
```
设置要ping的目标ip地址(dst)
```
>>> ping[IP].dst="192.168.1.1"
>>> ping.display()
###[ IP ]###
  version= 4
  ihl= None
  tos= 0x0
  len= None
  id= 1
  flags= 
  frag= 0
  ttl= 64
  proto= icmp #从这里可以知道ip的上层协议为icmp协议
  chksum= None
  src= 192.168.0.109 #scapy会自动侦听网卡Ip地址
  dst= 192.168.1.1
  \options\
###[ ICMP ]###
     type= echo-request
     code= 0
     chksum= None
     id= 0x0
     seq= 0x0
```
开始发包
```
>>> answer=sr1(ping)
Begin emission:
.Finished to send 1 packets.
.*
Received 3 packets, got 1 answers, remaining 0 packets
```
显示下回包的内容
```
>>> answer.display()
###[ IP ]###
  version= 4L
  ihl= 5L
  tos= 0x0
  len= 28
  id= 25387
  flags= 
  frag= 0L
  ttl= 128
  proto= icmp
  chksum= 0x558a
  src= 192.168.0.110
  dst= 192.168.0.109
  \options\
###[ ICMP ]###
     type= echo-reply #icmp的type=0的数据包
     code= 0
     chksum= 0xffff
     id= 0x0
     seq= 0x0
###[ Padding ]###
        load= '\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
```
以上过程也可以使用一条命令完成，以此实现我们在Python脚本中的调用
```
>>> sr1(IP(dst="192.168.0.101")/ICMP(),
Begin emission:
.Finished to send 1 packets.
.*
Received 3 packets, got 1 answers, remaining 0 packets
<IP  version=4L ihl=5L tos=0x0 len=28 id=32352 flags= frag=0L ttl=128 proto=icmp chksum=0x3a55 src=192.168.0.110 dst=192.168.0.109 options=[] |<ICMP  type=echo-reply code=0 chksum=0xffff id=0x0 seq=0x0 |<Padding  load='\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00' 
```
但是，如果使用scapy发送的ip地址不存在时，它会一直发包，直到对方响应为止，显然这是不想发生的，所以我们还需要使用timeout参数设定如果对方超过时间无回应则自动放弃！
```
>>> sr1(IP(dst="192.168.0.111")/ICMP(), timeout=1, verbose=0)
WARNING: Mac address to reach destination not found. Using broadcast.
```
---
##### Python脚本实现
 ```
#!/usr/bin/python

import logging
import subprocess
logging.getLogger("scapy.runtime").setLevel(logging.ERROR)
from scapy.all import *

if len(sys.argv)!= 2:
  print "Usage - ./ping1.py [/24 network address]"
  print "Example - ./ping1.py 128.38.28.3"
  sys.exit()

address = str(sys.argv[1])
prefix = address.split(".")[0]+'.'+address.split(".")[1]+'.'+address.split(".")[2]+"."

for addr in range(1, 254):
  a=sr1(IP(dst=prefix+str(addr))/ICMP(),timeout=0.1,verbose=0)
  if a == None:
    pass
  else:
    print(prefix+str(addr))
```
这里Python的脚本过于简单，并没有使用多线程取执行它，所有速度上可能略慢与bas脚本的执行速度~

下面调用能文件内存储的IP地址对可能存活的Ip地址进行检查
```
#!/usr/bin/python

import logging
import subprocess
logging.getLogger("scapy.runtime").setLevel(logging.ERROR)
from scapy.all import *

if len(sys.argv)!= 2:
  print "Usage - ./ping1.py [/24 network address]"
  print "Example - ./ping1.py 128.38.28.3"
  sys.exit()

filename = str(sys.argv[1])
file = open(filename, 'r')

for addr in file:
  a=sr1(IP(dst=addr.strip())/ICMP(), timeout=0.1, verbose=0)
  if a == None:
    pass
  else:
    print addr.strip()
运行:
root@jack:~/scripts/三层扫描# ./ping2.py pingaddr.txt 
```
---
#### traceroute 路由追踪
traceroute同样使用的是icmp协议，使用traceroute命令可以追踪到目标主机之间跳转了多少次路由

使用traceroute追踪到sina.com
```
root@jack:~# traceroute www.sina.com
traceroute to www.sina.com (218.30.108.192), 30 hops max, 60 byte packets
 1  bogon (192.168.0.1)  0.931 ms  0.932 ms  0.921 ms
 2  134.644.342.1  4.634 ms  5.127 ms  5.570 ms
 3   5.125 ms  5.513 ms  5.525 ms
 4   15.332 ms  15.726 ms  15.717 ms
 5   (202.97.38.45)  39.178 ms 202.97.80.145 (202.97.80.145)  36.039 ms  35.970 ms
 6  * * *
 7  1062.362 ms 220.181.0.50 (220.181.0.50)  1017.043 ms *
 8  180.149.128.46 (180.149.128.46)  39.002 ms * 180.149.128.146 (180.149.128.146)  41.218 ms
 9  180.149.129.214 (180.149.129.214)  38.029 ms  38.058 ms  38.046 ms
10  218.30.108.192 (218.30.108.192)  39.859 ms  37.563 ms  38.150 ms
```

---
#### fping命令

* __fping 1.2.2.2 -c 1__
* __fping -g 1.1.1.1 1.1.1.2__
* __fping -g 1.1.1.0/24__
* __fping -f iplist.txt__

---
#### hping

hping是一个很强大的命令，它能够发送几乎任意的TCP/IP包，除了可以一定程度上对ftp实现一个大量的压力测试(ddos)攻击，同时还可以实现第三层的扫描,但是每次只能扫描一个目标，但是这个不打紧！

hping实现三层icmp扫描
```
root@jack:~/scripts/三层扫描# hping3 192.168.0.1 --icmp -c 2
```
一行命令实现对整个ip网段的扫描
```
root@jack:~/scripts/三层扫描# for addr in $(seq 1 254); do hping3\
> 192.168.0.$addr --icmp -c 1 >> handle.txt & done
#将结果保存到handle.txt是因为hping与fping一样，显示的信息太过杂乱，
#先将其保存在文件中在进行分析
```
然后通过分析文本我们发现每个活着的IP都会有一个"len"字符,使用grep提取活着的ip
```
root@jack:~/scripts/三层扫描# cat handle.txt | grep ^len
len=46 ip=192.168.0.1 ttl=64 id=37158 icmp_seq=0 rtt=6.8 ms
len=46 ip=192.168.0.110 ttl=128 id=21635 icmp_seq=0 rtt=3.6 ms
len=46 ip=192.168.0.113 ttl=128 id=19190 icmp_seq=0 rtt=3.9 ms
len=46 ip=192.168.0.104 ttl=64 id=25196 icmp_seq=0 rtt=6.3 ms
```


