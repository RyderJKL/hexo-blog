---
title: 函数防抖和函数节流
date: 2016-06-22       
tags: ['JavaScript','JS高阶']
toc: true
categories: technology

---
### debounce vs throttle
`防抖（Debounce）` 和 `节流（throttle)` 两者都是用来控制某个函数在一定时间内执行多少次的技巧，两者相似而又不同。

“节流”是限制一个一直在执行的函数的最大执行次数。比如让一个本来要一直执行的函数以最多100毫秒执行一次的频率来执行。节流保证你的函数在一定频率下一直执行。

“去抖”则是等一段时间之后再去调用函数(并且函数此时没有被调用)。“去抖”可以让我们把一个连续的的函数调用”打包”成一个。函数去抖是一种空闲控制。

> requestAnimationFrame: 可以看做是`throttle`的替代品。当你的函数有很多的动画渲染或者有很多的元素操作时，你想保证动画的流畅性，就需要用到这个。注意：IE9不支持rAF.

`throttle` 方法在内部就是调用了带有 `maxWait` 参数的 `_.debounce` 来实现的，

** 两者的区别 **： 虽然在等待时间内函数都不会再执行，但 `throttle` 在第一次触发后开始计算等待时间，`debounce` 在最后一次触发之后才计算等待时间（最后一次在等待时间范围内）。

当然，这只是基本思想，之实际的应用中，我们还需要考虑一些其它的情况。




### 函数防抖


函数防抖其实就是函数在跪规定的时间间隔内被多次调用的话，那么函数不会被执行，直到调用的周期大于规定的时间，那么才开始执行函数，并且只执行一次。

函数防抖的基本模式可以简化如下:

> JavaScript高级程序设计中 `throttle` 其实是函数防抖的实现

```
function debounce(method, context){
	clearTimeout(method.tId)
	method.tId = setTimeout(function(){
		method.call(context)
	}, 500)
}
```

> 在 setTimeout() 中用到的函数其执行环境总是 window

`debounce` 方法调用实例:

```
function resizeDiv(){
	var div = document.querySelector("#block")
	div.style.height = div.offsetWidth + "px"
}

window.onresize = function(){
	debounce(resizeDiv)
}
```

如上，如果我们在 `500ms` 内连续改变窗口的大小，那么 `resizeDiv` 只会被执行一次，然后该函数永远不会被执行，知道最后停下来的时间超过 `500ms`。

当然这是个最基本的版本实现，它是存在很多问题的，先不说 `fn.timerId` 这种形式就不够爽，如果我们的 `fn` 需要就接受参数呢？或者`fn`是有返回值的？而且，就目前这个版本实现，函数永远是被延迟执行的，如果需要在函数函数被调用时立即执行呢？

那么，下面直接来看一个 `underscore` 中 `debounce` 的实现:

```
/*
  *空闲控制，返回函数连续调用时，空闲时间必须大于或者等于 wait，fn 才会被执行
  *
  * */

  function debounce(fn,wait,immediate) {
    let timer;
    let result;
    // 用于返回 fn 函数的执行结果

    let debounced = function(){
      let context = this;
      /*
      * 如果，需要在 fn 使用调用该函数的对象的话，会发现 fn 中的 this 是指向 window 的
      * 所以，需要找到 this 对象，并将该对象传递到 fn 函数中
      */
      let args = arguments;
      /*
      *  相应的需要将 args 传递到 fn 中，比如使用 dom.onmousemove = debounce(fn,wait) 时
      *  arguments 代表的就是 event 对象
      * */
			let immediate = immediate || true;
			// 默认情况下，立即执行
      if(timer) clearTimeout(timer);
      if(immediate) {
          // 如果传入 immediate 参数，表示立即执行
        let callNow = !timer;
        // 如果已经被执行过，则不会立即执行
        if (callNow) result = fn.apply(context,args);
        timer = setTimeout(function () {
          timer = null;
          // 使用 timer = null 去判断距离第一次执行是否已经过了 wait 时间
          // 注意 timer = null，与 clearTimeout(timer) 的区别
        },wait)
      }else {
          timer = setTimeout(function () {
              // 如果没有立即执行，那么由于 setTimeout 的原因 result 将永远是 undefined
            // 所以，我们只在 immediate 的时候返回 fn 函数执行的结果
             fn.apply(context,args);
          },wait)
      }
      return result;
    }

    debounced.canel = function () {
      cleatTimeout(timer);
      timer = null;
    }
    return debounced;
  }

```

调用实例:

```
var lazyLayout = debounce(calculateLayout, 300);
$(window).resize(lazyLayout);
// lazyLayout.cancle(); // 取消函数防抖
```


[soure](https://github.com/mqyqingfeng/Blog/issues/22)

---
### throttle

函数节流的实现方式有两种，时间戳和定时器。我们先看看时间戳。


```
function throttle(fn,wait) {
      let last=0;
      return function () {
        let now = +new Date();
        let context = this;
        let args  = arguments;
        if (last + wait < now) {
            fn.apply(context,args);
            last = now;
        }
      }
  }
```

再看使用定时器实现的版本:

```
function throttle(fn,wait) {
    let timeout ;
    return function () {
      let context = this;
      let args = arguments;
      if(!timeout) {
        timeout = setTimeout(function () {
          timeout = null;
          fn.apply(context,args);
        },wait)
      }
    }
}
```

 两者一比较，我们发现使用时间戳的版本，`fn` 会在被调用的时刻被立即执行，而使用定时器的版本则是在等待 `wait` 后才会执行。


 那么，如果我们将两者结合在一起呢，就是鼠标移入能立刻执行，停止触发的时候还能再执行一次！

 ```
function throttle(fn, await){
	let timeout = null;
	let result = null;
	let lastRun = 0;
	let throttled =  function(){
		let context = this;
		let args = arguments;
		let now = + new Date() || Date.now();
		const elapsed = now -lastRun - await;

		const runCallback = function(){
			timeout = null;
			lastRun = now;
			fn.apply(context,args);
		}

		if(elapsed >= 0){
			if(timeout){
				// 判断定时器是否存在，因为定时器的不准确性，很可能存在等待时间到期后，定时器并没执行的情况。
				clearTimeout(timeout);
				timeout = null;
			}
			lastRun =  now;
			fn.apply(context,args);

		}else if(!timeout){
			// 保证事件停止触发以后会再执行一次
			timeout = setTimeout(runCallback,await)
		}

	}

	throttled.cancle = function(){
		// 取消
		clearTimeout(timeout);
		timeout = null;
		lastRun = 0;
	}
	return throttled;
}
 ```

