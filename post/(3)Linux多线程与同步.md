---
title: (3)Linux多线程与同步
date: 2016-06-11 15:32
tags: ['Linux进程']
toc: true
categories: technology

---
### 0x00 多线程
我们已经知道了程序在内存中的表示。程序在整个运行过程中，只有一个控制权的存在，即激活函数(active)。此外，其它的函数都处于离场状态，并不运行。直到激活函数运行完成以后，控制权才会移交给下一个函数。各个函数就像连在一条线上一样，计算机也只会依次执行各个函数中定义的操作。这样的程序叫做__单线程程序__。

而__多线程__允许在一个进程空间中存在多个控制权，以便让多个函数同时处于激活状态，从而让多个函数的操作同时运行。

对于单cpu的计算机，可以通过不停的在不同线程的指令间切换，从而达到多线程同时运行的效果。


然而由于栈的限制，一个栈，只有最下方的帧可被读写。相应的，也只有该帧对应的那个函数被激活。为了实现多线程，必须绕开这种限制。为此，创建一个新的线程时，我们为这个线程建一个新的栈。每个栈对应一个线程。当某个栈执行到全部弹出时，对应线程完成任务。那么，多线程的进程在内存中便会有多个栈。

栈与栈之间以一定的空白区域隔开，以备栈的增长。每个线程可调用自己栈最下方的帧中的参数和变量，并与其它线程共享内存中的Text，heap和global data区域。

值得注意的是，对于多线程来说，由于同一个进程空间中存在多个栈，那么当任何一个空白区域被填满都会导致stack overflow。

---
### 0x01 并发
多线程相当于以__并发(concunrrency)__系统。并发系统一般同时执行多个任务。如果多个任务可以共享资源，特别是同时写入某个变量的时候，就需要解决同步的问题。

在并发情况下，指令执行的先后顺序由内核决定。同一个线程内部，指令按照先后顺序执行，但不同线程之间的指令很难说清除哪一个会先执行。如果运行的结果依赖于不同线程执行的先后的话，那么就会造成__竞争条件(race condition)__，在这样的状况下，计算机的结果很难预知。我们应该尽量避免竞争条件的形成。最常见的解决竞争条件的方法是将原先分离的两个指令构成不可分隔的一个__原子操作(atomic operation)__，而其它任务不能插入到原子操作中。


---
### 0x02 多线程同步
对于多线程程序，__同步(synchronization)__指在一定的时间内只允许某一个线程访问某个资源 。而在此时间内，不允许其它的线程访问该资源。我们可以通过__互斥锁(mutex)__\，__条件变量(condition variable)__\和__读写锁(reader-writer lock)__来同步资源。

---
#### 互斥锁
互斥锁是一个特殊的变量，一般被设置成全局变量，它有__锁上(lock)__\和__打开(unlock)__两个状态。打开的互斥锁可以由某个线程获得。一旦获得，这个互斥锁会锁上，此后只有该线程有权打开。其它想要获得互斥锁的线程，会等待直到互斥锁再次打开的时候。

所以线程在lock与unlock之间操作时，不会别其它的线程影响，由此便构成了一个原子操作。

---
#### 条件变量

条件变量是另一种常用的变量。它也常常被保存为全局变量，并和互斥锁合作。

条件变量特别适用于多个线程等待某个条件的发生。如果不使用条件变量，那么每个线程就需要不断尝试获得互斥锁并检查条件是否发生，这样大大浪费了系统的资源。


---
#### 读写锁

读写锁与互斥锁非常相似。RW lock有三种状态: __共享读取锁(shared-read)__\,__互斥写入锁(exclusive-write lock)__\, __打开(unlock)__。后两种状态与之前的互斥锁两种状态完全相同。

如果被一个线程获得R锁，RW lock可以被其它线程继续获得R锁，而不必等待该线程释放R锁。但是，如果此时有其它线程想要获得W锁，它必须等到所有持有共享读取锁的线程释放掉各自的R锁。

如果一个锁被一个线程获得W锁，那么其它线程，无论是想要获取R锁还是W锁，都必须等待该线程释放W锁。

这样，多个线程就可以同时读取共享资源。而具有危险性的写入操作则得到了互斥锁的保护。

