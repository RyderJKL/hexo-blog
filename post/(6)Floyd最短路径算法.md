---
title: (6)Floyd最短路径算法
date: 2016-05-27 10:38
tags: ['算法入门']
toc: true
categories: technology

---
### 0x00 前景

如何求两点之间最短路径？也许你会想到深度或广度优先搜索。进行n2遍的深度或广度优先搜索，对每两个点都进行一次深度或者广度优先搜索，便可以求得任意两点之间的最短路径。just like this？

案例分析:
如果有n个城市，这些城市间有m条路，彼此交错，彼此相连，而我们想知道A，B两个城市之间的最短路径？

假设有4个城市，可以使用二维数组来存储彼此之间的信息，如下4*4矩阵所示，2到1的距离为无穷(&)，1到2的距离为2，4到3的距离为12,另外约定一个城市自己到自己的距离是0。

|1|2|3|4
:--:|:---:|:---:|:--:|:---:|
1|0|2|6|4
2|&|0|3|&
3|7|&|0|1
4|5|&|12|0

先考虑只经过一个1号点开始中转，然后求两点间的最短距离。那么只需要判断e[i][1]+e[1][j]是否比e[i][j]小就可以了，经过1号点更新后的结果如下:

|1|2|3|4
:--:|:---:|:---:|:--:|:---:|
1|0|2|6|4
2|&|0|3|&
3|7|9|0|1
4|5|7|11|0

如此求在只允许经过1和2号的情况下求任意两点间的最短路程，以此类推。其实用一句话概况就是:__从i号顶点到j号顶点只经过k号点的最短路径__。这是一种__动态规划__的思想。

核心代码：
```
for(k=0;k<n;k++)
    for(i=0;i<n;i++)
        for(j=0;j<n;j++)
            if(e[i][j]>e[i][k]+e[k][j])
                e[i][j]=e[i][k]+e[k][j];
```  
### 0x01 代码实现
```
#include<stdio.h>

int main(){

	int e[10][10],m,n,k,i,j;
	int max=100000000;//存储一个我们认为是一个正无穷的数
	//读入n，m，n表示顶点个数，m表示边的条数
	scanf("%d %d",&n,&m);

	//初始化
	for(i=1;i<=n;i++)
		for(j=1;j<=n;j++)
			if(i==j)
				e[i][j]=0;
			else
				e[i][j]=max;

	//读入边
	int t1,t2,t3;
	for(i=1;i<=m;i++)
		{	
			scanf("%d %d %d",&t1,&t2,&t3);
			//表示从顶点t1到顶点t2的距离为t3
			e[t1][t2]=t3;
		}	
	
	//Floy算法核心代码
	for(k=1;k<=n;k++)
		for(i=1;i<=n;i++)
			for(j=1;j<=n;j++)
				if(e[i][j]>e[i][k]+e[k][j])
					e[i][j]=e[i][k]+e[k][j];
				
	//输出最后结果
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=n;j++)
		{
		 	printf("%10d",e[i][j]);
		
		}
		printf("\n");
	}

	return 0;
}
```

此系列均来源:http://blog.jobbole.com/100936/


