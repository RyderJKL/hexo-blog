---
title: 第十二章 正在表达与文件格式化处理
date: 2016-05-24 23:48:52
tags: ['鸟哥的Linux读书笔记基础篇']
toc: true
categories: technology

---
### 0x00 前言

正则表示法的字串表示方式依照不同的严谨度而分为基础正则表示法与延伸正则表示法。延伸型正则表示法除了简单的一组字串处理之外，还可以作群组的字串处理，例如进行搜寻 VBird 或 netman 或 lman 的搜寻，注意，是『或(or)』而不是『和(and)』的处理，此时就需要延伸正规表示法！

__正则表达式与通配符是完全不一样的东西，通配符(wildcard)代表的只是bash操作界面的一个功能，但正在表达式是一种字符处理的表示方式，两者要分清！__

此外，使用正则表达式时需要注意当前环境中的语言设置，因为每种语言的编码环境的不同，使用正则表示所得出的结果也会不同的！

为了避免编码产生的问题，有些特殊字符需要我们了解下：

特殊符号|代表意义
:---:|:---
[:alnum:]|代表英文大小写字节及数字，亦即 0-9, A-Z, a-z
[:alpha:]|代表任何英文大小写字节，亦即 A-Z, a-z
[:upper:]|代表大写字节，亦即 A-Z
[:lower:]|代表小写字节，亦即 a-z
[:digit:]|代表数字而已，亦即 0-9

---
### 0x01 基础正则表达式

 既然正规表示法是处理字串的一种表示方式，那么对字节排序有影响的语系数据就会对正规表示法的结果有影响！ 此外，正规表示法也需要支持工具程序来辅助才行！所以，我们这里就先介绍一个最简单的字串撷取功能的工具程序，那就是 grep 罗了!

---
#### grep的进阶技能

__选项与参数:__

* __{ usage $: grep [-A] [-B] [--color=auto] '关键字' filename }__
 * -A:后面可加数字，为 after 的意思，除了列出该行外，后续的 n 行也列出来；
 * -B:后面可加数字，为 befer 的意思，除了列出该行外，前面的 n 行也列出来；
 * --color=auto 可将正确的那个撷取数据列出颜色

 dmesg列出核心产生的信息，通过grep来获取网卡(eth),并将获得的信息关键字加上颜色，且显示行号
```
root@jack:~# dmesg | grep -n 'eth'--color=auto
```
同上，在关键字所在行的前两行和后三行也显示出来
```
root@jack:~# dmesg | grep -n -A3 -B2 'eth' 
544-[    1.008020] mmc0: SDHCI controller on PCI [0000:02:00.0] using DMA
545-[    1.017700] alg: No test for crc32 (crc32-pclmul)
546:[    1.266674] e1000e 0000:00:19.0 eth0: registered PHC clock
547:[    1.266682] e1000e 0000:00:19.0 eth0: (PCI Express:2.5GT/s:Width x1) 3c:97:0e:80:50:72
548:[    1.266687] e1000e 0000:00:19.0 eth0: Intel(R) PRO/1000 Network Connection
549:[    1.266753] e1000e 0000:00:19.0 eth0: MAC: 10, PHY: 11, PBA No: 1000FF-0FF
550-[    1.266996] ehci-pci 0000:00:1a.0: EHCI Host Controller
551-[    1.267007] ehci-pci 0000:00:1a.0: new USB bus registered, assigned bus number 1
552-[    1.267021] ehci-pci 0000:00:1a.0: debug port 2
```

在 ~/.bashrc 内加上这行:__alias grep='grep --color=auto'__再以__source ~/.bashrc__来立即生效即可喔！这样每次运行 grep 他都会自动帮你加上颜色显示啦！_


---
#### 基础正则表达式练习

练习使用到的文本文件如下:
```
"Open Source" is a good mechanism to develop programs.
apple is my favorite food.
Football game is not use feet only.
this dress doesn't fit me.
However, this dress is about $ 3183 dollars.^M
GNU is free air not free beer.^M
Her hair is very beauty.^M
I can't finish the test.^M
Oh! The soup taste good.^M
motorcycle is cheap than car.
This window is clear.
the symbol '*' is represented as start.
Oh!     My god!
The gd software is a library for drafting programs.^M
You are the best is mean you are the no. 1.
The world <Happy> is the same with "glad".
I like dog.
google is the best tools for search keyword.
goooooogle yes!
go! go! Let's go.
# I am VBird
```
最后一行为空行

##### 练习一:搜索特定字符
从文件中取得the关键字
```
root@jack:~# grep -n 'the' ex11 
8:I can't finish the test.^M
12:the symbol '*' is represented as start.
15:You are the best is mean you are the no. 
```
反向选择，搜索不含the的行
```
root@jack:~# grep -vn 'the' ex11 
1:"Open Source" is a good mechanism to develop programs.
2:apple is my favorite food.
```
忽略大小写，搜索the关键字
```
root@jack:~# grep -in 'the' ex11 
8:I can't finish the test.^M
9:Oh! The soup taste good.^M
```

##### 练习二:使用[ ]来搜索集合字节
 搜寻 test 或 taste 这两个单字时，可以发现到，其实她们有共通的 't?st' 存在
```
root@jack:~# grep -n 't[ae]st' ex11 
```
搜索含有oo的字符但是却不要前面含有g
```
root@jack:~# grep -n '[^g]oo' ex11
```
搜索文件中的数字
```
root@jack:~# grep -n '[[:digit:]]' ex11 
5:However, this dress is about $ 3183 dollars.^M
15:You are the best is mean you are the no. 1.
或者:
root@jack:~# grep -n '[0-9]' ex11 
```

##### 练习三:行首^与行尾$字节
^ 符号，在字节集合符号(括号[])之内与之外是不同的！	在 [] 内代表『反向选择』，在 [] 之外则代表定位在行首的意义！

搜索行首是The的内容
```
root@jack:~# grep -n '^The' ex11 
```
下面找出行尾结束为小数点(.)的哪行
```
root@jack:~# grep -n '\\.$' ex11 
1:"Open Source" is a good mechanism to develop programs.
2:apple is my favorite food.
3:Football game is not use feet only.
4:this dress doesn't fit me.
```
需要注意的是由于小数点(.)具有特殊意义，所以需要加转义字符(\\)，但是注意到5-9行也是也小数点结尾的，但却没有打印处理，弄啥咧？这里就牵涉到 Windows 平台的软件对於断行字节的判断问题了！我们使用 cat -A 将第五行拿出来看， 你会发现：
```
root@jack:~# cat -An ex11 | head -n 10 |tail -n 6
     5	However, this dress is about $ 3183 dollars.^M$
     6	GNU is free air not free beer.^M$
     7	Her hair is very beauty.^M$
     8	I can't finish the test.^M$
     9	Oh! The soup taste good.^M$
    10	motorcycle is cheap than car.$
```
上面的表格中我们可以发现 5~9 行为 Windows 的断行字节 (^M$) ，而正常的 Linux 应该仅有第 10 行显示的那样 ($) ，如此似乎更加理解了^与$的意义了有木有，下面直接找出空白行吧
```
root@jack:~# grep -n '^$' ex11 
22:
```
再来，假设你已经知道在一个程序脚本 (shell script) 或者是配置档当中，空白行与开头为 # 的那一行是注解，那么如何干掉它们直接提前数据？以/etc/sysctl.conf 文件为例:
```
root@jack:~# cat -n /etc/sysctl.conf 
 60	#
```
在未除去空白行和注解后共有60行
```
root@jack:~# grep -v '^$' /etc/sysctl.conf | grep -v '^#'
```

##### 练习四:任意一字节.与重复字节*
 在bash中，*代表着通配符的意思，但在正在表达式中却不是，至于小数点(.)则代表着__绝对有一个任意字节__的意思，它们的意义如下:
 * .(小数点):代表__一定有一个任意字节__
 * *(星号):代表__重复前一个字节， 0 到无穷多次__，为组合态
 
 找出关键字"g??d"，即是只有四个字节，并且开头是g，结尾为d的
```
root@jack:~# grep -n 'g..d' ex11 
```
强调 g 与 d 之间一定要存在两个字节，因此，第 13 行的 god 与第 14 行的 gd 就不会被列出来

 下面我们来看看星号\\*,\\*o的意思是__代表拥有空字节或者一个o以上的字符__,需要特别注意的就是它允许空字节的存在，因此__grep -n 'o*'  ex11__会将整个文件打印出来，所以当我们__需要至少两个o以上的字符串__时，需要使用__ooo*__
```
root@jack:~# grep -n 'ooo*' ex11 
2:apple is my favorite food.
```
 想要字串开头与结尾都是 g，但是两个 g 之间仅能存在至少一个 o 
```
root@jack:~# grep -n 'ooo*' ex11 
```
想要找出 g 开头与 g 结尾的字串，当中的字节可有可无
```
root@jack:~# grep -n 'g.*g' ex11 
```
现在就需要利用任意字节.了，__{ .* 就代表零个或多个任意字节 }__


#### 练习五:限定连续RE字符范围
以上我们使用.或者\\*可以得到0个或者无穷多个重复字节，现在我想找出2-5个连续的o字符串，那么此时就要使用到限定字符范围的符号{}了，但有因为{}的符号在shell中具有特殊意义，所以我们必须使用转义字符\\使其失去特殊意义

找出两个o的字符串
```
root@jack:~# grep -n 'o\\{2\\}' ex11 
1:"Open Source" is a good mechanism to develop programs.
2:apple is my favorite food.
```

找出 g 后面接 2 到 5 个 o ，然后再接一个 g 的字串
```
root@jack:~# grep -n 'go\\{2,5\\}g' ex11 
```
想要的是 2 个 o 以上的 goooo....g 呢？除了可以是 gooo*g ，也可以是：
```
root@jack:~# grep -n 'go\\{2,\\}' ex11 
```
需特别注意的是，正则表达式里的特殊字节与一般在命令行里使用的通配符并不相同，如，wilcard中的\\*表示__0到无穷多个字节__,而在正则表达式中\\*则是__重复0到无穷多个的前一个re字符__，使用的意义并不相同！

例如在命令行中__ls -l a*__代表以a开头所有文件，而在正在表达式中，要找到所有以a开头的文件则是:__ls | grep -n '^a.*' __

---
#### sed工具:行的新增/删除，替换/显示，搜索并替换，直接修改

__以行为单位的新增/删除功能__
将 /etc/passwd 的内容列出并且列印行号，同时，请将第 2~5 行删除！
```
root@jack:~# nl /etc/passwd | sed '2,5d'
     1	root:x:0:0:root:/root:/bin/bash
     6	games:x:5:60:games:/usr/games:/usr/sbin/nologin
     7	man:x:6:12:man:/var/cache/man:/usr
```
__sed 的动作为 '2,5d' ，那个 d 就是删除,sed 后面接的动作，请务必以 '' 两个单引号括住__

删除第 3 到最后一行，则是『 nl /etc/passwd | sed '3,$d' 』的啦，那个钱字号『 $ 』代表最后一行！
```
root@jack:~# nl /etc/passwd | sed '3,$d' 
     1	root:x:0:0:root:/root:/bin/bash
     2	daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
```
在第二行后(亦即是加在第三行)加上『drink tea?』字样！
```
root@jack:~# nl /etc/passwd | sed '2a,drink tea???'
     1	root:x:0:0:root:/root:/bin/bash
     2	daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
,drink tea?
```
如果是在第二行以前添加呢？那么就是把__"a"__改成__"i"__就是了

 添加一行so easy，如果我要添加两行呢?
```
root@jack:~# nl /etc/passwd | sed '2a,drink tea? or .....\\
> i want to drink milk!'
     1	root:x:0:0:root:/root:/bin/bash
     2	daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
,drink tea? or .....
i want to drink milk!
```
『我们可以新增不只一行喔！可以新增好几行』但是每一行之间都必须要以反斜线『 \\ 』来进行新行的添加喔!

* __以行为单位的替换与显示功能__

 将第2-5行的内容取代成为『No 2-5 number』
```
root@jack:~# nl /etc/passwd | sed '2,5c no 2-5 number'
     1	root:x:0:0:root:/root:/bin/bash
no 2-5 number
     6	games:x:5:60:games:/usr/games:/usr/sbin/nologin
....
```

 以前想要列出第 11~20 行， 得要透过『head -n 20 | tail -n 10』之类的方法来处理,有木有超级麻烦，现在可以使用sed了

 列出 /etc/passwd 文件内的第 5-7 行
```
root@jack:~# nl /etc/passwd | sed -n '5,7p'
```
至于为什么有n，你自己试试没有n的情况就懂了！

* __部分数据的搜索并取代功能__

 __{usage $: sed 's/被取代的字串/新的字串/g' }__

 下面一步一步，取出ifconfig里的ip字段，首先来查看下原始数据
```
root@jack:~# /sbin/ifconfig wlan0
wlan0     Link encap:Ethernet  HWaddr   
         inet addr:102.90.09.2  Bcast:102.23.0.15  Mask:255.255.255.240
          inet6 addr: ca80::a17:01fc:2ef4:d059/64 Scope:Link
(...)
```
使用grep截取关键字所在行数据
```
root@jack:~# /sbin/ifconfig wlan0 | grep 'inet addr'
          inet addr:102.90.09.2  Bcast:102.23.0.15  Mask:255.255.255.240
```
将ip前面的部分删除掉
```
root@jack:~# /sbin/ifconfig wlan0 | grep 'inet addr'\\
> | sed 's/^.*addr://g'
102.90.09.2  Bcast:102.23.0.15   Mask:255.255.255.240
```
将ip后面的部分删除掉
```
root@jack:~# /sbin/ifconfig wlan0 | grep 'inet addr'| sed 's/^.*addr://g'|
> sed 's/Bcast.*$//g'
102.90.09.2
```

 再来，假设我只要 MAN 存在的那几行数据， 但是含有 # 在内的注解我不想要，而且空白行我也不要
```
root@jack:~# cat /etc/manpath.config  | grep 'MAN'
# MANDATORY_MANPATH			manpath_element
# MANPATH_MAP		path_element	manpath_element
# MANDB_MAP		global_manpath	[relative_catpath]
# every automatically generated MANPATH includes these fields
#MANDATORY_MANPATH 			/usr/src/pvm3/man
MANDATORY_MANPATH			/usr/man
```
删除掉注释以后的数据，可以看到删除的部分留下了空行
```
root@jack:~# cat /etc/manpath.config  | grep 'MAN'|\\
> sed 's/^#.*$//g'
MANDATORY_MANPATH			/usr/man
```
现在删除空空
```
root@jack:~# cat /etc/manpath.config  | grep 'MAN'|sed 's/^#.*$//g'| sed '/^$/d'
MANDATORY_MANPATH			/usr/man
```

* __直接修改文件内容:危险动作__

 如果你有一个 100 万行的文件，你要在第 100 行加某些文字，此时使用 vim 可能会疯掉！因为文件太大了！那怎办？就利用 sed 啊~
```
root@jack:~# sed -i '$a #this a test' ex11 
```

 将ex11文件末尾的.替换为!
```
root@jack:~# sed -i 's/\\.$/\\!/g' ex11 
```





> #### 0x02 延伸正则表达式

之前有一个除去空白行和行首为#的行使用的是
```
root@jack:~# grep -v '^$' ex11 | grep -v '^#'
```
这样的话就需要使用两次的管道命令了，那么我们来简化一下啊
```
root@jack:~# egrep -v '^$|^#' ex11 
```
延伸型正规表示法可以透过群组功能『 | 』来进行一次搜寻, egrep 与 grep -E 是类似命令别名的关,其实所谓延伸正则表达式不过就是比基础正在表达式多了几个特殊符号而已了

RE字符|意义与范例
:---:|:---
+|意义:重复__一个或者一个以上__的前一个RE 字符 实例:搜索god,good,gooood等```root@jack:~# egrep -n 'go+d' ex11 ```
?|意义:__空的或一个__的前一个RE字符 实例：搜索gd，god，o？代表__空的或一个o __```root@jack:~# egrep -n 'go+d' ex11 ```
`1（表示竖线或的意思，简书死活不显示竖线）`|意义:用__或(or)的方式__找出数个字符串 实例:搜寻 gd 或 good 这两个字串 ```root@jack:~# egrep -n 'gd 1 god 1 good 1 dog' ex11```
()|意义:找出__群组__字符串 实例:搜寻 (glad) 或 (good) 这两个字串，因为 g 与 d 是重复的，所以， 我就可以将 la 与 oo 放在( ) 当中，并以 1 来分隔开来 ```root@jack:~# egrep -n 'g(la 1 oo)d' ex11```
()+|多个__重复群组的判断__ ```实例:root@jack:~# echo 'AxyzxyzxyzC' 1 egrep -n 'A(xyz)+C' ``` 找开头是 A 结尾是 C ，中间有一个以上的 "xyz" 字串的意思


> #### 0x03 文件的格式化与相关处理

现在我们来对文件进行简单的整理，不需要以vim取进行整理，而是直接通过数据流重定向配合以下的print，awk等功能，就可以将信息以你想要的模样输出来


 > ###### 格式化打印输出 printf 

如果你学过c语言，那么这里的printf对你而言就很好理解了哈，格式及其用法与c并无太多差异，但是需要注意的是printf并不是管道命令！

...

> ###### awk好用的数据处理工具

....
> ###### 文件对比工具:diff,cmp,patch

....
> ###### 文件打印准备工具:pr

pass


