---
title: (7)Dijkstra最短路径算法
date: 2016-05-28 09:52
tags: ['算法入门']
toc: true
categories: technology

---
### 0x00 算法思维

我们已经知道，Floyd最短路径算法，可以很方便求得任意两点间的最短路径，这称为"多源路径算法"。而Dijksta是要求的是指定一点到所有点的最短路径，这称为"单源最短路径"。

我们依旧用二维数组来存储顶点与边之间的关系（其实这是一种__图的邻接矩阵存储法__）。

|1|2|3|4|5|6
:--:|:---:|:---:|:--:|:---:|:---:|:--:|:
1|0|1|12|&|&|&
2|&|0|9|3|&|&
3|&|&|0|&|5|&
4|&|&|4|0|13|15
5|&|&|&|&|0|4
6|&|&|&|&|&|0

有上边可知顶点1到2的距离为1，顶点2到顶点1的没有路。

我们在用一个一维数组dis来存放1号顶点到其余点的初始路程:

|1|2|3|4|5|6|
:|:
dis|0|1|12|&|&|&

此时dis数组中的值称为最短路的"估计值".

算法的基本思想是:每次找到里源点最近的那个顶点，然后以该顶点为中心进行松弛操作，最终得到源点到其余所有点的最短路径。

* 将所有顶点分为两部分，已知最短路径的顶点P和未知最短路径的顶点Q，并用book数组记录他们。book[i]为1代表这个顶点在集合P中。
* 设源点到自己的距离为0，即dis=0，并将所有不能直接到达的顶点的距离设为无穷。
* 在集合Q中选择离源点最近的顶点u(即dis(u)最小)加入到集合P中。并以u为起点对其所有能到达的每一条边进行松弛操作。(dis[v]>dis[u]+e[u][v] update;)
* 重复第三步，知道集合Q为空。最终dis数组的值就是源点到所有顶点的最短路径。

---
### 0x01 Dijkstra算法代码实例

```
#include<stdio.h>
int main(){
	int e[10][10],i,j,n,m,t1,t2,t3,u,v,min;
	int book[10];
	int inf=9999999;
	int dis[10];
	//输入顶点，边
	printf("请输入顶点和边数\n");
	scanf("%d %d",&n,&m);
	//初始化
	for(i=1;i<=n;i++)
	{	
		for(j=1;j<=n;j++)
		{
			if(i==j)
				e[i][j]==0;
			else
				e[i][j]=inf;
		}
	}
   //输入顶点之间的距离
   for(i=1;i<=m;i++)
  	{
		printf("请输入两个顶底之间的距离\n");
		scanf("%d %d %d",&t1,&t2,&t3);
		e[t1][t2]=t3;
	}

   for(i=1;i<=n;i++)
   {
		book[i]=0;	 
	}
	book[1]=1;

	for(i=2;i<=n;i++) dis[i]=e[1][i];

	//Dijkstr核心算法
	for(i=1;i<=n-1;i++)
	{ 
		min=inf;
		for(j=1;j<=n;j++)
		{ 
			if(dis[j]<min  && book[j]==0)
				{
					min=dis[j];
					u=j;
				}
		}	
                book[u]=1;//将该顶点加入到Q集合中
		for(v=1;v<=n;v++)//对该顶点进行松弛操作
		{ 
			if(e[u][v]<inf && dis[v]>dis[u]+e[u][v])
			dis[v]=dis[u]+e[u][v];
         	}
	}
	//输出结果
	for(i=1;i<=n;i++)
		printf("%d",dis[i]);
	return 0;
}
```

从上我们可以看出，这个算法的时间复杂度是O(N^2)找里源点最近的点时的时间复杂度是O(N)，以后可以使用堆对其进行优化，达到(logN)。

本文来源:http://blog.jobbole.com/101065/


