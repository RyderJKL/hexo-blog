---
title: (2)Linux进程空间
date: 2016-06-08 11:16
tags: ['Linux进程']
toc: true
categories: technology

---
### 0x00 关于进程空间

进程空间|描述
:---:|:--
Stack|存放局部变量
Unused Area|未使用区域
Heap|存放动态变量(dynaminc variable ,比如:malloc直接从内存中为dynamic variable开辟空间)
Global Data|存放全局变量
Text(instruction codes)|存储指令

__栈(stack)__\以__帧(stack frame)__为单位。当程序调用函数的时候，比如main函数中调用程序中的子函数，stack会向下增长一帧。帧中存储该子函数的参数和局部变量，以及该子函数的返回地址(return address)。此时，计算机将控制权从main()转移到子函数，子函数处于激活(active)状态。位于栈最下方的帧，和全局变量一起，构成了当前的环境(context)。激活函数可以从环境中调用需要的变量。当函数又进一步调用另一个函数的时候，一个新的帧会继续增加到栈的下方，控制权转移到新的函数中。当激活函数返回的时候，会从栈中弹出(pop，读取并从栈中删除)该帧，并根据帧中记录的返回地址，将控制权交给返回地址所指向的指令。

在C语言中，当程序中使用malloc的时候，__堆(heap)__会向上增长，其增长的部分就成为malloc从内存中分配的空间。malloc开辟的空间会一直存在，直到我们用free系统调用来释放，或者进程结束。一个经典的错误是__内存泄漏(memory leakage)__, 就是指我们没有释放不再使用的堆空间，导致堆不断增长，而内存可用空间不断减少。

栈和堆的大小则会随着进程的运行增大或者变小。当栈和堆增长到两者相遇时候，也就是内存中的未使用区域(unused area)完全消失的时候，再无可用内存。进程会出现__栈溢出(stack overflow)__的错误，导致进程终止。

---
### 0x01 进程附加信息

内核会为每个进程在内核自己的空间中分配一__变量(task_struct结构体)__以保存进程的附加信息,比如PID,PPID,PGID等，这些信息用于说明进程的身份，进程关系以及其它的统计信息。

内核可以通过查看自己空间中的各个进程的附加信息就能知道进程的概况，而不用进入到进程自身的空间。

---
### 0x02 fork && exec
当一个程序调用__fork__的时候，实际上就是将上面的内存空间，包括text, global data, heap和stack，又复制出来一个，构成一个新的进程，并在内核中为该进程创建新的附加信息 (比如新的PID，而PPID为原进程的PID)。此后，两个进程分别地继续运行下去。新的进程和原有进程有相同的运行状态,我们只能通过进程的附加信息来区分两者。

然后程序调用exec，进程清空自身内存空间的text, global data, heap和stack，并根据新的程序文件重建text, global data, heap和stack (此时heap和stack大小都为0)，并开始运行。


本文参考来源:http://www.cnblogs.com/vamei/archive/2012/10/09/2715388.html

