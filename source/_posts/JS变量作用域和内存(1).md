---
title: JS变量作用域和内存(1)  
date: 2016-01-17      
tags: ['JavaScript','JS变量作用域和内存']
toc: true
categories: technology

---

### 0x01 基本类型和引用类型

ECMAScript 中规定变量有两种类型:基本类型和引用类型。

在将一个值赋值给变量的时候，解析器必需确定这个值是基本类型值还是引用类型值。ES6 规定了 6 种基本数据类型: `Undefined`, `Null`, `String`, `Number`,`Boolean`, `Symbol`。这 6 中基本数据类型是按值访问的，可以直接操作变量中的实际值。

而引用类型是保存在内存中的对象，当对引用类型进行复制的时候，实际上是在操作对象的引用。

比如，从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一新值，然后将该值复制到为新变量分配的位置上。

而从一个变量向另一个变量复制引用类型的值时，则是将对象的引用复制给变量。

---
#### 检测类型
可以使用 `typeof` 操作符来检测一个变量是不是基本数据类型。但如果变量中保存的值是对象或者 `null`， 则应该使用 `instanceof` 操作符。

```
var s = 'jack';
console.log(typeof s)
// string
```

```
var person = [1, 3, 4];
console.log( person instanceof Array);
// true
```

在检测一个引用类型值和 `Object` 构造函数时， `instanceof` 操作符会返回 `true`,而检测基本类型的值时，会返回 `false`。

其实，`typeof` 也好，`instanceof` 也罢，某些情况下，两者的检测结果都是不可靠的。

一个完美的解决方案是使用 `Object.prototype.toString()` 方法去检测一个变量的数据类型。 当然这不在本次讨论范围，请参考: 

> http://


---
### 0x01 执行环境及其作用域
Javascript 中的执行环境(excution context)定义了变量或函数有权访问哪些数据，并决定了它们各自的行为。每个执行环境有一个相关联的 **变量对象(variable object)**，环境中定义的所有变量和函数都保存在该对象中。

每个函数都有自己的执行环境，而当代码在环境中执行时会创建变量对象的一个 **作用域链(scope chain)**，作用域链保证了对执行环境有权访问的所有变量和函数的有序访问。

而作用域的链的前端，始终都是当前执行的代码所在环境的变量对象。如果该环境是函数，则将其 **活动对象（activation object)** 作为变量对象。作用域中的下一个变量对象来自包含环境（外部）环境，而再下一个变量对象则来自下一个包含环境，如此，一直延续到全局执行环境。

如此，内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。

虽说执行环境只有两种：全局和局部。但是以下两种情况会延长作用域链，它们可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。

* try-catch 语句中 catch 块；
* with 语句。

对于 `catch` 语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。而对 `with` 语句来说，会将指定的对象添加到作用域链中。

下面是 `with` 语句的一个例子:

```
function buildUrl(){
   var qs = "?debug=true";
   
   with(location){
       var url = href + qs;
   }
   
   return url;
}
```

如上，我们使用 `with` 语句将 `location` 对象添加到了 `buidUrl` 函数执行环境中变量对象的作用域链的前端。当在 `with` 语句中引用变量 `href` 时(实际引用的是 locaiton.href)，就可以在当前执行环境的变量对象中找到。





