---
title: (3)排序去重
date: 2016-05-25 12:50
tags: ['算法入门']
toc: true
categories: technology

---

### 0x00 案例分析

输入n个小于1000的数，去掉重复的数，然后按从大到小的顺序输出。当然我们有两种方法可以用:1)先去掉重复的数，然后在进行排序，最后输出。2）先进行排序，然后再输出的时候只显示重复的数中的一个。

#### 方法1

我们可以使用桶排序来完成

```
#include<stdio.h>

int main(){
	int a[1000],n,t;

	printf("请输入排序的数目n\n:");
	scanf("%d",&n);
	for(int i=0;i<1000;i++){
		a[i]=0;
	}//对数组进行初始化

	for(int i=0;i<n;i++){
		printf("请输入第一数%d:",i+1);
		scanf("%d",&t);
	 	a[t]=1;//对已经出现的数进行标记
   }										
    //打印输出
	for(int i=0;i<1000;i++){ 
		if(a[i]==1){	
		printf("%d\n",i);
	}
  }
}				
```    

这种方法的时间复杂度就是桶排序的时间复杂度，就是O(N+M)。

#### 方法2

先排序，再去重。排序可以使用冒泡或者快速排序。

```
#include<stdio.h>
int main(){
	int a[100],n,t,i,j;
	printf("请输入排序数目\n:");
	scanf("%d",&n);
	for(i=0;i<n;i++){
		printf("请输入第%d个数",i+1);
		scanf("%d",&a[i]);
	}
	//开始冒泡排序
	for(i=0;i<n-1;i++)
	for(j=0;j<n-i;j++){
		if(a[j]<a[j+1]){
			t=a[j];
			a[j]=a[j+1];
			a[j+1]=t;
		}		
	}

	printf("%d",a[0]);//输出第一个数
	for(i=1;i<n;i++){//从2循环到n
		if(a[i]!=a[i-1])
		{
			printf("%d",a[i]);//如果当前这个数是第一次出现则输出
		}
	}
	return 0;
 }
```

这种方式的时间复杂度有两部分组成，一个是冒泡的复杂度O(N^2),一个是输入和输出的时间复杂度(O(N*2)),但是后一个可以忽略不计。

### 0x01 小结

从以上的我们可以知道，桶排序是最快的，它的时间复杂度是O(N+M),但是它的开销也是最大的；冒泡排序的时间复杂度是O(N^2),时间很慢，但是稳定；快速排序是O(NlogN),比较快了，但是它不稳定，最差情况下依然是O(N^2)。


