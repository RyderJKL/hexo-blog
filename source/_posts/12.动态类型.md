# 动态类型

title: Python(12)-动态类型(dynamic typing)
date: 2016-05-02 22:38
tags: ['Python基础']
toc: true
categories: technology

---

## 0x00 mutable vs immutable

---

__对象是存储在内存中的实体__,但是我们并不能直接接触到该对象，在程序中所写的对象名，只是__指向这一对象的引用(reference)__

C中的变量比如，数字，字符串，表等等，在Python中都是对象。

__对象和引用分离，是动态类型的核心__,而引用可以随时指向一个新的对象。

```python
a = 3
a = 'at'
#开始，3是存储在内存中的一个对象，通过赋值，引用a指向对象3
#然后，引用a指向了内存中的另一个对象'at',是一个字符串，此时, 3不在有引用指向
```

__Python会自动销毁(destruct)没用引用指向的对象，从而释放相应内存！__

```python
a = 5
b = a
a = a+2
#通过前两个句子，我们让a，b指向同一个对象
#b = a的意思是让引用b指向引用a所指向的那一个对象
#但第三个句子实际上是对引用a重新赋值，让a指向一个新的对象7
```

此时，a，b指向不同的对象。可以看到，即使是多个引用指向同一个对象，如果一个引用值发生变化，那么实际上是让这个引用再指向一个新的引用，但并不影响其它引用的指向，即是各个引用相互独立，互不影响！

其它数据对象也是如此:

```python
l1 = [1, 2, 4]
l2 = l1
l1 = 4
```

但是以下则不一样:

```python
l1 = [1, 2, 3]
l2 = l1
l2[2] = 99
print l1,l2
[1,2,99],[1,2,99]
```

l1,l2 同时发生了改变，为何?首先，我们使l2指向l1引用所指的对象，而对象是一个表，而表实际上是包含了多个引用的对象，l2[2] = 99这个操作并没有使l1，l2的指向发生变化，它们依然指向那个表，而是对l2[2]，也就是表对象的一一部分对象(元素)进行操作，所以，所有指向该对象(表中元素)的引用都受到影响！

(前一个列子的赋值操作都没有对对象自身发生作用，而是改变引用指向)

列表可以通过引用其元素，改变对象自身(in-place change)。这种对象类型，称为`可变数据对象(mutable object)`，词典也是这样的数据类型。
而像之前的数字和字符串，不能改变对象本身，只能改变引用的指向，称为`不可变数据对象(immutable object)`。
我们之前学的元组`tuple`，尽管可以调用引用元素，但不可以赋值，因此不能改变对象自身，所以也算是`immutable object`.

---

## 0x00 从动态类型看函数参数传递

函数的参数传递，本质上传递的是引用。

```python
def f(x):
      x = 100
      print x

a = 1
f(a)
print a

100
1
```
参数`x`是一个新的引用，指向a所指的对象，如果参数是不可变`immutable`的对象，那么`a`和`x`引用之间相互独立，对参数`x`的操作不会影响引用a。

如果传递的是可变`mutable`的对象，那么改变函数参数，有可能改变原对象，所有指向原对象的引用都会受到影响:

```python
def f(x):
        x[0] = 100
        print x
a = [1,2,4]
f(a)
print a
[100,2,4]
[100,2,4]
```

