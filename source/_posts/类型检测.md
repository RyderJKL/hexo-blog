---
title: 类型检测
date: 2017-06-12
tags: ['JavaScript','JS高阶']
toc: true
categories: technology


---

[typeof使用以及null和undefined的判断区分](https://segmentfault.com/a/1190000008485113)

[阮一峰的网络日志 ](http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html)

### 类型检测

#### 关于 typeof

1.`typeof` 是一个运算符而不是一个方法;

2.使用 `typeof` 操作符检测数据类型只会返回七个结果;

`string`,`number`,`undefined`,`function`,`object`,`Boolean`,`Symbol`,注意 `typeof` 可以检测 `function` 类型，但是当检测类型是 `null` 和 `Object` 时都是返回`object`。

3.使用 `typeof` 检测未实例化的对象(想对于检测原型的构造函数)返回`function`;

```
console.log(typeof  Object)
console.log(typeof Date)
console.log(typeof Error)
console.log(typeof Math)
// function
  ```

4.使用 `typeof` 检测 `new` 以后的实例，除了 `new Function` 返回 `function` 外，其它均返回 `object` ，包括自定义的函数

```
function test (){       }
var obj = new test();
console.log(obj.constructor);//function test(){}
console.log(obj);//test｛｝
console.log(typeof obj);//Object

var obj1 = new Array();
console.log(obj1.constructor);//function Array() { [native code] }
console.log(obj1);//[]
console.log(typeof obj1);//Object

var obj2 = new Function();
console.log(obj2.constructor);//function Function() { [native code] }
console.log(obj2);//function anonymous() {}
console.log(typeof obj2);//function
```

5.使用 `typeof` 检测 `BOM` 对象返回 `object`;

```
console.log(typeof window)
console.log(typeof navigator)
console.log(typeof screen)
console.log(typeof history)
console.log(typeof location)
```

#### 插播一个 null 和 undefined 的区别

1.`null` 是一个表示“无”的对象，转换为数字的时候值为0，其典型应用场景是:

* 用来初始化一个变量，该变量未来可能被赋值成一个对象
* 用来和一个已经初始化的对象进行比较，用来和一个已经初始化的对象进行比较，这个变量可以是一个对象，也可以不是一个对象
* 当函数的参数期望是对象时，被用作参数传入
* 当函数返回值期望是对象时，被当做返回值输出
* 删除事件绑定,事件本身是一个 null ,是一个空的对象，可以添加
* 作为对象原型链的终点

如何判断一个变量是 `null`:

```
var exp =  null;
if(typeof(exp) == 'object' && exp == null){
  // 因为 undefined == null 返回 true
  console.log("该变量为空")
}
```


2.`undefined`是一个表示“无”的原始值，转换为数值的时候为`0`.

* 变量被声明了，但是没有赋值，那么该变量的值就是undefined
* 调用一个函数的时候，如果应该提供的参数没有提供，那么该参数默认是undefined
* 如果一个对象的属性没有赋值，那么该属性值为undefined
* 函数没有返回值的时候，默认返回undefined;

如何判断一个变量是 `undefined`:

```
var exp = undefined;
if (typeof(exp) == 'undefined') {
  console.log("该变量是undefined")
}
```

### 关于 instanceof
我们先试着回忆片刻，我们知道，在 javascript 中对基本类型值的类型判断要用 `typeof` 操作符，对引用类型的判断要用 `instanceof` 操作符。其实，Javascript 内置的类型检测机制并不完全可靠，比如 `typeof` 操作符在应对正则表达式的时候就会返回 `function`，因此很难确定某个值到底是不是函数。而 `instanceof` 操作符，存在多个全局作用域(比如，一个页面中有多个框架)的问题。此外，由于 `JSON` 的存在，在检测某个对到底是原生对象还是开发人员自定义的对象时也有问题。



针对上述问题，都有一终极解决办法，就是 _在任何值上调用 `Object` 原生的 `toString()` 方法_，该方法会返回一个 `[object NativeConstructorName]` 格式的字符串。而每个类在内部都有一个 `[[Class]]` 属性，它指向上述字符串中的构造函数名。

利用这一点，可以创建以下函数:

```
// 检测数组类型
function isArray(value){
    return Object.prototype.toString(value) == "[ object Array]";
}

// 检测检测是否是原生函数
function isFunction(value){
    return Object.prototype.toString(value) == "[ object Function]";
}

// 检测正则表达式
function isRegExp(value){
    return Object.property.toString(value) == "[object RegExp]";
}
```

其实，还有很多类型检测，照这么写下去，代码冗余太多，所以，我们可以引入一个新的函数，而这个新的函数可以像工厂一样批量创建一些类似的函数:

```
var isType = function(type){
	var toString = Object.prototype.toString;
	return function(obj){
		return toString.call(obj) == '[object' + ' '+type + ']';
	};
};
```

如上，通过 `isType()`  函数，预先指定了参数 `type` 的， 这种通过指定部分参数来产生一个新的定制函数的形式就是 **函数柯里化**。

---
### 使用柯理化封装类型检测函数
如此，通过 `isType()` 函数来创建一个新的函数就要简单得多了

```
var isString = isType('String');
var isFunction = isType('Function');
var isArray = isType("Array")
var str = 'hello world'
console.log(isString(str))//true
```

