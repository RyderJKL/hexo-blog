---
title: 深入浅出Node.js(2)异步I/O
date: 2017-01-12 16:45
tags: ['Node.js','深入浅出Node.js学习笔记']
toc: true
categories: technology

---
### 0x00 前言
在众多的高级编程语言或运行平台中，将异步作为主要编程方式和设计理念的，Node 是首个。

而伴随异步 I/O 的还有事件驱动和单线程，它们构成 Node 的基调。

Node 创始人 Ryan Dahl 最初只是想要设计出一高性能的 Web 服务器，但后来却演变为了一个可以基于它构建各种高速，可伸缩网络应用的平台。 

Web 是一个网，而 Node 犹如其名字一般，是网络中灵活的一个节点。

---
### 0x01 为何要异步 I/O
异步 I/O 的期望是 I/O 的调用不再阻塞后续的运算，将原有的等待 I/O 完成的这段时间分配给其余的业务去执行。

可以说异步 I/O 是一种趋势，也是时代发展的必需，因为现代 Web 应用绝不是单凭一台服务器就可以完全胜任的，在跨网络的结构下，并发已是现代编程中的标配。

---
#### 用户体验
从用户体验而言，Javascript 是以单线程在浏览器中运行的，并且它还和 UI 渲染供用一个线程，这意味着在执行 javascript 代码的时候，UI 和响应是处于停滞状态的。 一旦对服务器发起资源请求，那么 javascript 必需要等到全部加载完成才能执行，而在这期间，UI 和 交互响应是处于阻塞状态的。但若采用异步请求，便可以在加载 javascript 代码的同时进行 UI渲染和响应用户交互。

---
#### 资源分配
我们所知道的是，单线程同步编程会因为阻塞 I/O 导致硬件资源得不到充分的使用。而多线程编程也因为编程中的死锁，状态同步等问题使得程序猿痛苦万分。

Node 在两者之间给出了它的方案： 

_利用单线程，远离多线程死锁，状态同步等问题；利用异步 I/O， 让单线程远离阻塞，以更好的使用 CPU 等硬件资源。_


而为了弥补单线程无法利用多核心 CPU 的缺点，Node 提供了类似前端浏览器中 Web Workers 的子进程，该子进程可以通过工作进程高效的利用 CPI 和 I/O。


---
### 0x02 OS 异步 I/O 与非阻塞 I/O
首先，对计算机内核而言,异步/同步和阻塞/非阻塞是两码事。

OS Kernel 对于 I/O 只有两种方式: 阻塞与非阻塞。在调用阻塞 I/O 时，应用程序需要等待 I/O 完成才能返回结果，这期间会包括磁盘寻道，读取数据，复制数据到内存整个 I/O 过程，在这期间会造成 CPU 等待，使得 CPU 性能得不到充分利用。为了提升性能，kernel 提供了非阻塞 I/O,非阻塞 I/O 在调用之后会立即返回，但返回的不是数据，而是状态。

非阻塞 I/O 返回之后，CPU 的时间片便可以用来处理其他事物，性能会得到明显提升，但由于完整的 I/O 并未完成，立即返回的并不是业务层期望的数据，而仅是当前调用的状态。而为了得到完成的数据，应用程序需要重复调用 I/O 操作来判断操作是否完成，我们把这种技术叫做 **轮询 (Cment)**。

任何技术都并非完美的。阻塞 I/O 造成 CPU 等待浪费，非阻塞需要轮询去确认是否完全完成数据获取，让 CPU 处理状态判断，是对 CPU 资源的浪费，同时对于应用程序而言，轮询技术仍然只能算是一种同步，因为 APP 仍然需要等待 I/O 完全返回，依旧会花费很多时间来等待，而等待期间，CPU 要么用于遍历文件描述符的状态，要么用于休眠等待事件的发生。

我们期望的完美的异步 I/O 应该是 APP 发起非阻塞调用，无序通过遍历或者事件唤醒等方式轮询，便可以直接处理下一个任务，只需在 I/O 完成以后通过信号或者回调将数据传递给 APP 即可。我们没必要将场景只限定在单线程状况下，_通过让部分线程进行阻塞 I/O 或者非阻塞 I/O 加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将 I/O 得到的数据进行传递，这就轻松实现了异步 I/O。_对于这个技术的具体实现，在 Windows 下的异步 I/O 方案是 IOCP，而 Node 的异步调用模型与此也十分相似。

但由于 Windows 平台与 linux 平台的差异，Node 提供了 libuv 库作为抽象封装层，使得所有平台的兼容性的判断都有这一层来完成。

---
### 0x03 Node 的异步 I/O
初步了解了 OS 对异步 I/O 的支持后，再来看看 Node 是如何实现异步 I/O
 的。对于 Node 完成整个异步 I/O 的环节将涉及 **事件循环**,**观察者**,和 **请求对象**，而它们一起和 **I/O线程池** 构成了 Node 异步 I/O 模型的基本要素。

对于事件循环，正是它使得回调函数十分普遍，在进程启动时， Node 便会创建一个类似于 while 的循环体，每执行一次循环体的过程我们称为 **Tick**。 Tick 是一个过程，整个过程就是查看是否有事件待处理。而如何判断是否有事件待处理，就是观察者的任务了。

事件循环是一个典型的生产者/消费者模型。异步 I/O，网络请求等是事件的生产者，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。一个事件循环中有一个或多个观察者。

比如，一个 Node 中的经典调用场景，使用 `fs.open()` 打开一个文件，首先 Javascript 会调用 Node 的核心模块，核心模块调用 C++ 内建模块，内建模块通过 libuv 进行系统调用，然后当前 I/O 操作在线程池中等待执行，不管其是否阻塞 I/O,都不会影响到 Javascript 线程的执行，因为此时的 I/O 操作已经和 Javascript 不在同一个线程里了，自然不会影响到后续 Javascript 的执行，如此，便到达了异步的目的。

> 在 Node 中，除了 Javascript 是单线程外，Node 本身是多线程的，而除了用户代码无法并行执行之外，所有的 I/O（磁盘 I/O ，网络 I/O）都是可以并行执行的。


在上述的整个过程中，**请求对象**  作为异步 I/O 的中间产物，所有的状态都会保存其中，包括送入线程池等待执行以及 I/O 操作完成以后的回调处理。


---
#### 执行回调
组装好请求对象，送入 I/O 线程池等待执行，其实只是完成了异步 I/O 的第一步，回调通知是其二。

在回调通知的过程中还动用了事件循环和 I/O 观察者。每次执行 Tick，它都会调用系统的相关方法去检查线程池中是否有执行完的请求，若存在，会将请求对象加入到 I/O 观察者的队列中，然后将其当作事件处理。如果，I/O 操作完成，则将线程归还线程池，至此，整个异步 I/O 的流程全部结束。

---
### 0x04 非 I/O 的异步 API

---
#### 定时器
`setTimeout()` 和 `setInterval()` 与浏览器中的 API 是一致的，分别用于单次和多次定时执行任务，其实现原理与异步 I/O 类似，只是不需要 I/O 线程池的参与。

---
### 0x05 事件驱动与高性能服务器
以下是几种经典的服务器模型:

* 同步式: 一次只能处理一个请求，并且其余请求都处于等待状态。 
* 每进程/每请求: 为每个请求启动一进程，如此，虽然可以处理多个请求，但是不具备扩展性，因为系统资源是有限的。
* 每线程/每请求: 为每个请求启动一个线程来处理(比如 Apache)。虽然比每进程/每请求的方式要好，但是对于大型站点而言依然不够。

而 Node 就高级得多了，它采用事件驱动的方式处理请求，即是 _通过主循环加事件触发的方式来运行程序_。 无需为每一个请求创建额外的对应线程，可以省掉创建线程和销毁线程的开销，同时因为 OS 在调度任务时因为线程较少，切换上下文代价很低。如此，服务器可以顺畅的处理大量请求，这是 Node 高性能的原因之一。

与之相似的是 Nginx，它同样采用事件驱动，因此与 Node 具有很多相同的特性，但因其采用 C 编写，所以性能更高，但它仅适合做 Web 服务器，用于反向代理和负载均衡等服务。

 










