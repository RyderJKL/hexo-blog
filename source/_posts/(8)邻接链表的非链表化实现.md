---
title: (8)邻接链表的非链接化实现
date: 2016-06-03 11:05:44
tags: ['算法入门']
toc: true
categories: technology

---
### 0x00 前言

Dijkstra使用了图的邻接矩阵存储法，它的时间和空间复杂度都是N^2，现在来看看另外一种图的存储方法:邻接表。邻接表可以使得时空复杂度都是M，对于稀疏图来讲，M要远远小于N^2。

测试数据如下:
```
4 5
1 4 9
4 3 8
1 2 5
2 4 6
1 3 7
```

当然邻接表的实现可以使用两种方法:1)是使用链表来实现；2)是使用非链表的实现方法。

这里使用第二种:
* 首先使用u，v，w三个数组来记录每条边的具体信息，即u[i],v[i],w[i]表示第i条边是从第u[i]号顶点到v[i]号顶点，且权值为w[i]。

* 再使用一个pre数组来__"存储每个顶点其中一条边的编号"__(其实pre数组最后存放的是每个顶点的第一条边(相对于最后的遍历读取时),也是最后读入的那条边(相对于输入数据时))。

* 最后使用一个next数组来__"存储编号为i边"__\的__"前一条边"__。

### 0x01 创建邻接表

创建邻接表的代码如下:

```
int n,m,i;
//u，v，w数组大小需根据实际情况设置，要比m最大值大1
int u[6],v[6],w[6]
//pre和next数组大小要根据实际情况设置，要比n最大值大1
int pre[5],next[5]
scanf("%d %d",&n,&m);
//初始化pre数组，表示1-n号顶点都没有边的
for(i=1;i<=n;i++) pre[i]=-1;
for(i=1;i<=m;i++)
{
  scanf("%d %d %d",&u[i],&v[i],&w[i]);//读入每一条边
  //数据插入的核心算法
  next[i]=pre[u[i]];
  pre[u[i]]=i;
}
```

遍历每个顶点的所有边

```
int k;
for(i=1;i<=n;i++)
{
  k=pre[i];
  while(k!=-1)
  {
      printf("%d %d %d",u[k],v[k],w[k]);
      k=next[k];
  }
}
```

邻接表来存储图的时空复杂度是O(M)，遍历每一个边的时间复杂度也是O(M)。当一个图是稀疏图时，M要远小于N^2。因此，稀疏图选用邻接链表来存储要比邻接矩阵好很多。

本文来源:http://blog.jobbole.com/101136/


