# 装饰器

---

tags: ['Python基础']
toc: true
categories: technology

## 0x00 装饰器

---

装饰器是Python中的一种高级语法，同时也是一个很著名的设计模式，装饰器可以对一个函数，方法或者类进行加工，其作用就是为已存在的对象添加额外的功能。

现在已经存在一个函数`test_func`:

```python
def test_func():
      print "i am test_func"
```

我们希望知道`foo()`运行需要消耗多少时间，或许你会这么修改函数

```python
import time

def  test_func():
      start = time.clock()
      print "i am test_func"
      end = time.clock()
      print "used", end - start
```

ok，你完全可以这么做，毕竟你实现了所提出的需求，不错，但是有没有想过，如果这个项目里这个函数有一万个，怎么办，copy*10000次？

No，我们只需对这个函数进行稍加”装饰“！

现在，来看看装饰器怎么做到的

```python
import time

#定义一个计时器，传入一个函数，并且返回另一附件了计时功能的函数
def timeit(func):
    #定义一内嵌的包装函数，给传入的函数加上计时功能
    def wrapper():
        start = time.clock()
        func()
        end = time.clock()
        print 'used:', end - start
    #将包装以后的函数返回
    return wrapper

#@timeit在定义上与test_func = timeit(test_func)完全等价，@并不具有魔法！
@timeit
def test_fun():
     print 'hi,i am test_func'

test_fun()
运行结果:
hi,i am test_func
used: 1.62500801813e-05
```

ok,最初的需求通过对`test_func`函数的"装饰(decorator)"实现了，在这个例子中，函数进入和退出时需要计时，这被称为一个横切面(Aspect)，这种编程方式被称为面向切面的编程(Aspect-Oriented Programming)。与传统编程习惯的从上往下执行方式相比较而言，像是在函数执行的流程中横向地插入了一段逻辑。在特定的业务领域里，能减少大量重复代码。

> 参考来源:http://www.cnblogs.com/huxi/
http://www.cnblogs.com/vamei/

## 0x01 带参数的装饰器

---

装饰器允许我们在调用`decorator`时提供其他参数，比如`@decorator(a)`,这样就又为程序的编写提供了更大的灵活性。

```python
import time

def pre_str(pre = ' '):
    def timeit(func):
        def wrapper():
            start = time.clock()
            func()
            end = time.clock()
            print (pre + "used:", end - start)
        return wrapper
    return timeit

@pre_str('"_"')
def test_fun():
     print 'hi,i am test_func'

test_fun()
运行结果:
hi,i am test_func
('"_"used:', 1.5394812803352647e-05)
```

其实我们也可以将其理解为一个含有环境变量的闭包，当我们使用`@pre_str('"_"')`调用时，Python能够发现这一层的封装，并把参数传递到装饰器的环境中！

大部分的用户都不怎么需要定义装饰器，但是有可能会使用装饰器。

