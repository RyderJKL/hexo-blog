---
title: 前端模块化(1)之各种规范  
date: 2017-02-23      
tags: ['JavaScript','前端模块化']
toc: true
categories: technology
 
---
### 0x00 What 模块化?
模块化是一种处理复杂系统分解为代码结构更合理，可维护性更高的可管理的模块的方式。

对于软件行业来说：解耦软件系统的复杂性，使得不管多么大的系统，也可以将管理，开发，维护变得“有理可循”。

随着前端惊人的发展速度，JavaScript 也出现了一些模块化的规范。比如有后端的 `CommonJS`，前端的 `AMD` 和 `CMD` 规范，还有融合了 `CommonJS` 和 `AMD` 规范的 `UMD` 规范，以及未来 `ES6 Modules` 中 即将一统天下的 JavaScript 模块标准规范。

---
### 0x01 CommonJS 和 AMD 
CommonJS 规定一个模块就是一个文件，
Node 在后台有 CommonJS 规范，为什么 JavaScript 还需要 AMD 规范?
原因在于环境，浏览器和服务器的环境不同，node 可以从本地硬盘中以同步的方式（`synchronous`）去加载各个模块，但是由于 Javascript 在浏览器中的单线程机制以及其资源的传输速度受网速的影响，意味着 CommonJS 的模块规范不适用于浏览器端，浏览器端的模块加载必需是
`异步(asynchronous)`的。

所以，AMD 规范就此诞生。

**AMD** 是 `Asynchronous Module Definition` 的缩写，它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。

##### Require.js
RequireJS 是一个前端的模块化管理的工具库，遵循 AMD 规范，它的作者就是 AMD 规范的创始人 James Burke。所以说RequireJS是对AMD规范的阐述一点也不为过。

关于 `Requre.js` 的具体用法，可参看博主的另外一篇文章。


---
### 0x02 CMD
`CMD` 是 `SeaJS` 在推广过程中对模块定义的规范化产出。同样属于浏览端的模块化规范，但是 `CMD` 推崇就近依赖，`AMD` 推崇前置依赖。

`AMD` 的 API 默认是一个当多个用，`CMD` 推崇职责单一。例如：`AMD` 里 `require` 分全局的和局部的。CMD里面没有全局的 `require`，提供 `seajs.use()` 来实现模块系统的加载启动。`CMD` 里每个 `API` 都简单纯粹。


---
### 0x03 UMD
`UMD` 是 `AMD` 和 `CommonJS` 的糅合。

`AMD` 模块以浏览器第一的原则发展，异步加载模块。
`CommonJS` 模块以服务器第一原则发展，选择同步加载，它的模块无需包装(`unwrapped modules`)。
这迫使人们又想出另一个更通用的模式 `UMD （Universal Module Definition）`。希望解决跨平台的解决方案。

`UMD` 先判断是否支持 `Node.js` 的模块（exports）是否存在，存在则使用 `Node.js` 模块模式。在判断是否支持 `AMD`（define是否存在），存在则使用 `AMD` 方式加载模块。


---
### 0X04 ES6 Modules 
ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 `CommonJS` 和 `AMD` 规范，成为浏览器和服务器通用的模块解决方案。

ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。`CommonJS` 和 `AMD` 模块，都只能在运行时确定这些东西。

