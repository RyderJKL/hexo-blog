---
title: (1)Linux进程基础
date: 2016-06-09 21:16
tags: ['Linux进程']
toc: true
categories: technology

---
### 0x01 程序与进程
程序(program)是由指令(instruction)构成，通过程序我们可以让计算机完成复杂的操作。

在Linux中，所有的进程都是通过对init进程的fork建立的。当计算机启动时，内核(kerner)只会建立一个init进程。新的进程主要通过老的进程复制自身得到，这就是for机制。

fork通常作为一个函数被调用。这个函数会有两个返回，将子进程的PID返回给父进程，0返回给子进程。

---
### 0x01 子进程的终结
当子进程终结时，它会通知父进程，清空自己所占据的内存，并在kernel里留下自己的退出信息(exit code，如果顺利运行，则返回0；如果有错误或异常状况，为>0的整数)。之后父进程对该子进程使用wait调用，wait能取出子进程的退出信息，并清空该信息在kernel中所占据的空间。

但是当父进程早于子进程终结时，子进程就会成为一个孤儿进程。此时子进程会过继给init进程。

不同于Unix，在Linux中，线程只是一种特殊的进程，多个线程之间可以共享内存空间和I/O接口。但进程是Linux程序的唯一实现方式。

---
### 0x02 Linux信号
出于进程的保护机制，进程之间是不会相互干扰的。但有时，进程之间的相互通信确是必要的。信号(singal)就是一种向进程传递信息的方式。不同于其它的进程间通信(interprocess communication，如:pipe,shared memory)，signal所能传递的信息比较粗糙，只是一个整数，但也因此而易于对signal进行管理。

signal通常用于系统管理相关的任务，比如通知进程终结，暂停或者恢复。

信号由内核管理，所以信号的传递是需要通过内核来完成的。内核对每一进程都有一个表存储相关的进程信息。当内核需要将信号传递给某个进程时，就在该进程相对应的表中的适当位置写入信号，这样，就生成(generate)了信号。进程执行系统调用，系统调用完成退出内核时便会查看该表。若有信号，则执行对应__该信号的操作__(signal action,也叫信号处理:signal disposition),此时叫做__执行(deliver)信号 __。从信号的生成到信号的传递时间，信号处于__等待状态(pending)__(未查看表)。我们可以设计程序，让其生成的进程__阻塞(block)__某些信号，即让这些信号始终处于pending状态，直到__取消阻塞(unblock)__或者无视信号。

---
### 0x03 Linux中的常见信号
Linux中常见的信号有SIGINT，SIGQUIT，SIGCONT，SIGTSTP，SIGALRM等。
* SIGINT: 当键盘按下CTRL+C从shell中发出信号，信号被传递给shell中前台运行的进程，对应该信号的默认操作是中断 (INTERRUPT) 该进程。
* SIGQUIT  当键盘按下CTRL+\从shell中发出信号，信号被传递给shell中前台运行的进程，对应该信号的默认操作是退出 (QUIT) 该进程。
* SIGTSTP  当键盘按下CTRL+Z从shell中发出信号，信号被传递给shell中前台运行的进程，对应该信号的默认操作是暂停 (STOP) 该进程。
* SIGCONT  用于通知暂停的进程继续。
* SIGALRM  起到定时器的作用，通常是程序在一定的时间之后才生成该信号。


---
### 0x03 信号处理(signal disposition)
进程决定执行信号时，有下面几种可能:
* 无视(ignore)信号，信号被清除，进程本身不采取任何特殊的操作
* 默认(default)操作。每个信号对应有一定的默认操作。比如上面SIGCONT用于继续进程。
* 自定义操作。也叫做获取 (catch) 信号。执行进程中预设的对应于该信号的操作。

进程会采取哪种操作，要根据该进程的程序设计。特别是获取信号的情况，程序往往会设置一些比较长而复杂的操作(通常将这些操作放到一个函数中)。

### 0x04 进程组与会话

---
#### 进程组
每个进程都会属于一个进程组，每个进程组都会包含多个进程。进程组都有一个进程领导进程组(process group leader),领导进程的PID成为进程组的ID(process group ID,PGID),以识别进程组。

```
$ ps -o pid,pgid,ppid,comm | cat
```

将进程归为进程组的一个原因是我们可以将信号发送个一个进程组。而进程组中的所有进程都会收到该信号。


---
#### 会话

多个进程组还可以构成一个会话(session),bash(Bourne-Again shell)支持工作控制(job control),而sh(Bourne shell)并不支持。

会话是由进程组中的进程建立的，该进程叫做会话的领导进程(session leader)。会话领导进程的PID成为识别会话的SID(session ID)。会话中的每一个进程组称为一个工作(jod),

会话可以有一个进程组成为会话的前台工作(foreground),而其它的进程组是后台工作(background)。每个会话可以连接一个终端(control terminal)。当控制终端有输入输出时，都传递给该会话的前台进程组。

会话的意义在于将多个工作囊括在一个终端，并取其中的一个工作作为前台，来直接接收该终端的输入输出以及终端信号。 其他工作在后台运行。

