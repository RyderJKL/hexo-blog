---
title: 二层发现
date: 2016-04-10 10:45
tags: ['kali渗透测试','主动信息收集']
toc: true
categories: technology

---
### 0x00 琐碎
从上一章节，我们可以收集到大量的被动信息，但是因被动而收集的信息，并不与目标系统进行直接交互，所以很有可能所收集的并不是最新的信息，所以现在我们开始进行主动信息收集！

毫无疑问，主动信息收集，终极目标不过是为了获得目标大大量信息，比如高层管理账号密码，核心数据库，系统root权限，也因此我们不可避免的需要与目标主机进行直接接触而留下访问痕迹，为了避免留下痕迹，我们有必要使用受控的第三方电脑进行探测，并且做好被封杀的准备，或者我们可以使用噪音迷惑目标，淹没真实的探测流量。这些所有的主动信息收集过程我们称之为扫描！

过程是这样的，首先对目标进行IP层扫描，再对其进行端口扫描，然后是应用层的扫描，就是对其进行各种网络层面的扫描，根据发送不同探测返回的结果判断目标状态！

### 0x01 第一阶段 发现

----

* 一层发现 IP层
一层发现阶段的目的是为了识别网络里活着的主机，这些主机就会成为我们后续潜在的攻击目标，整理出一个IP地址列表！

* 二层发现 基于数据链路层 
  二层发现是基于数据链路层的，主要根据其arp协议，其有优点是扫描速度 ，探测出来的结果也非常可靠，缺点是不可路由，它只能发现本网段之内的主机，若是需要夸网段，进行下一跳的话是不可以的，因为路由器并不会转发arp协议包


### 0x02 基于二层发现的工具

----

#### arping 发现网卡所在网段的IP

----

 * __参数:airping ip -c <数字>__ 限定发送的探测包的数量
```
root@jack:~# arping 192.168.0.109 -c 2
ARPING 192.168.0.109
Timeout
Timeout
--- 192.168.0.109 statistics ---
2 packets transmitted, 0 packets received, 100% unanswered (0 extra)
```
 * __参数:arping ip -d __其作用是发现重复的相应，即是发现不同的mac地址拥有同一个IP，就是说明这是一个arp地址欺骗了！
 下面来尝试抓取本机网卡下的ip:

 * 使用grep管道对信息进行过滤
首先抓取一个包，分析其特征信息
```
root@jack:~# arping 192.168.0.110 -c 2 -d
ARPING 192.168.0.110
60 bytes from 20:6a:8a:02:bf:19 (192.168.0.110): index=0 time=6.563 msec
60 bytes from 20:6a:8a:02:bf:19 (192.168.0.110): index=1 time=1.518 msec
--- 192.168.0.110 statistics ---
2 packets transmitted, 2 packets received,   0% unanswered (0 extra)
rtt min/avg/max/std-dev = 1.518/4.040/6.563/2.522 ms
```

  如上可知得到的返回信息中还包含了统计信息，使用grep筛选出我们想要的"bytes from"字段:
```
root@jack:~# arping 192.168.0.110 -c 2 | grep "bytes from"
60 bytes from 20:6a:8a:02:bf:19 (192.168.0.110): index=0 time=10.246 msec
60 bytes from 20:6a:8a:02:bf:19 (192.168.0.110): index=1 time=5.159 msec
```
  在进一步筛选，只显示第五行IP字段信息:
```
root@jack:~# arping 192.168.0.110 -c 2 | grep "bytes from" | cut -d " "  -f 5
{cut -d " "忽略空格;-f 5意思是显示第五个字段的信息}
(192.168.0.110):
(192.168.0.110):
```
  最后除去括号和冒号:
```
root@jack:~# arping 192.168.0.110 -c 2 | grep "bytes from" | cut -d " " -f 5 | cut -d "(" -f 2 | cut -d ")" -f 1
192.168.0.110
192.168.0.110
```

* 但是arping只能一个一个的取ping并不能进行大量同时的ping，所以这便需要脚本来完成了！
 脚本代码如下:
 ```
#!/bin/bash
#===============================================================================
#
#          FILE: arping1.sh
# 
#         USAGE: ./arping1.sh 
# 
#   DESCRIPTION: 通过arping实现对整个网段或者网卡下连接的一个网络存活ip的扫描
# 
#       OPTIONS: ---
#  REQUIREMENTS: ---
#          BUGS: ---
#         NOTES: ---
#        AUTHOR: onejustone
#  ORGANIZATION: 
#       CREATED: 2016年04月29日 15:47
#      REVISION:  ---
#===============================================================================
if [ "$#" -ne 1 ]; then
#脚本携带的参数数量只能为１个参数
    echo "usage ../arping.sh [interface]"
    echo "Example ../arping.sh etho"
    echo "Example wil perfors an arp scanf of the local subnet to which eth0 is assigned"
fi
interface=$1
#获得第一参数
prefix=$(ifconfig $interface | grep 'inet addr'| cut -d":" -f 2 | cut -d' ' -f 1 | cut -d"." -f 1-3)
for addr in $(seq 1 254);do
    arping -c 1 $prefix.$addr | grep "bytes from" | cut -d" " -f 5 | cut -d"(" -f 2 | cut -d")" -f 1 >>addr.txt
done
```
 运行脚本：
```
root@jack:~/scripts# sh arping1.sh  eth0 &
root@jack:~/scripts# cat addr.txt 
192.168.0.1
192.168.0.101
192.168.0.102
192.168.0.103
192.168.0.110
192.168.0.113
 ```
  我们获得了６个相同局域网下活着的ＩＰ，但是多段时间以后我们如果要对这些ｉｐ重新进行检查是否依旧存活?
```
#!/bin/bash - 
#===============================================================================
#
#          FILE: arping2.sh
# 
#         USAGE: ./arping2.sh 
# 
#   DESCRIPTION: 定期对已收集到的ＩＰ进行存活检查
# 
#       OPTIONS: ---
#  REQUIREMENTS: ---
#          BUGS: ---
#         NOTES: ---
#        AUTHOR: YOUR NAME (), 
#  ORGANIZATION: 
#       CREATED: 2016年04月29日 17:06
#      REVISION:  ---
#===============================================================================
if [ "$#" -ne 1 ]; then
    echo "usage ../arping.sh [interface]"
    echo "Example ../arping.sh etho"
    echo "Example wil perfors an arp scanf of the local subnet to which eth0 is assigned"
fi
file=$1
for addr in $(cat $file); do
	arping -c 1 $addr | grep "bytes from" | cut -d" " -f 5 | cut -d"(" -f 2 | cut -d")" -f 1
done
```
  运行脚本arping2.sh
```
root@jack:~/scripts# sh arping2.sh addr.txt
192.168.0.1
192.168.0.101
192.168.0.102
192.168.0.103
192.168.0.110
192.168.0.113
[1]+  已完成               sh arping1.sh eth0
```

#### nmap 神器

----
nmap是一个超级强大的工具，但是在这里我们不会细说，而只是基于nmap对于二层发现的作用，后面我们会单独介绍

* __参数:nmap -sn__
  
   不对端口进行扫描，只是二层发现，寻找存活IP
   ```
root@jack:~/scripts# nmap -sn 192.168.0.*
Starting Nmap 7.01 ( https://nmap.org ) at 2016-04-29 17:35 CST
Nmap scan report for 192.168.0.1
Host is up (0.00069s latency).
MAC Address: C8:3A:35:4E:4B:B0 (Tenda Technology)
Nmap scan report for bogon (192.168.0.102)
Host is up (0.52s latency).
MAC Address: F8:A4:5F:14:74:FB (Xiaomi Communications)
Nmap scan report for 192.168.0.103
Host is up (0.52s latency).
MAC Address: DC:6D:CD:D1:E4:FA (Guangdong Oppo Mobile Telecommunications)
Nmap scan report for bogon (192.168.0.110)
Host is up (0.00025s latency).
MAC Address: 20:6A:8A:02:BF:19 (Wistron InfoComm Manufacturing(Kunshan)Co.)
Nmap scan report for 192.168.0.113
Host is up (0.00026s latency).
MAC Address: 5C:F9:DD:6A:02:61 (Dell)
Nmap scan report for 192.168.0.109
Host is up.
Nmap done: 256 IP addresses (6 hosts up) scanned in 2.71 seconds
```
  我可以发现nmap的扫描速度明显快于arping，执行时间为５秒，并且扫描出来的的信息比arping详细很多！

   同样nmap也可以从文件中获得ｉｐ地址段并对其进行扫描探测
 ```
root@jack:~/scripts# nmap -iL addr.txt -sn
Nmap done: 7 IP addresses (7 hosts up) scanned in 0.43
seconds
   ```
  运行时间缩短到了0.43秒！

#### Netdiscover 

----

Netdiscover可用于主动发现和被动发现，同样它采用arp协议，通过向目标发送arp包是否响应来判断目标是否存活，当然主动探测很有可能会触发目标的反侦查系统(如果目标有的话)，所以Netdiscover也支持被动发送，Netdiscover对网卡启用混杂模式，收取非本网卡IP地址和非本网卡MAC地址的数据包，并且他的机制是基于广播的，Netdiscover会一直在网络中默默侦听着，等待截取目标发送的arp！这是一种被动的等待，所以比主动的探测或许响应稍慢！

* __主动探测__
```
root@jack:/tmp# netdiscover -i eth0 -r 192.168.0.109/24
#-i指定在哪个网卡上进行发现
#-r指定网络地址段
 Currently scanning: Finished!   |   Screen View: Unique Hosts                        
                                                                                      
 1 Captured ARP Req/Rep packets, from 1 hosts.   Total size: 60                       
 _____________________________________________________________________________ 
   IP            At MAC Address      Count  Len   MAC Vendor                   y scanni ----------------------------------------------------------------------------- dress    192.168.0.1     08:aa:45:6e:4b:10    01    060   Unknown vendor                       
```

* __被动扫描__
```
#-p将网卡配置为混杂模式，将会抓取非本网卡即整个网络物理空间中所广播的数据包
root@jack:/# netdiscover -p
 Currently scanning: (passive)   |   Screen View: Unique Hosts
                                                                                      
 0 Captured ARP Req/Rep packets, from 0 hosts.   Total size: 0
 _____________________________________________________________________________
   IP            At MAC Address      Count  Len   MAC Vendor
 ----------------------------------------------------------------------------- 
```

### 0x03 Python Scapy

----

Scapy是Python的一个库文件，可以在脚本里进行调用，主要是为Python处理一些网络的处理，可以抓包，以可以单独的创建一个数据包，进行发送，也可以对收集到数据包进行修改然后重放，向网络里注入流量，用Scapy学习网络协议也是不错的选择！

初次使用Scapy需要安装python-gnuplot的一组件:
```
root@jack:~# apt-get install python-gnuplot
```
进入Scapy
```
root@jack:~# scapy 
WARNING: No route found for IPv6 destination :: (no default route?)
Welcome to Scapy (2.2.0)
>>> 
```

### 0x04 Python Scapy 脚本实现arp扫描

----
```
#!/usr/bin/python
import logging
'''导入日志'''
import subprocess
'''实现一些系统命令的调用'''
logging.getLogger("scapy.routime").setLevel(logging.ERROR)
from scapy.all import *
'''导入scapy模块'''


if len(sys.argv)!= 2:
'''如果命令加脚本不等于2，这里不同于bash shell'''
	print "Usage .. /arp.display [interface]"
	print "Usage .. /arp.display.py eth0"
	print "Example will perfors an ARP scanf of the local subnet to which etho is assigned"
	sys.exit()

interface = str(sys.argv[1])
ip = subprocess.check_output("ifconfig "+interface +" | grep 'inet addr'| cut -d':' -f 2 | cut -d' ' -f 1", shell=True).strip()
prefix = ip.split('.')[0]+'.'+ip.split('.')[1]+'.'+ip.split('.')[2]+'.'

for addr in range(0, 254):
  answer = sr1(ARP(pdst=prefix+str(addr)),timeout=0.1,verbose=0)
'''如果不添加timeout参数，那么scapy遇到不存在的p将会一直发包，
直到有响应为止，所以我们为其添加timeout参数，
超过1秒没响应将放弃，verbose=0表示不显示异常信息=1则会显示'''
  if answer == None:
    pass
  else:
    print prefix+str(addr)
```

### 0x05 何时用到二层发现
---

一般只有当渗透到内网以后才会使用基于二层的探测，一般服务器不会安装nmap，也可能没有arping，也有可能没有Netdiscover，也有可能运行不了Python的脚本，但是一般没有可能连以上一个可能都没有，这是不可能的。


