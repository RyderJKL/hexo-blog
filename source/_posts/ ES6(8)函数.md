---
title: ES6(8)函数     
date: 2016-12-26  
tags: ['ES6']
toc: true
categories: technology

---
### 0x00 参数默认值
ES6 可以直接为函数的参数指定一个默认值：

```
function Poing ( x = 0, y = 5){
    this.x = x;
    this.y = y;
}
```

如此一来，使得得函数的书写更简洁，也便于阅读，更有利于将来的代码维护。

需要注意的是，_参数变量是默认声明的_ 所以不能再用 `let` 或者 `const` 再次声明。

---
### 0x01 参数默认值解构赋值


```
function Point( {x =1, y = 5}){
    this.x = x;
    this.y = y;
    console.log(x * y)
}

var p = new Point({x:200, y:40})
// 双重默认值，2000 和 40 将会覆盖原始默认值
// 8000

Point()
// TypeError

Ponit({})
// 5
```


如上，函数的参数是一个对象， 参数变量 `x` 和 `y` 通过解构赋值而生成。

当传递给函数的参数不是一个对象时，将会报错。


请注意以下写法:

```
function fetch(url, { body = '', method = 'GET', headers = {} } = {}) {
   alert(method)
}

fetch('https://www.sina.com/page/1')

```

`fetch` 函数的第二参数可以省略，因为已经在声明函数的同时结合结构对第二个参数进行了默认赋初值。


```
function fetch1(url, { body = '', method = 'GET', headers = {} }) {
   alert(method)
}
  
fetch('https://ww.sian.com/page/1',{})
```

`fetch1` 函数的第二参数是一个对象，在调用该函数时不可省略，其和第一个参数 `url` 的性质是一样的。

在看以下两种写法的差别:

```
// 写法一
function m1 ( { x = 0, y = 0} = {}){
    return [x, y]
}

// 写法二
function m2 ( {x, y} = {x:0, y:0}){
    return [x, y]
}

// 函数没有参数的情况
m1() // [0, 0]
m2() // [0, 0]

// x和y都无值的情况
m1({}) // [0, 0];
m2({}) // [undefined, undefined]
```

上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。

> 一旦函数有多个参数并指定了默认值，那么调用函数时，便不能省略非尾部的参数

---
#### 函数作用域小探

来看一个复杂点的例子:

```
var x = 1
function foo(x, y = function () { x = 2}){
    console.log(x)
    var x = 3
    y()
    console.log(x)
}

foo()
// undefined
// 3
```

如上，函数 `foo` 的参数 y 的默认值是一个匿名函数。函数`foo`调用时，它的参数 `x` 的值为 `undefined`，所以 y 函数内部的 x 一开始是 `undefined` ，后来被重新赋值 2。但是，函数 `foo` 内部重新声明了一个 `x`，值为3，这两个 `x` 是不一样的，互相不产生影响，因此最后输出 3。


---
### 0x02 rest 参数
ES6引入 `rest` 参数（形式为“...变量名”），用于获取函数的多余参数，这样就不需要使用 `arguments` 对象了。`rest` 参数中的变量代表一个数组。

```
function  add(...values) {
    let sum = 0;
    for( let val of values){
        sum += val
    }
    
    return sum
}

add(3,45,56,6)
```

#### 使用 rest 参数替代 arguments 

```
// arguments 对象写法
function sortNumbers() {
        return Array.prototype.slice.call(arguments).sort()
}

// rest 参数写法
const sortNumbers1 = (...numbers) => numbers.sort()
```


---
### 0x03 扩展运算符 ...

**扩展运算符**（spread）是三个点 (...)。我们将其看作 **rest** 参数的逆操作，该运算符将一个数组，变为参数序列。

```
function add(x, y) {
    return x + y
}

var numbers = [4, 38]
add(...numbers) //42
```

扩展运算符与正常的函数参数可以结合使用:

```
function f(u, v, w, x, y) {}
var args = [0, 1]
f(-1, ...args, 2, ...[3])
```

##### 替代数组 apply 方法

```
var arr1 = [0, 1, 2]
var arr2 = [3, 4, 5]

// ES5
Array.prototype.push.apply(arr1, arr2)

// ES6
arr1.push(...arr2)
```

`push` 方法的参数不能是数组，所以只好通过 `apply` 方法变通使用 `push`方法。有了 **扩展运算符**，就可以直接将数组传入 `push` 方法.

##### 合并数组

```
var arr1 = ['a', 'b'];
var arr2 = ['c'];
var arr3 = ['d', 'e'];

// ES5的合并数组
arr1.concat(arr2, arr3);
// [ 'a', 'b', 'c', 'd', 'e' ]

// ES6的合并数组
[...arr1, ...arr2, ...arr3]
// [ 'a', 'b', 'c', 'd', 'e' ]
```

##### 与解构赋值结合

```
const [first, ...rest] = [1, 2, 3, 4]
first // 1
rest  // [2, 3, 4]
```

#### 将字符串转换为数组

```
[...'Hello']
// ["h", "e", "l", "l", "o"]
```

##### 将 Iterator 接口的对象转换为数组

```
var nodeList = document.querySelector('div')
var array = [...nodeList]
```

如下，我们将一个 `nodeList` 对象转换为了一个数组。

但是，扩展运算符无法转换那些没有部署 `Iterator` 接口的类似数组的对象。在这种情况下，可以改为使用 `Array.from` 方法将 `arrayLike` 转为真正的数组。

---
### 0x04 箭头函数

```
var f = v => v;

//等同于:
var f = function (v) { return v;};
```

如果没有参数或者需要多个参数，就使用一个圆括号代表参数部分。

```
var f = () => 5;
// 等同于 
var f = function () { return 5;};

var sum = (sum1, sum2) => {sum1 + sum2;};
// 等同于
var sum = function (sum1 + sum2) {return sum1 + sum2}
```

如上，当函数体多于一条语句的时候便使用大括号 `{}` 将其括起。 

---
#### 箭头函数使用场景
下面是一些箭头函数使用的场景:

```
[1, 2, 3].map( x => x * x);

// 对数组排序
var result = values.sort((a, b) => a - b)

// 结合 rest 参数
const numbers = (...nums) => nums;
numbers(1, 2, 4, 5)
```

---
#### 箭头函数注意点

1. 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。箭头函数中，`this` 它是固定的。
2. 不可以当作构造函数，也就是说，不可以使用 `new` 命令。
3. 不可以使用 `arguments` 对象，该对象在函数体内不存在。如果要用，可以用 `Rest` 参数代替。
4. 不可以使用 `yield` 命令，因此箭头函数不能用作 `Generator` 函数。


由于箭头函数没有自己的 `this`，所以当然也就不能用`call()`、`apply()`、`bind()`这些方法去改变 `this` 的指向。


###


